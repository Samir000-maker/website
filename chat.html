
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat Room - MoodLog</title>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="global.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Manrope', sans-serif;
        }
        
        .reply-btn {
            opacity: 0;
            transition: opacity 0.15s ease;
            cursor: pointer;
        }
        .message-item:hover .reply-btn {
            opacity: 1;
        }
        
        .reply-preview {
            animation: slideUp 0.15s ease-out;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .quoted-message {
            border-left: 3px solid #93c5fd;
            padding-left: 8px;
            margin-bottom: 6px;
            background-color: rgba(255, 255, 255, 0.15);
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 0.813rem;
        }
        
        .quoted-message-light {
            background-color: rgba(0, 0, 0, 0.05);
            border-left-color: #4a9d9d;
        }

        .sidebar {
            transition: transform 0.2s ease;
        }
        
        .main-container {
            height: 100vh;
            height: 100dvh;
        }

        .chat-main {
            max-height: calc(100vh - 64px);
            max-height: calc(100dvh - 64px);
        }

        @media (max-width: 768px) {
            .chat-main {
                max-height: calc(100vh - 56px);
                max-height: calc(100dvh - 56px);
            }
        }
        
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100vh;
                width: 280px;
                z-index: 40;
                box-shadow: 2px 0 10px rgba(0,0,0,0.1);
                transform: translateX(-100%);
            }
            
            .sidebar.show {
                transform: translateX(0);
            }
            
            .sidebar-overlay {
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.5);
                z-index: 30;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.2s ease;
            }
            
            .sidebar-overlay.active {
                opacity: 1;
                pointer-events: auto;
            }
        }
        
        @media (min-width: 769px) {
            .sidebar {
                position: relative;
                width: 280px;
                min-width: 280px;
                display: block !important;
            }
            
            .sidebar-toggle {
                display: none;
            }
            
            .sidebar-overlay {
                display: none;
            }
        }

        .user-card {
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .user-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .calling {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .call-buttons-container {
            position: relative;
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        @media (max-width: 640px) {
            .call-buttons-container {
                gap: 8px;
            }
        }
        
        @supports (padding: max(0px)) {
            .header-safe {
                padding-top: max(1rem, env(safe-area-inset-top));
            }
            
            .bottom-safe {
                padding-bottom: max(1rem, env(safe-area-inset-bottom));
            }
        }
        
        @media (max-width: 640px) {
            #messageForm {
                gap: 8px;
            }
            
            #messageInput {
                font-size: 16px;
                min-height: 44px;
            }
            
            #messageForm button[type="submit"] {
                min-width: 44px;
                min-height: 44px;
            }
        }
        
        /* Confirmation Dialog Styles */
        .confirmation-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            opacity: 0;
            animation: fadeIn 0.15s ease-out forwards;
        }
        
        .confirmation-dialog {
            background: white;
            border-radius: 1.5rem;
            padding: 2rem;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            transform: scale(0.95) translateY(10px);
            animation: slideUpDialog 0.2s ease-out forwards;
        }
        
        .dark .confirmation-dialog {
            background: #22252a;
            border: 1px solid #374151;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        @keyframes slideUpDialog {
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        .confirmation-buttons {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }
        
        .confirmation-buttons button {
            flex: 1;
            padding: 0.875rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.15s ease;
            border: none;
            cursor: pointer;
        }
        
        .btn-stay {
            background: #367d7d;
            color: white;
        }
        
        .btn-stay:hover {
            background: #2d6666;
        }
        
        .btn-stay:active {
            transform: scale(0.97);
        }
        
        .btn-leave {
            background: #f3f4f6;
            color: #374151;
        }
        
        .dark .btn-leave {
            background: #374151;
            color: #e5e7eb;
        }
        
        .btn-leave:hover {
            background: #e5e7eb;
        }
        
        .dark .btn-leave:hover {
            background: #4b5563;
        }
        
        .btn-leave:active {
            transform: scale(0.97);
        }
        
        /* Animate message appearance */
        .animate-fade-in-up {
            animation: fadeInUp 0.2s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Loading state for buttons */
        .btn-loading {
            position: relative;
            pointer-events: none;
        }
        
        .btn-loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.6s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        
        
@keyframes pulse-slow {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.animate-pulse-slow {
    animation: pulse-slow 2s ease-in-out infinite;
}


@keyframes slideOutToRight {
    from {
        opacity: 1;
        transform: translateX(0);
    }
    to {
        opacity: 0;
        transform: translateX(100px);
    }
}

/* Pulsing avatar border for active speaker */
.speaking-border {
    animation: pulseBorder 1.5s ease-in-out infinite;
}

@keyframes pulseBorder {
    0%, 100% {
        border-color: #33bfcc;
        box-shadow: 0 0 0 0 rgba(51, 191, 204, 0.4);
    }
    50% {
        border-color: #2aa5b0;
        box-shadow: 0 0 0 4px rgba(51, 191, 204, 0.2);
    }
}

/* Responsive adjustments */
@media (max-width: 640px) {
    #floatingCallPopup {
        right: 0.75rem;
        top: 4.5rem;
    }
}
        
        
        /* Call Button Loading States */
.call-btn-loading {
    position: relative;
    pointer-events: none;
    opacity: 0.7;
}

.call-btn-loading .material-symbols-outlined {
    opacity: 0;
}

.call-btn-loading::after {
    content: '';
    position: absolute;
    width: 20px;
    height: 20px;
    top: 50%;
    left: 50%;
    margin-left: -10px;
    margin-top: -10px;
    border: 2.5px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #ffffff;
    animation: spin 0.8s linear infinite;
}

.join-btn-loading {
    position: relative;
    pointer-events: none;
    opacity: 0.7;
}

.join-btn-loading .material-symbols-outlined,
.join-btn-loading span:not(.loader) {
    opacity: 0;
}

.join-btn-loading::after {
    content: '';
    position: absolute;
    width: 18px;
    height: 18px;
    top: 50%;
    left: 50%;
    margin-left: -9px;
    margin-top: -9px;
    border: 2.5px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #ffffff;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}


@keyframes pulse-slow {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.animate-pulse-slow {
    animation: pulse-slow 2s ease-in-out infinite;
}
        
    </style>
</head>
<body class="bg-background-light main-container flex flex-col overflow-hidden">
    <header class="sticky top-0 z-50 w-full border-b border-gray-200 bg-white/95 backdrop-blur header-safe">
        <div class="mx-auto flex h-14 sm:h-16 max-w-full items-center justify-between px-3 sm:px-6">
            <div class="flex items-center gap-2 sm:gap-3 flex-1 min-w-0">
                <button id="sidebarToggle" class="sidebar-toggle p-2 hover:bg-gray-100 rounded-lg md:hidden flex-shrink-0">
                    <span class="material-symbols-outlined text-gray-700">menu</span>
                </button>
                
                <div class="min-w-0 flex-1">
                    <h2 class="text-base sm:text-lg font-bold truncate">Mindful Space</h2>
                    <div class="flex items-center gap-1.5 sm:gap-2 text-xs text-gray-500">
                        <span class="flex h-2 w-2 rounded-full bg-green-500 flex-shrink-0"></span>
                        <span id="onlineCount" class="truncate">Loading...</span>
                        <span class="hidden sm:inline">‚Ä¢</span>
                        <span id="timeRemaining" class="hidden sm:inline truncate">--:-- remaining</span>
                    </div>
                </div>
            </div>
            
            <div class="flex items-center gap-2 sm:gap-3 flex-shrink-0">
                <div class="call-buttons-container">
                    <button id="audioCallBtn" 
                        class="w-9 h-9 sm:w-10 sm:h-10 flex items-center justify-center rounded-full bg-primary text-white hover:bg-primary/90 transition-all"
                        title="Start Audio Call">
                        <span class="material-symbols-outlined text-lg sm:text-xl">call</span>
                    </button>
                    <button id="videoCallBtn" 
                        class="w-9 h-9 sm:w-10 sm:h-10 flex items-center justify-center rounded-full bg-primary text-white hover:bg-primary/90 transition-all"
                        title="Start Video Call">
                        <span class="material-symbols-outlined text-lg sm:text-xl">videocam</span>
                    </button>
                    <button id="joinCallBtn" 
                        class="hidden items-center gap-1.5 px-3 sm:px-4 h-9 sm:h-10 rounded-full bg-green-600 text-white hover:bg-green-700 transition-all text-xs sm:text-sm font-semibold"
                        title="Join Active Call">
                        <span class="material-symbols-outlined text-base sm:text-lg">login</span>
                        <span class="hidden sm:inline">Join Call</span>
                        <span class="sm:hidden">Join</span>
                    </button>
                </div>
                
                <button id="leaveBtn" class="text-xs sm:text-sm font-medium text-red-600 hover:text-red-700 px-2 sm:px-3 py-1.5 sm:py-2 whitespace-nowrap">
                    <span class="hidden sm:inline">Leave Room</span>
                    <span class="sm:hidden material-symbols-outlined text-xl">logout</span>
                </button>
            </div>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative chat-main">
        <div id="sidebarOverlay" class="sidebar-overlay"></div>
        
        <aside id="sidebar" class="sidebar border-r border-gray-200 bg-white overflow-y-auto">
            <div class="p-3 sm:p-4">
                <div class="flex items-center justify-between mb-3 sm:mb-4">
                    <h3 class="text-xs font-bold text-gray-500 uppercase">Active Users</h3>
                    <button id="sidebarClose" class="md:hidden p-1 hover:bg-gray-100 rounded">
                        <span class="material-symbols-outlined text-gray-500 text-xl">close</span>
                    </button>
                </div>
                <div id="usersList" class="space-y-2 sm:space-y-3"></div>
            </div>
        </aside>

        <main class="flex-1 flex flex-col min-h-0 bg-white">
            <div id="messagesList" class="flex-1 overflow-y-auto px-2 sm:px-4 py-3 sm:py-6 space-y-2 sm:space-y-4 min-h-0">
                <div class="text-center text-xs sm:text-sm text-gray-400 mb-4">
                    Welcome to the safe space. Be kind and supportive.
                </div>
            </div>

            <div class="border-t border-gray-200 bg-white flex-shrink-0 sticky bottom-0 left-0 right-0 z-10" style="padding-bottom: env(safe-area-inset-bottom, 0px);">
                <div id="replyPreview" class="reply-preview hidden border-b border-gray-200 px-3 py-2 bg-gray-50">
                    <div class="flex items-start justify-between gap-2">
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-1.5 mb-1">
                                <span class="material-symbols-outlined text-primary text-sm">subdirectory_arrow_left</span>
                                <span class="text-xs font-medium text-primary" id="replyToUsername">Replying to User</span>
                            </div>
                            <p class="text-xs text-gray-600 truncate" id="replyToMessage">Original message text</p>
                        </div>
                        <button id="cancelReply" class="text-gray-400 hover:text-gray-600 p-1">
                            <span class="material-symbols-outlined text-lg">close</span>
                        </button>
                    </div>
                </div>
                
                <div class="p-3 pb-4">
                    <form id="messageForm" class="flex gap-2 items-center">
                        <input type="text" id="messageInput" required maxlength="500"
                            class="flex-1 px-4 py-3 text-base border-2 border-gray-300 rounded-xl focus:border-primary focus:outline-none bg-white"
                            placeholder="Type a message..." style="min-width: 0; -webkit-appearance: none;">
                        <button type="submit" class="w-12 h-12 flex-shrink-0 flex items-center justify-center bg-primary text-white rounded-xl hover:bg-primary/90 active:scale-95 transition-transform">
                            <span class="material-symbols-outlined">send</span>
                        </button>
                    </form>
                </div>
            </div>
        </main>
    </div>

    <div id="incomingCallModal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[100] flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl shadow-2xl p-6 sm:p-8 max-w-sm w-full animate-fade-in">
            <div class="text-center">
                <div class="mb-4 sm:mb-6">
                    <div id="callerAvatar" class="w-20 h-20 sm:w-24 sm:h-24 mx-auto rounded-full overflow-hidden bg-primary/20 flex items-center justify-center">
                        <span class="text-3xl sm:text-4xl">üìû</span>
                    </div>
                </div>
                <h3 class="text-lg sm:text-xl font-bold mb-2" id="callerName">Incoming Call</h3>
                <p class="text-sm sm:text-base text-gray-600 mb-6 sm:mb-8" id="callType">Audio Call</p>
                
                <div class="flex gap-3 sm:gap-4 justify-center">
                    <button id="declineCallBtn" 
                        class="flex items-center gap-2 px-5 sm:px-6 py-2.5 sm:py-3 rounded-xl bg-red-500 text-white hover:bg-red-600 transition-all text-sm sm:text-base">
                        <span class="material-symbols-outlined text-lg sm:text-xl">call_end</span>
                        <span class="font-medium">Decline</span>
                    </button>
                    <button id="acceptCallBtn" 
                        class="flex items-center gap-2 px-5 sm:px-6 py-2.5 sm:py-3 rounded-xl bg-green-500 text-white hover:bg-green-600 transition-all text-sm sm:text-base">
                        <span class="material-symbols-outlined text-lg sm:text-xl">call</span>
                        <span class="font-medium">Accept</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Dialog (hidden by default) -->
    <div id="confirmationOverlay" style="display: none;"></div>
    
    

<div id="floatingReturnToCall" class="hidden fixed bottom-20 right-4 z-[60] bg-green-600 rounded-full shadow-2xl p-4 cursor-pointer hover:scale-110 transition-all active:scale-95 animate-pulse-slow">
    <div class="relative flex items-center justify-center">
        <span class="material-symbols-outlined text-white text-3xl">call</span>
        <div class="absolute -top-2 -right-2 w-5 h-5 bg-white rounded-full border-2 border-green-600 flex items-center justify-center">
            <span class="material-symbols-outlined text-green-600 text-xs">arrow_back</span>
        </div>
    </div>
</div>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };

      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>

    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="app.js"></script>

    <script>
(async () => {
  const MoodApp = window.MoodApp || {};
  const _Auth = MoodApp.Auth;
  const _API = MoodApp.API;
  const _Toast = MoodApp.Toast;
  const _Utils = MoodApp.Utils;

  const toast = (m, t='success') => { 
    if (_Toast && typeof _Toast[t] === 'function') return _Toast[t](m); 
    console[t==='error'?'error':'log'](m); 
  };

  // ============================================
  // STORAGE KEYS
  // ============================================
  const CHAT_STATE_KEY = 'chat_state';
  const CHAT_MESSAGES_KEY = 'chat_messages';
  const CHAT_TIMESTAMP_KEY = 'chat_timestamp';
  const ACTIVE_CALL_KEY = 'activeCall';
  
  // ============================================
  // STATE MANAGEMENT
  // ============================================
  let replyingTo = null;
  let isInitiatingCall = false;
  let pendingCallData = null;
  let navigatingToCall = false;
  let messagesCache = [];
  let activeCallInRoom = null;
  let backButtonHandled = false;
  let timerInterval = null;
  let socketInstance = null;
  let currentUser = null;
  let roomData = null;
  let serverClockOffset = 0; // Milliseconds to add to client time to get server time
  let serverExpiresAt = null; // Absolute server timestamp for expiry
  
  let floatingCallPopup = null;
let floatingCallSocket = null;
let currentSpeaker = null;
let isInBackgroundCall = false;
  
  // ============================================
  // DOM ELEMENTS (Initialized early)
  // ============================================
  const sidebar = document.getElementById('sidebar');
  const sidebarToggle = document.getElementById('sidebarToggle');
  const sidebarClose = document.getElementById('sidebarClose');
  const sidebarOverlay = document.getElementById('sidebarOverlay');
  const messagesList = document.getElementById('messagesList');
  const messageForm = document.getElementById('messageForm');
  const messageInput = document.getElementById('messageInput');
  const usersList = document.getElementById('usersList');
  const onlineCount = document.getElementById('onlineCount');
  const timeRemaining = document.getElementById('timeRemaining');
  const leaveBtn = document.getElementById('leaveBtn');
  const cancelReplyBtn = document.getElementById('cancelReply');
  const audioCallBtn = document.getElementById('audioCallBtn');
  const videoCallBtn = document.getElementById('videoCallBtn');
  const joinCallBtn = document.getElementById('joinCallBtn');
  const incomingCallModal = document.getElementById('incomingCallModal');
  const acceptCallBtn = document.getElementById('acceptCallBtn');
  const declineCallBtn = document.getElementById('declineCallBtn');
  
  // ============================================
  // UTILITY FUNCTIONS
  // ============================================
  
  
  
  function initializeFloatingCallPopup() {
  console.log('üéà Initializing floating call popup elements');
  
  floatingCallPopup = {
    container: document.getElementById('floatingCallPopup'),
    avatar: document.getElementById('floatingCallAvatar'),
    username: document.getElementById('floatingCallUsername'),
    status: document.getElementById('floatingCallStatus'),
    returnBtn: document.getElementById('returnToCallBtn')
  };
  
  if (!floatingCallPopup.container) {
    console.error('‚ùå Floating call popup container not found in DOM');
    return false;
  }
  
  console.log('‚úÖ Floating call popup elements initialized');
  return true;
}

function showFloatingCallPopup(callData, participants) {
  console.log('üéà ========================================');
  console.log('üéà SHOWING FLOATING CALL POPUP');
  console.log('üéà ========================================');
  console.log(`   callId: ${callData?.callId}`);
  console.log(`   participants: ${participants?.length || 0}`);
  
  if (!floatingCallPopup || !floatingCallPopup.container) {
    console.error('‚ùå Floating call popup not initialized');
    return;
  }
  
  // Mark that we're in background call mode
  isInBackgroundCall = true;
  console.log('‚úÖ Background call mode activated');
  
  // Find a participant to display (prefer someone other than current user)
  let displayParticipant = participants?.find(p => p.userId !== currentUser.userId);
  
  if (!displayParticipant && participants?.length > 0) {
    displayParticipant = participants[0];
    console.log('‚ÑπÔ∏è Only current user in call, showing self');
  }
  
  if (!displayParticipant) {
    console.warn('‚ö†Ô∏è No participants to display in popup');
    displayParticipant = {
      userId: currentUser.userId,
      username: currentUser.username,
      pfpUrl: currentUser.pfpUrl
    };
  }
  
  console.log(`üë§ Displaying participant: ${displayParticipant.username} (${displayParticipant.userId})`);
  
  // Set avatar
  if (floatingCallPopup.avatar) {
    floatingCallPopup.avatar.innerHTML = '';
    const pfpElement = createProfilePictureElement(
      displayParticipant.pfpUrl, 
      displayParticipant.username, 
      'w-full h-full'
    );
    floatingCallPopup.avatar.appendChild(pfpElement);
  }
  
  // Set username
  if (floatingCallPopup.username) {
    floatingCallPopup.username.textContent = displayParticipant.username;
  }
  
  // Set initial status
  if (floatingCallPopup.status) {
    floatingCallPopup.status.textContent = 'In call...';
  }
  
  // Show the popup
  floatingCallPopup.container.classList.remove('hidden');
  console.log('‚úÖ Floating call popup displayed');
  
  // Setup return button click handler
  if (floatingCallPopup.returnBtn) {
    floatingCallPopup.returnBtn.onclick = () => {
      console.log('üîô Return to call button clicked');
      returnToActiveCall();
    };
  }
  
  // Initialize socket connection for call updates
  initializeFloatingCallSocket();
  
  console.log('üéà ========================================\n');
}

function hideFloatingCallPopup() {
  console.log('üéà Hiding floating call popup');
  
  if (!floatingCallPopup || !floatingCallPopup.container) {
    console.warn('‚ö†Ô∏è Floating call popup not initialized');
    return;
  }
  
  isInBackgroundCall = false;
  currentSpeaker = null;
  
  // Disconnect floating socket if exists
  if (floatingCallSocket) {
    console.log('üîå Disconnecting floating call socket');
    floatingCallSocket.disconnect();
    floatingCallSocket = null;
  }
  
  floatingCallPopup.container.classList.add('hidden');
  console.log('‚úÖ Floating call popup hidden');
}

function updateFloatingCallSpeaker(userId, username, speaking) {
  console.log(`üé§ Speaker update: ${username} (${userId}) - speaking: ${speaking}`);
  
  if (!floatingCallPopup || !isInBackgroundCall) {
    return;
  }
  
  if (speaking) {
    currentSpeaker = { userId, username };
    
    // Update status
    if (floatingCallPopup.status) {
      floatingCallPopup.status.textContent = 'Speaking...';
    }
    
    // Add pulsing border effect
    if (floatingCallPopup.avatar) {
      floatingCallPopup.avatar.classList.add('speaking-border');
    }
    
    console.log(`‚úÖ ${username} marked as speaking in popup`);
  } else {
    if (currentSpeaker?.userId === userId) {
      currentSpeaker = null;
      
      // Update status
      if (floatingCallPopup.status) {
        floatingCallPopup.status.textContent = 'In call...';
      }
      
      // Remove pulsing border effect
      if (floatingCallPopup.avatar) {
        floatingCallPopup.avatar.classList.remove('speaking-border');
      }
      
      console.log(`‚úÖ ${username} stopped speaking in popup`);
    }
  }
}

function initializeFloatingCallSocket() {
  console.log('üîå Initializing floating call socket connection');
  
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  if (!activeCallStr) {
    console.error('‚ùå No active call data in localStorage');
    return;
  }
  
  let activeCallData;
  try {
    activeCallData = JSON.parse(activeCallStr);
  } catch (e) {
    console.error('‚ùå Failed to parse active call data:', e);
    return;
  }
  
  if (floatingCallSocket) {
    console.log('‚ÑπÔ∏è Floating call socket already exists, reusing');
    return;
  }
  
  firebase.auth().currentUser?.getIdToken().then(idToken => {
    const socketUrl = window.location.origin;
    
    floatingCallSocket = io(socketUrl, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 500,
      reconnectionAttempts: 10,
      auth: { token: idToken },
      timeout: 10000
    });
    
    console.log('‚úÖ Floating call socket created');
    
    // Setup socket handlers
    floatingCallSocket.on('connect', () => {
      console.log('üîå Floating socket connected:', floatingCallSocket.id);
      
      floatingCallSocket.emit('authenticate', {
        token: idToken,
        userId: currentUser.userId
      });
    });
    
    floatingCallSocket.on('authenticated', () => {
      console.log('‚úÖ Floating socket authenticated');
    });
    
    floatingCallSocket.on('speaking_state', (data) => {
      console.log(`üé§ [FLOATING] Speaking state: ${data.userId} - ${data.speaking}`);
      
      // Find username from room data
      const participant = roomData?.users?.find(u => u.userId === data.userId);
      const username = participant?.username || 'User';
      
      updateFloatingCallSpeaker(data.userId, username, data.speaking);
    });
    
    floatingCallSocket.on('user_left_call', (data) => {
      console.log(`üëã [FLOATING] User left call: ${data.userId}`);
      
      // If the displayed user leaves, might need to update popup
      if (floatingCallPopup?.username?.textContent === data.username) {
        console.log('‚ö†Ô∏è Displayed user left call - might need to update popup');
      }
    });
    
    floatingCallSocket.on('call_ended', () => {
      console.log('üìû [FLOATING] Call ended - hiding popup');
      hideFloatingCallPopup();
      localStorage.removeItem(ACTIVE_CALL_KEY);
    });
    
    floatingCallSocket.on('disconnect', () => {
      console.log('üîå Floating socket disconnected');
    });
    
  }).catch(err => {
    console.error('‚ùå Failed to get token for floating socket:', err);
  });
}

function returnToActiveCall() {
  console.log('üîô ========================================');
  console.log('üîô RETURNING TO ACTIVE CALL FROM CHAT');
  console.log('üîô ========================================');
  
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  if (!activeCallStr) {
    console.error('‚ùå No active call data found');
    toast('No active call found', 'error');
    hideFloatingCallPopup();
    return;
  }
  
  try {
    const activeCallData = JSON.parse(activeCallStr);
    console.log(`   callId: ${activeCallData.callId}`);
    console.log(`   callType: ${activeCallData.callType}`);
    console.log(`   backgroundMode: ${activeCallData.backgroundMode}`);
    
    // Mark that we're returning to call (not starting new call)
    navigatingToCall = true;
    
    // CRITICAL: Remove background mode flag so call page knows we're coming back
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    
    // Mark that we're returning to existing call
    sessionStorage.setItem('returningToBackgroundCall', 'true');
    
    // Save current chat state
    saveChatState(roomData.roomId, messagesCache);
    
    // Disconnect floating socket before navigating
    if (floatingCallSocket) {
      console.log('üîå Disconnecting floating socket (will reconnect on call page)');
      floatingCallSocket.disconnect();
      floatingCallSocket = null;
    }
    
    console.log('‚úÖ Navigating back to call page');
    window.location.href = '/call.html';
    
  } catch (e) {
    console.error('‚ùå Failed to parse active call data:', e);
    toast('Failed to return to call', 'error');
  }
  
  console.log('üîô ========================================\n');
}

function checkForBackgroundCall() {
  const hasBackgroundCall = sessionStorage.getItem('hasBackgroundCall') === 'true';
  const activeCallStr = localStorage.getItem('activeCall');
  
  console.log('üîç Checking for background call...');
  console.log(`   hasBackgroundCall flag: ${hasBackgroundCall}`);
  console.log(`   activeCall in storage: ${!!activeCallStr}`);
  
  if (hasBackgroundCall && activeCallStr) {
    console.log('‚úÖ Background call detected - showing return button');
    
    const returnBtn = document.getElementById('floatingReturnToCall');
    if (returnBtn) {
      returnBtn.classList.remove('hidden');
      
      returnBtn.onclick = () => {
        console.log('üìû Floating button clicked - returning to call');
        
        // CRITICAL: Don't clear hasBackgroundCall flag
        // Just navigate back to call
        window.location.href = '/call.html';
      };
      
      console.log('‚úÖ Floating return button activated');
    } else {
      console.error('‚ùå floatingReturnToCall button not found in DOM!');
    }
  } else {
    console.log('‚ÑπÔ∏è No background call detected');
  }
}
  
  
  
  function saveChatState(roomId, messages) {
    try {
      const state = {
        roomId,
        messages: messages || [],
        timestamp: Date.now()
      };
      localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(state));
      localStorage.setItem(CHAT_TIMESTAMP_KEY, Date.now().toString());
      console.log('‚úÖ Chat state saved:', messages.length, 'messages');
    } catch (e) {
      console.warn('‚ö†Ô∏è Failed to save chat state:', e);
    }
  }
  
  function loadChatState() {
    try {
      const stateStr = localStorage.getItem(CHAT_STATE_KEY);
      if (!stateStr) return null;
      
      const state = JSON.parse(stateStr);
      console.log('‚úÖ Chat state loaded:', state.messages?.length || 0, 'messages');
      return state;
    } catch (e) {
      console.warn('‚ö†Ô∏è Failed to load chat state:', e);
      return null;
    }
  }
  
  function clearChatState() {
    localStorage.removeItem(CHAT_STATE_KEY);
    localStorage.removeItem(CHAT_MESSAGES_KEY);
    localStorage.removeItem(CHAT_TIMESTAMP_KEY);
    console.log('üóëÔ∏è Chat state cleared');
  }

  function clearAllChatData() {
    // CRITICAL: Clear ALL chat-related data on entry
    localStorage.removeItem(CHAT_STATE_KEY);
    localStorage.removeItem(CHAT_MESSAGES_KEY);
    localStorage.removeItem(CHAT_TIMESTAMP_KEY);
    // Don't clear currentRoom or activeCall - those are needed
    console.log('üßπ All chat state cleared on entry');
  }
  
  function escapeHtml(text) {
    if (_Utils && typeof _Utils.escapeHtml === 'function') {
      return _Utils.escapeHtml(text);
    }
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function formatTimestamp(timestamp) {
    if (_Utils && typeof _Utils.formatDate === 'function') {
      return _Utils.formatDate(timestamp);
    }
    return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // ============================================
  // CALL STATE MANAGEMENT
  // ============================================
  
 function setInitialCallButtonState() {
    console.log('üîç Checking for active call in localStorage...');
    
    // Show loading state initially
    if (joinCallBtn) {
        joinCallBtn.classList.add('join-btn-loading');
        joinCallBtn.classList.add('flex');
        joinCallBtn.classList.remove('hidden');
    }
    if (audioCallBtn) {
        audioCallBtn.classList.add('call-btn-loading');
    }
    if (videoCallBtn) {
        videoCallBtn.classList.add('call-btn-loading');
    }
    
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    
    if (activeCallStr) {
        try {
            const activeCallData = JSON.parse(activeCallStr);
            
            if (activeCallData.roomId === roomData?.roomId) {
                console.log(`üìû Active call found: ${activeCallData.callId} in room ${activeCallData.roomId}`);
                
                activeCallInRoom = {
                    callId: activeCallData.callId,
                    participantCount: 1,
                    callType: activeCallData.callType
                };
                
                // Keep loading state - will be removed when socket confirms
                console.log('‚úÖ Initial call state set (waiting for socket confirmation)');
                return true;
            } else {
                console.log(`‚ùå Room mismatch: ${activeCallData.roomId} !== ${roomData?.roomId}`);
            }
        } catch (e) {
            console.error('‚ùå Failed to parse activeCall:', e);
            localStorage.removeItem(ACTIVE_CALL_KEY);
        }
    }
    
    // Keep loading state - will be removed when socket confirms no active call
    return false;
}
  
  function updateCallButtonState(isActive, callData = null) {
    // Remove loading states
    if (audioCallBtn) audioCallBtn.classList.remove('call-btn-loading');
    if (videoCallBtn) videoCallBtn.classList.remove('call-btn-loading');
    if (joinCallBtn) joinCallBtn.classList.remove('join-btn-loading');
    
    if (isActive && callData) {
        activeCallInRoom = {
            callId: callData.callId,
            participantCount: callData.participantCount || 1,
            callType: callData.callType || 'video'
        };
        
        if (joinCallBtn) {
            joinCallBtn.classList.remove('hidden');
            joinCallBtn.classList.add('flex');
        }
        if (audioCallBtn) audioCallBtn.classList.add('hidden');
        if (videoCallBtn) videoCallBtn.classList.add('hidden');
        
        console.log(`‚úÖ Call buttons updated: JOIN visible`);
    } else {
        activeCallInRoom = null;
        
        if (joinCallBtn) {
            joinCallBtn.classList.remove('flex');
            joinCallBtn.classList.add('hidden');
        }
        if (audioCallBtn) audioCallBtn.classList.remove('hidden');
        if (videoCallBtn) videoCallBtn.classList.remove('hidden');
        
        console.log(`‚úÖ Call buttons updated: AUDIO/VIDEO visible`);
    }
}

  // ============================================
  // UI FUNCTIONS
  // ============================================
  
  function openSidebar() {
    if (!sidebar || !sidebarOverlay) return;
    sidebar.classList.add('show');
    sidebarOverlay.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  function closeSidebar() {
    if (!sidebar || !sidebarOverlay) return;
    sidebar.classList.remove('show');
    sidebarOverlay.classList.remove('active');
    document.body.style.overflow = '';
  }

  function toggleSidebar() {
    if (!sidebar) return;
    sidebar.classList.contains('show') ? closeSidebar() : openSidebar();
  }

  function setupUserCardClick() {
    if (window.innerWidth <= 768) {
      document.querySelectorAll('.user-card').forEach(card => {
        card.addEventListener('click', closeSidebar, { passive: true });
      });
    }
  }

  function createProfilePictureElement(pfpUrl, username, size = 'w-10 h-10') {
    const initial = username ? username.charAt(0).toUpperCase() : 'U';
    const container = document.createElement('div');
    container.className = `${size} rounded-full overflow-hidden bg-slate-100 border-2 border-white shadow-sm flex-shrink-0`;
    
    if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
      const img = document.createElement('img');
      img.src = pfpUrl;
      img.alt = username;
      img.className = 'h-full w-full object-cover';
      img.loading = 'lazy';
      img.onerror = function() {
        this.onerror = null;
        container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-sm">${initial}</div>`;
      };
      container.appendChild(img);
    } else {
      container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-sm">${initial}</div>`;
    }
    
    return container;
  }

  function showReplyPreview(messageData) {
    replyingTo = messageData;
    const replyPreview = document.getElementById('replyPreview');
    const replyToUsername = document.getElementById('replyToUsername');
    const replyToMessage = document.getElementById('replyToMessage');
    
    if (replyPreview && replyToUsername && replyToMessage) {
      replyToUsername.textContent = `Replying to ${messageData.username}`;
      replyToMessage.textContent = messageData.message;
      replyPreview.classList.remove('hidden');
      
      if (messageInput) messageInput.focus();
    }
  }

  function hideReplyPreview() {
    replyingTo = null;
    const replyPreview = document.getElementById('replyPreview');
    if (replyPreview) replyPreview.classList.add('hidden');
  }

  function createMessageElement(data, isCurrentUser) {
    const messageItem = document.createElement('div');
    messageItem.className = `message-item flex gap-2 items-start ${isCurrentUser ? 'flex-row-reverse' : ''} animate-fade-in-up`;
    messageItem.dataset.messageId = data.messageId || `msg-${Date.now()}-${Math.random()}`;
    
    const pfpContainer = createProfilePictureElement(data.pfpUrl, data.username, 'w-8 h-8 sm:w-10 sm:h-10');
    const messageContent = document.createElement('div');
    messageContent.className = `flex flex-col ${isCurrentUser ? 'items-end' : 'items-start'} flex-1 min-w-0`;

    const headerDiv = document.createElement('div');
    headerDiv.className = `flex items-center gap-1.5 sm:gap-2 mb-1 px-1 ${isCurrentUser ? 'flex-row-reverse' : ''}`;
    
    const usernameSpan = document.createElement('span');
    usernameSpan.className = 'text-xs sm:text-sm font-semibold text-gray-900 truncate';
    usernameSpan.textContent = data.username || 'User';
    
    const timestampSpan = document.createElement('span');
    timestampSpan.className = 'text-[10px] sm:text-xs text-gray-400 whitespace-nowrap';
    timestampSpan.textContent = data.timestamp ? formatTimestamp(data.timestamp) : 'Just now';
    
    headerDiv.appendChild(usernameSpan);
    headerDiv.appendChild(timestampSpan);
    messageContent.appendChild(headerDiv);

    const bubbleWrapper = document.createElement('div');
    bubbleWrapper.className = `flex items-center gap-1`;

    const messageBubble = document.createElement('div');
    messageBubble.className = `px-3 sm:px-4 py-2 rounded-2xl ${isCurrentUser ? 'bg-primary text-white' : 'bg-gray-100 text-gray-900'} break-words text-sm sm:text-base max-w-full`;

    if (data.replyTo) {
      const quotedDiv = document.createElement('div');
      quotedDiv.className = `quoted-message ${isCurrentUser ? '' : 'quoted-message-light'}`;
      
      const quotedUsername = document.createElement('div');
      quotedUsername.className = `text-xs font-semibold mb-1 ${isCurrentUser ? 'text-blue-200' : 'text-primary'}`;
      quotedUsername.textContent = data.replyTo.username;
      
      const quotedText = document.createElement('div');
      quotedText.className = `text-xs ${isCurrentUser ? 'text-white/80' : 'text-gray-600'} break-words`;
      quotedText.textContent = data.replyTo.message;
      
      quotedDiv.appendChild(quotedUsername);
      quotedDiv.appendChild(quotedText);
      messageBubble.appendChild(quotedDiv);
    }

    const messageText = document.createElement('div');
    messageText.className = 'text-sm sm:text-base break-words';
    messageText.innerHTML = escapeHtml(data.message || '');
    messageBubble.appendChild(messageText);

    const replyBtn = document.createElement('button');
    replyBtn.className = 'reply-btn p-1 sm:p-1.5 hover:bg-gray-100 rounded-full transition-colors flex-shrink-0';
    replyBtn.title = 'Reply';
    replyBtn.innerHTML = '<span class="material-symbols-outlined text-gray-400 text-base sm:text-lg">reply</span>';
    replyBtn.addEventListener('click', () => {
      showReplyPreview({
        messageId: messageItem.dataset.messageId,
        username: data.username,
        message: data.message,
        userId: data.userId
      });
    }, { passive: true });

    // Current user: reply button left, bubble right
    // Other users: bubble left, reply button right
    if (isCurrentUser) {
      bubbleWrapper.appendChild(replyBtn);
      bubbleWrapper.appendChild(messageBubble);
    } else {
      bubbleWrapper.appendChild(messageBubble);
      bubbleWrapper.appendChild(replyBtn);
    }

    messageContent.appendChild(bubbleWrapper);
    messageItem.appendChild(pfpContainer);
    messageItem.appendChild(messageContent);
    
    return messageItem;
  }

  // ============================================
  // CONFIRMATION DIALOG
  // ============================================
  
  function showConfirmationDialog() {
    return new Promise((resolve) => {
      const overlay = document.getElementById('confirmationOverlay');
      if (!overlay) return resolve(false);
      
      const dialogHTML = `
        <div class="confirmation-overlay">
          <div class="confirmation-dialog">
            <div style="text-align: center; margin-bottom: 1rem;">
              <div style="width: 64px; height: 64px; margin: 0 auto 1rem; background: #fef2f2; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                <span class="material-symbols-outlined" style="font-size: 32px; color: #dc2626;">warning</span>
              </div>
              <h3 style="font-size: 1.25rem; font-weight: 700; margin-bottom: 0.5rem; color: #1f2937;">Leave Chat Room?</h3>
              <p style="color: #6b7280; font-size: 0.95rem; line-height: 1.5;">
                You're currently in an active chat room. If you leave, you'll be disconnected from the conversation.
              </p>
            </div>
            <div class="confirmation-buttons">
              <button class="btn-stay" id="btnStay">Stay Here</button>
              <button class="btn-leave" id="btnLeave">Leave</button>
            </div>
          </div>
        </div>
      `;
      
      overlay.innerHTML = dialogHTML;
      overlay.style.display = 'flex';
      
      const btnStay = document.getElementById('btnStay');
      const btnLeave = document.getElementById('btnLeave');
      
      if (btnStay) {
        btnStay.addEventListener('click', () => {
          overlay.style.display = 'none';
          resolve(false);
        }, { once: true });
      }
      
      if (btnLeave) {
        btnLeave.addEventListener('click', () => {
          overlay.style.display = 'none';
          resolve(true);
        }, { once: true });
      }
    });
  }

  // ============================================
  // BACK BUTTON HANDLER
  // ============================================
  
  function setupBackButtonHandler() {
    history.pushState({ page: 'chat' }, '', window.location.href);
    
    window.addEventListener('popstate', async (event) => {
      if (backButtonHandled) return;
      
      console.log('‚¨ÖÔ∏è Back button pressed');
      history.pushState({ page: 'chat' }, '', window.location.href);
      
      const shouldLeave = await showConfirmationDialog();
      
      if (shouldLeave) {
        console.log('‚úÖ User confirmed leaving');
        backButtonHandled = true;
        
        if (socketInstance?.connected) {
          socketInstance.emit('leave_room');
        }
        
        clearChatState();
        window.location.href = '/mood.html';
      } else {
        console.log('‚ùå User staying in chat');
      }
    });
  }
const updateTimer = () => {
  if (!serverExpiresAt) {
    // Don't show anything if no server time yet
    return;
  }
  
  // Use server-adjusted time
  const clientNow = Date.now();
  const serverNow = clientNow + serverClockOffset;
  const remaining = Math.max(0, serverExpiresAt - serverNow);
  
  const minutes = Math.floor(remaining / 60000);
  const seconds = Math.floor((remaining % 60000) / 1000);
  
  if (timeRemaining) {
    timeRemaining.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} remaining`;
  }
  
  // Check for expiry
  if (remaining === 0) {
    console.error('‚è∞ CHAT: TIMER EXPIRED');
    
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    
    // Disconnect socket
    if (socketInstance) {
      socketInstance.disconnect();
    }
    
    // Clear ALL storage - both call and room
    localStorage.removeItem('activeCall');
    localStorage.removeItem('currentRoom');
    sessionStorage.removeItem('hasBackgroundCall');
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    sessionStorage.removeItem('returningToBackgroundCall');
    clearChatState();
    
    toast('Room has expired', 'warning');
    
    setTimeout(() => { 
      window.location.href = '/mood.html'; 
    }, 1500);
  }
};

  // ============================================
  // SOCKET EVENT HANDLERS
  // ============================================
  
  function setupSocketHandlers() {
    if (!socketInstance) return;
    
    socketInstance.on('connect', () => {
      console.log('üîå Socket connected:', socketInstance.id);
      
      firebase.auth().currentUser?.getIdToken().then(idToken => {
        socketInstance.emit('authenticate', {
          token: idToken,
          userId: currentUser.userId
        });
      }).catch(err => {
        console.error('‚ùå Failed to get token:', err);
      });
    });

    socketInstance.on('authenticated', () => {
  console.log('‚úÖ Authenticated - joining room');
  
  // Request room sync data for timer
  socketInstance.emit('request_room_sync', { roomId: roomData.roomId });
  
  // Join room
  socketInstance.emit('join_room', { roomId: roomData.roomId });
});;

    socketInstance.on('room_joined', (data) => {
  console.log('‚úÖ ========================================');
  console.log('‚úÖ ROOM_JOINED EVENT RECEIVED');
  console.log('‚úÖ ========================================');
  console.log(`   roomId: ${data.roomId}`);
  
  // ... [Keep all existing validation and timer sync code] ...
  
  // Handle chat history
  if (data.chatHistory?.length > 0) {
    console.log(`üìú Loading ${data.chatHistory.length} messages`);
    
    const existingIds = new Set(messagesCache.map(m => m.messageId || `${m.userId}-${m.timestamp}`));
    
    data.chatHistory.forEach(msg => {
      const msgId = msg.messageId || `${msg.userId}-${msg.timestamp}`;
      if (existingIds.has(msgId)) return;
      
      const isCurrentUser = msg.userId === currentUser.userId;
      const msgEl = createMessageElement(msg, isCurrentUser);
      messagesList?.appendChild(msgEl);
      messagesCache.push(msg);
    });
    
    if (messagesList) {
      messagesList.scrollTop = messagesList.scrollHeight;
    }
    
    saveChatState(roomData.roomId, messagesCache);
  }
  
  // CRITICAL: Check for background call AFTER room data is loaded
  const returningFromCall = sessionStorage.getItem('returningFromCall');
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  
  if (returningFromCall === 'true' && activeCallStr) {
    console.log('üéà User returned from call - showing floating popup');
    
    try {
      const activeCallData = JSON.parse(activeCallStr);
      
      if (activeCallData.roomId === roomData.roomId) {
        // Initialize popup elements if not already done
        if (!floatingCallPopup) {
          initializeFloatingCallPopup();
        }
        
        // Get participants for popup display
        const participants = activeCallData.users || roomData.users || [];
        
        // Show the floating popup
        showFloatingCallPopup(activeCallData, participants);
        
        // Clear the flag so it doesn't show again on refresh
        sessionStorage.removeItem('returningFromCall');
        
        console.log('‚úÖ Floating call popup displayed');
      }
    } catch (e) {
      console.error('‚ùå Failed to show floating popup:', e);
      sessionStorage.removeItem('returningFromCall');
    }
  }
  
  // Handle active call state (for call buttons)
  if (data.activeCall) {
    console.log('üìû Active call confirmed:', data.activeCall);
    updateCallButtonState(true, data.activeCall);
  } else {
    console.log('üìû No active call in room');
    updateCallButtonState(false);
  }
  
  // Start timer updates immediately
  console.log('‚è∞ Starting timer updates with server time...');
  updateTimer();
  
  if (data.expiresAt) {
    serverExpiresAt = data.expiresAt;
    
    // Calculate server time offset if provided
    if (data.serverTime) {
      const clientNow = Date.now();
      serverClockOffset = data.serverTime - clientNow;
      
      console.log(`‚è∞ Clock sync: offset = ${(serverClockOffset / 1000).toFixed(1)}s`);
    }
    
    // Update localStorage
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const roomData = JSON.parse(roomStr);
        roomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(roomData));
      } catch (e) {}
    }
    
    console.log(`‚úÖ Timer data received: expires at ${new Date(serverExpiresAt).toISOString()}`);
    updateTimer(); // Update immediately
  }
  
});

    socketInstance.on('room_expired', (data) => {
  console.error('üí• Room expired event from server');
  if (timerInterval) clearInterval(timerInterval);
  
  // ADD THIS: Clear call-related storage
  localStorage.removeItem('activeCall');
  sessionStorage.removeItem('hasBackgroundCall');
  sessionStorage.removeItem('returningFromCall');
  
  toast('Room has expired', 'warning');
  clearChatState();
  setTimeout(() => window.location.href = '/mood.html', 2000);
});

    socketInstance.on('error', (data) => {
      console.error('‚ùå Socket error:', data);
      if (data.code === 'ROOM_NOT_FOUND' || data.code === 'NOT_IN_ROOM') {
        toast('Room no longer available', 'error');
        clearChatState();
        setTimeout(() => window.location.href = '/mood.html', 2000);
      } else {
        toast(data.message || 'An error occurred', 'error');
      }
    });

    socketInstance.on('chat_message', (data) => {
      if (!data.messageId) {
        data.messageId = `msg-${data.userId}-${data.timestamp || Date.now()}`;
      }
      
      const isCurrentUser = data.userId === currentUser.userId;
      const msgEl = createMessageElement(data, isCurrentUser);
      
      if (messagesList) {
        messagesList.appendChild(msgEl);
        messagesList.scrollTop = messagesList.scrollHeight;
      }
      
      messagesCache.push(data);
      saveChatState(roomData.roomId, messagesCache);
    });

    socketInstance.on('user_left', (data) => {
      const msgEl = document.createElement('div');
      msgEl.className = 'text-center text-xs sm:text-sm text-gray-400 my-2';
      msgEl.textContent = `${data.username || 'A user'} left the room`;
      messagesList?.appendChild(msgEl);

      if (onlineCount && data.remainingUsers !== undefined) {
        onlineCount.textContent = `${data.remainingUsers} Online`;
      }

      if (data.remainingUsers <= 1) {
        toast('Room closing...', 'warning');
        clearChatState();
        setTimeout(() => window.location.href = '/mood.html', 2000);
      }
    });

socketInstance.on('left_room', (data) => {
  console.log('‚úÖ LEFT_ROOM confirmed by server');
  
  // Clear ALL storage
  localStorage.removeItem('activeCall');
  localStorage.removeItem('currentRoom');
  sessionStorage.removeItem('hasBackgroundCall');
  sessionStorage.removeItem('returningFromCall');
  sessionStorage.removeItem('backgroundCallMode');
  sessionStorage.removeItem('returningToBackgroundCall');
  clearChatState();
  
  toast('Left room', 'success');
  
  // Go to mood.html
  setTimeout(() => { 
    window.location.href = '/mood.html'; 
  }, 1000);
});

    socketInstance.on('incoming_call', (data) => {
  pendingCallData = data;
  const callerName = document.getElementById('callerName');
  const callType = document.getElementById('callType');
  const callerAvatar = document.getElementById('callerAvatar');
  
  if (callerName) callerName.textContent = `${data.callerUsername} is calling`;
  if (callType) callType.textContent = data.callType === 'video' ? 'Video Call' : 'Audio Call';
  if (callerAvatar) {
    callerAvatar.innerHTML = '';
    const pfp = createProfilePictureElement(data.callerPfp, data.callerUsername, 'w-full h-full');
    callerAvatar.appendChild(pfp);
  }
  
  // CRITICAL: Show modal after 2 second delay
  setTimeout(() => {
    // Only show if call is still pending (user hasn't left, call hasn't ended)
    if (pendingCallData && pendingCallData.callId === data.callId) {
      incomingCallModal?.classList.remove('hidden');
      console.log(`üìû Showing incoming call modal after 2s delay`);
    } else {
      console.log(`üìû Call already handled, skipping modal display`);
    }
  }, 2000);
  
  console.log(`üìû Incoming call from ${data.callerUsername} - modal will appear in 2s`);
});

    socketInstance.on('call_accepted', (data) => {
      console.log('‚úÖ Call accepted:', data);
      isInitiatingCall = false;
      navigatingToCall = true;
      
      saveChatState(roomData.roomId, messagesCache);
      sessionStorage.setItem('returningFromCall', 'true');
      
      localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
        callId: data.callId,
        roomId: roomData.roomId,
        callType: data.callType,
        users: data.users
      }));
      
      console.log('üöÄ Navigating to call');
      window.location.href = '/call.html';
    });

    socketInstance.on('call_declined', (data) => {
      toast('Call was declined', 'warning');
      isInitiatingCall = false;
      audioCallBtn?.classList.remove('calling');
      videoCallBtn?.classList.remove('calling');
    });
    
    socketInstance.on('call_state_update', (data) => {
      console.log('üìû Call state update:', data);
      
      if (data.isActive && data.participantCount > 0) {
        updateCallButtonState(true, data);
      } else {
        updateCallButtonState(false);
      }
    });

    socketInstance.on('call_ended_notification', (data) => {
      console.log('üìû Call ended:', data.callId);
      updateCallButtonState(false);
    });

    socketInstance.on('join_existing_call_success', (data) => {
      console.log('‚úÖ Joining existing call:', data);
      navigatingToCall = true;
      
      saveChatState(roomData.roomId, messagesCache);
      sessionStorage.setItem('returningFromCall', 'true');
      
      localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
        callId: data.callId,
        roomId: data.roomId,
        callType: data.callType,
        users: []
      }));
      
      console.log('üöÄ Navigating to call');
      window.location.href = '/call.html';
    });
  }

  // ============================================
  // EVENT LISTENERS
  // ============================================
  
  function setupEventListeners() {
    // Sidebar
    sidebarToggle?.addEventListener('click', toggleSidebar, { passive: true });
    sidebarClose?.addEventListener('click', closeSidebar, { passive: true });
    sidebarOverlay?.addEventListener('click', closeSidebar, { passive: true });
    
    // Reply
    cancelReplyBtn?.addEventListener('click', hideReplyPreview, { passive: true });
    
    // Call buttons
    if (audioCallBtn) {
      audioCallBtn.addEventListener('click', () => {
        if (isInitiatingCall) return;
        isInitiatingCall = true;
        audioCallBtn.classList.add('calling');
        videoCallBtn?.classList.add('calling');
        
        socketInstance?.emit('initiate_call', {
          roomId: roomData.roomId,
          callType: 'audio'
        });
        toast('Calling...', 'success');
        
        setTimeout(() => {
          if (isInitiatingCall) {
            isInitiatingCall = false;
            audioCallBtn.classList.remove('calling');
            videoCallBtn?.classList.remove('calling');
          }
        }, 30000);
      }, { passive: true });
    }

    if (videoCallBtn) {
      videoCallBtn.addEventListener('click', () => {
        if (isInitiatingCall) return;
        isInitiatingCall = true;
        audioCallBtn?.classList.add('calling');
        videoCallBtn.classList.add('calling');
        
        socketInstance?.emit('initiate_call', {
          roomId: roomData.roomId,
          callType: 'video'
        });
        toast('Calling...', 'success');
        
        setTimeout(() => {
          if (isInitiatingCall) {
            isInitiatingCall = false;
            audioCallBtn?.classList.remove('calling');
            videoCallBtn.classList.remove('calling');
          }
        }, 30000);
      }, { passive: true });
    }

    if (joinCallBtn) {
    joinCallBtn.addEventListener('click', () => {
        if (!activeCallInRoom) {
            toast('No active call to join', 'warning');
            return;
        }
        
        // Add loading state
        joinCallBtn.classList.add('join-btn-loading');
        
        console.log(`üìû Joining call ${activeCallInRoom.callId}`);
        
        socketInstance?.emit('join_existing_call', {
            callId: activeCallInRoom.callId,
            roomId: roomData.roomId
        });
        
        toast('Joining call...', 'success');
    }, { passive: true });
}

if (acceptCallBtn) {
  acceptCallBtn.addEventListener('click', () => {
    if (pendingCallData) {
      const callToAccept = pendingCallData;
      pendingCallData = null; // Clear immediately to prevent modal re-show
      
      socketInstance?.emit('accept_call', {
        callId: callToAccept.callId,
        roomId: roomData.roomId
      });
      incomingCallModal?.classList.add('hidden');
    }
  }, { passive: true });
}

    if (declineCallBtn) {
  declineCallBtn.addEventListener('click', () => {
    if (pendingCallData) {
      const callToDecline = pendingCallData;
      pendingCallData = null; // Clear immediately to prevent modal re-show
      
      socketInstance?.emit('decline_call', {
        callId: callToDecline.callId,
        roomId: roomData.roomId
      });
      incomingCallModal?.classList.add('hidden');
    }
  }, { passive: true });
}

    // Message form
    if (messageForm) {
      messageForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const message = messageInput?.value.trim();
        if (!message) return;

        const messageData = {
          roomId: roomData.roomId,
          message: message
        };

        if (replyingTo) {
          messageData.replyTo = {
            messageId: replyingTo.messageId,
            username: replyingTo.username,
            message: replyingTo.message,
            userId: replyingTo.userId
          };
          hideReplyPreview();
        }

        socketInstance?.emit('chat_message', messageData);
        if (messageInput) messageInput.value = '';
      });
    }

// Leave button
leaveBtn?.addEventListener('click', () => {
  console.log('üö™ Leave button clicked - clearing everything');
  
  // Clear ALL storage
  localStorage.removeItem('activeCall');
  localStorage.removeItem('currentRoom');
  sessionStorage.removeItem('hasBackgroundCall');
  sessionStorage.removeItem('returningFromCall');
  sessionStorage.removeItem('backgroundCallMode');
  sessionStorage.removeItem('returningToBackgroundCall');
  clearChatState();
  
  // Disconnect and leave
  socketInstance?.emit('leave_room');
  
  console.log('‚úÖ All storage cleared, leaving room');
}, { passive: true });

    // Visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        console.log('üì± Page hidden');
        saveChatState(roomData.roomId, messagesCache);
      } else {
        console.log('üì± Page visible');
      }
    });

// Before unload
window.addEventListener('beforeunload', (e) => {
  console.log('üö™ Chat page beforeunload event');
  
  // CRITICAL: Check if in background call mode
  if (isInBackgroundCall) {
    console.log('üîí Background call active - preserving floating socket');
    saveChatState(roomData.roomId, messagesCache);
    
    // Don't disconnect floating socket - let it persist
    if (floatingCallSocket) {
      console.log('‚úÖ Keeping floating call socket alive');
    }
    
    // Only disconnect main chat socket
    if (socketInstance) {
      socketInstance.emit('leave_room');
      socketInstance.disconnect();
    }
    
    return;
  }
  
  if (navigatingToCall) {
    console.log('üîí Navigating to call - keeping socket');
    saveChatState(roomData.roomId, messagesCache);
    return;
  }
  
  console.log('üóëÔ∏è Normal chat exit - full cleanup');
  
  // Clean up floating call popup if exists
  if (floatingCallPopup) {
    hideFloatingCallPopup();
  }
  
  if (socketInstance) {
    socketInstance.emit('leave_room');
    socketInstance.disconnect();
  }
  if (timerInterval) clearInterval(timerInterval);
});
  }

  // ============================================
  // INITIALIZATION
  // ============================================
  
try {
  // CRITICAL: Check if we're returning from a call
  const returningFromCall = sessionStorage.getItem('returningFromCall') === 'true';
  const hasBackgroundCall = sessionStorage.getItem('hasBackgroundCall') === 'true';
  
  if (returningFromCall || hasBackgroundCall) {
    console.log('üîÑ Returning from call - preserving room state');
    // DON'T clear anything when returning from call
  } else {
    // Only clear on fresh entry to chat
    console.log('üßπ Fresh entry - clearing old chat state');
    // clearAllChatData();
  }
    
    // Auth check
    await _Auth.requireAuth();
  } catch (err) {
    console.error('‚ùå Auth failed:', err);
    window.location.href = '/login.html';
    return;
  }
  
  
// CRITICAL: Initialize floating call popup elements early
console.log('üéà Pre-initializing floating call popup');
initializeFloatingCallPopup();

// Check if returning from call
const returningFromCall = sessionStorage.getItem('returningFromCall');
if (returningFromCall === 'true') {
  console.log('üîÑ Returning from call - popup will be shown after room_joined');
  console.log('üîç Active call check:', !!localStorage.getItem(ACTIVE_CALL_KEY));
}

const roomDataStr = localStorage.getItem('currentRoom');
if (!roomDataStr) {
  console.error('‚ùå No currentRoom in localStorage');
  
  // Check if we have background call - if so, something went wrong
  const hasBackgroundCall = sessionStorage.getItem('hasBackgroundCall') === 'true';
  if (hasBackgroundCall) {
    console.error('‚ùå CRITICAL: Had background call but no room data!');
    // Clear the broken flags
    localStorage.removeItem('activeCall');
    sessionStorage.removeItem('hasBackgroundCall');
    sessionStorage.removeItem('returningFromCall');
  }
  
  toast('No active room found', 'error');
  setTimeout(() => window.location.href = '/mood.html', 1500);
  return;
}
  try {
    roomData = JSON.parse(roomDataStr);
    console.log('üì¶ Loaded room data from localStorage:');
    console.log(`   roomId: ${roomData.roomId}`);
    
    // CRITICAL: Don't trust localStorage expiresAt - wait for server
    if (roomData.expiresAt) {
      console.log(`   LocalStorage expiresAt: ${new Date(roomData.expiresAt).toISOString()}`);
      console.log(`   ‚ö†Ô∏è Will be replaced with server time after connection`);
    } else {
      console.log(`   No expiresAt in localStorage - will get from server`);
    }
    
    if (!roomData.roomId) {
      throw new Error('Invalid room data: missing roomId');
    }
    checkForBackgroundCall();
  } catch (err) {
    console.error('‚ùå Invalid room data:', err);
    toast('Invalid room data', 'error');
    clearChatState();
    setTimeout(() => window.location.href = '/mood.html', 1500);
    return;
  }

  // Get Firebase user
  const firebaseUser = firebase.auth().currentUser;
  if (!firebaseUser) {
    window.location.href = '/login.html';
    return;
  }

  // Get current user data
  try {
    const userData = await _API.get('/api/users/me');
    currentUser = {
      userId: userData._id,
      username: userData.username,
      pfpUrl: userData.pfpUrl
    };
  } catch (err) {
    console.error('‚ùå Failed to get user data:', err);
    toast('Failed to load user data', 'error');
    setTimeout(() => window.location.href = '/login.html', 1500);
    return;
  }

  // Set initial call button state
  setInitialCallButtonState();
  checkForBackgroundCall();

  // Render initial users
  if (usersList && Array.isArray(roomData.users)) {
    roomData.users.forEach(user => {
      const userCard = document.createElement('div');
      userCard.className = 'user-card flex items-center gap-2 sm:gap-3 p-2 sm:p-3 rounded-lg hover:bg-gray-50 transition-all cursor-pointer';
      
      const pfpElement = createProfilePictureElement(user.pfpUrl, user.username, 'w-10 h-10 sm:w-12 sm:h-12');
      
      const userInfo = document.createElement('div');
      userInfo.className = 'flex-1 min-w-0';
      
      const nameSpan = document.createElement('div');
      nameSpan.className = 'text-sm font-semibold truncate';
      nameSpan.textContent = user.username || 'User';
      
      const statusSpan = document.createElement('div');
      statusSpan.className = 'text-xs text-gray-500 flex items-center gap-1';
      statusSpan.innerHTML = '<span class="flex h-2 w-2 rounded-full bg-green-500 flex-shrink-0"></span> Online';
      
      userInfo.appendChild(nameSpan);
      userInfo.appendChild(statusSpan);
      
      userCard.appendChild(pfpElement);
      userCard.appendChild(userInfo);
      usersList.appendChild(userCard);
    });

    setupUserCardClick();

    if (onlineCount) {
      onlineCount.textContent = `${roomData.users.length} Online`;
    }
  }

  console.log('‚è∞ Starting timer interval (will update when server data arrives)');
  // Start timer interval (will show "--" until server data arrives)
  timerInterval = setInterval(updateTimer, 1000);
  updateTimer();

  // Initialize socket
  try {
    const idToken = await firebaseUser.getIdToken();
    const socketUrl = window.location.origin;
    
    socketInstance = io(socketUrl, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 500,
      reconnectionAttempts: 10,
      auth: { token: idToken },
      timeout: 10000
    });

    setupSocketHandlers();
  } catch (err) {
    console.error('‚ùå Socket initialization failed:', err);
    toast('Connection failed', 'error');
  }

  // Setup all event listeners
  setupEventListeners();

  // Setup back button handler
  setupBackButtonHandler();

  console.log('‚úÖ Chat initialization complete');

})();
</script>
</body>
</html>
