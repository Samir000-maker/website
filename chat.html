
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat Room - MoodLog</title>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="global.css" rel="stylesheet">
    <style>
    body {
        font-family: 'Manrope', sans-serif;
        background-color: #0a0e14;
    }
    
    .reply-btn {
        opacity: 0;
        transition: opacity 0.15s ease;
        cursor: pointer;
    }
    .message-item:hover .reply-btn {
        opacity: 1;
    }
    
    .reply-preview {
        animation: slideUp 0.15s ease-out;
    }
    
    @keyframes slideUp {
        from {
            transform: translateY(10px);
            opacity: 0;
        }
        to {
            transform: translateY(0);
            opacity: 1;
        }
    }
    
    .quoted-message {
        border-left: 3px solid #06b6d4;
        padding-left: 8px;
        margin-bottom: 6px;
        background-color: rgba(6, 182, 212, 0.1);
        padding: 6px 8px;
        border-radius: 6px;
        font-size: 0.813rem;
    }
    
    .quoted-message-light {
        background-color: rgba(6, 182, 212, 0.08);
        border-left-color: #06b6d4;
    }

    .sidebar {
        transition: transform 0.2s ease;
        background-color: #161b22;
    }
    
    .main-container {
        height: 100vh;
        height: 100dvh;
    }
    
    .call-buttons-container {
        position: relative;
        display: flex;
        flex-direction: row;
        gap: 8px;
        align-items: center;
    }

    @media (max-width: 640px) {
        .call-buttons-container {
            gap: 6px;
        }
    }

    .chat-main {
        max-height: calc(100vh - 64px);
        max-height: calc(100dvh - 64px);
        background-color: #0d1117;
    }

    @media (max-width: 768px) {
        .chat-main {
            max-height: calc(100vh - 56px);
            max-height: calc(100dvh - 56px);
        }
    }
    
    @media (max-width: 768px) {
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 280px;
            z-index: 40;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            transform: translateX(-100%);
        }
        
        .sidebar.show {
            transform: translateX(0);
        }
        
        .sidebar-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 30;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        .sidebar-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
    }
    
    @media (min-width: 769px) {
        .sidebar {
            position: relative;
            width: 280px;
            min-width: 280px;
            display: block !important;
        }
        
        .sidebar-toggle {
            display: none;
        }
        
        .sidebar-overlay {
            display: none;
        }
    }

    .user-card {
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        background-color: transparent;
    }

    .user-card:hover {
        transform: translateY(-2px);
        background-color: rgba(6, 182, 212, 0.05) !important;
    }

    /* Message input styling */
    #messageInput {
        background-color: #0d1117;
        border: 1px solid #30363d;
        color: #c9d1d9;
    }
    
    #messageInput::placeholder {
        color: #8b949e;
    }
    
    #messageInput:focus {
        border-color: #06b6d4;
        background-color: #0d1117;
        box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.1);
        outline: none;
    }
    
    /* Reply preview styling */
    #replyPreview {
        background-color: #161b22;
        border-bottom: 1px solid #30363d;
        border-left: 3px solid #06b6d4;
    }
    
    /* Confirmation dialog dark mode */
    .confirmation-dialog {
        background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
        border: 1px solid #30363d;
    }
    
    /* Add emoji picker button styling */
    .emoji-btn {
        background-color: #1c2128;
        border: 1px solid #30363d;
        color: #8b949e;
        width: 44px;
        height: 44px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.15s ease;
    }
    
    .emoji-btn:hover {
        background-color: #21262d;
        border-color: #444c56;
    }
    
    .attachment-btn {
        background-color: #1c2128;
        border: 1px solid #30363d;
        color: #8b949e;
        width: 44px;
        height: 44px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.15s ease;
    }
    
    .attachment-btn:hover {
        background-color: #21262d;
        border-color: #444c56;
    }

    /* Header styling */
    header {
        background-color: #161b22 !important;
        border-bottom: 1px solid #30363d !important;
    }

    /* Timer display */
    .hidden.sm\:flex.items-center.gap-2 {
        background-color: #1c2128 !important;
        border: 1px solid #30363d !important;
    }

    /* Call buttons - brighter cyan with glow */
    #audioCallBtn, #videoCallBtn {
        background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%);
        box-shadow: 0 0 15px rgba(6, 182, 212, 0.4);
        border: 1px solid #22d3ee;
    }

    #audioCallBtn:hover, #videoCallBtn:hover {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%);
        box-shadow: 0 0 20px rgba(6, 182, 212, 0.6);
    }

    #joinCallBtn {
        background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%);
        box-shadow: 0 0 15px rgba(6, 182, 212, 0.4);
        border: 1px solid #22d3ee;
    }

    #joinCallBtn:hover {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%);
        box-shadow: 0 0 20px rgba(6, 182, 212, 0.6);
    }

    /* Send button - bright cyan gradient */
    button[type="submit"] {
        background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%);
        box-shadow: 0 0 20px rgba(6, 182, 212, 0.4);
        border: 1px solid #22d3ee;
    }

    button[type="submit"]:hover {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%);
        box-shadow: 0 0 25px rgba(6, 182, 212, 0.6);
    }

    /* Message bubbles */
    .bg-\[\#2a2d33\] {
        background-color: #1c2128 !important;
        border: 1px solid #30363d;
    }

    /* User's own messages - teal/cyan with glow */
    .bg-\[\#33bfcc\] {
        background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%) !important;
        border: 1px solid #22d3ee;
        box-shadow: 0 0 20px rgba(6, 182, 212, 0.3);
    }

    /* System messages */
    .text-center.text-xs, .text-center.text-sm {
        color: #8b949e !important;
    }

    /* Message text colors */
    .text-gray-200 {
        color: #c9d1d9 !important;
    }

    .text-gray-400 {
        color: #8b949e !important;
    }

    .text-gray-500 {
        color: #6e7681 !important;
    }

    /* Input bottom bar */
    .border-t.border-gray-800.bg-\[\#1f2228\] {
        background-color: #0d1117 !important;
        border-top: 1px solid #30363d !important;
    }

    /* Messages list background */
    #messagesList {
        background-color: #0d1117;
    }

    /* Sidebar background */
    .bg-\[\#22252a\] {
        background-color: #161b22 !important;
    }

    /* Leave button */
    #leaveBtn {
        color: #8b949e;
    }

    #leaveBtn:hover {
        color: #c9d1d9;
    }

    /* Online count text */
    #onlineCount {
        color: #8b949e;
    }

    /* Header title */
    header h2 {
        color: #f0f6fc;
    }

    /* Decline call button in modal */
    #declineCallBtn:hover {
        background: linear-gradient(135deg, #ef4444 0%, #f87171 100%) !important;
        box-shadow: 0 0 25px rgba(239, 68, 68, 0.5) !important;
    }

    /* Accept call button in modal */
    #acceptCallBtn:hover {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%) !important;
        box-shadow: 0 0 25px rgba(6, 182, 212, 0.6) !important;
    }

    /* Loading states */
    .call-btn-loading, .join-btn-loading {
        opacity: 0.7;
        cursor: not-allowed;
    }

    .animate-pulse {
        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }

    @keyframes pulse {
        0%, 100% {
            opacity: 1;
        }
        50% {
            opacity: .5;
        }
    }

    /* Reply preview close button */
    #cancelReply {
        color: #8b949e;
    }

    #cancelReply:hover {
        color: #c9d1d9;
    }

    /* Sidebar close button */
    #sidebarClose {
        color: #8b949e;
    }

    #sidebarClose:hover {
        background-color: rgba(6, 182, 212, 0.05);
    }

    /* Sidebar toggle button */
    #sidebarToggle {
        color: #8b949e;
    }

    #sidebarToggle:hover {
        background-color: rgba(6, 182, 212, 0.05);
    }

    /* Active users section */
    .text-gray-400.uppercase {
        color: #8b949e !important;
    }

    /* Green online indicator */
    .bg-green-500 {
        background-color: #22c55e !important;
    }

    /* Material icons color adjustments */
    .material-symbols-outlined {
        color: #8b949e;
    }

    button .material-symbols-outlined {
        color: inherit;
    }

    /* Scrollbar styling */
    #messagesList::-webkit-scrollbar,
    .sidebar::-webkit-scrollbar {
        width: 8px;
    }

    #messagesList::-webkit-scrollbar-track,
    .sidebar::-webkit-scrollbar-track {
        background: #0d1117;
    }

    #messagesList::-webkit-scrollbar-thumb,
    .sidebar::-webkit-scrollbar-thumb {
        background: #30363d;
        border-radius: 4px;
    }

    #messagesList::-webkit-scrollbar-thumb:hover,
    .sidebar::-webkit-scrollbar-thumb:hover {
        background: #444c56;
    }

    /* Fade in animation for messages */
    @keyframes fade-in-up {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .animate-fade-in-up {
        animation: fade-in-up 0.3s ease-out;
    }

    /* Modal fade in */
    @keyframes fade-in {
        from {
            opacity: 0;
            transform: scale(0.95);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }

    .animate-fade-in {
        animation: fade-in 0.2s ease-out;
    }

    /* Profile picture borders */
    .border-white {
        border-color: #30363d !important;
    }

    /* Time remaining text */
    #timeRemaining {
        color: #c9d1d9;
    }

    /* User status in sidebar */
    .user-card .text-gray-500 {
        color: #8b949e !important;
    }

    .user-card .text-sm {
        color: #c9d1d9 !important;
    }
    
    /* ============================================
   ATTACHMENT PREVIEW STYLES
   ============================================ */
.attachment-preview-container {
    background: linear-gradient(135deg, rgba(6, 182, 212, 0.08) 0%, rgba(14, 116, 144, 0.12) 100%);
    border: 1px solid rgba(6, 182, 212, 0.2);
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 12px;
    animation: slideUpFade 0.2s ease-out;
}

@keyframes slideUpFade {
    from {
        opacity: 0;
        transform: translateY(8px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.attachment-preview-content {
    display: flex;
    align-items: center;
    gap: 12px;
}

.attachment-icon-wrapper {
    width: 48px;
    height: 48px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    position: relative;
    overflow: hidden;
}

.attachment-icon-wrapper.image-preview {
    background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%);
    border: 1px solid rgba(6, 182, 212, 0.3);
}

.attachment-icon-wrapper.pdf-preview {
    background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%);
    border: 1px solid rgba(239, 68, 68, 0.3);
}

.attachment-icon-wrapper.video-preview {
    background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
    border: 1px solid rgba(168, 85, 247, 0.3);
}

.attachment-icon-wrapper img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.attachment-icon-wrapper .material-symbols-outlined {
    font-size: 24px;
    color: white;
}

.attachment-info {
    flex: 1;
    min-width: 0;
}

.attachment-name {
    font-size: 0.875rem;
    font-weight: 600;
    color: #c9d1d9;
    margin-bottom: 2px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.attachment-size {
    font-size: 0.75rem;
    color: #8b949e;
}

.attachment-remove-btn {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    background-color: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.15s ease;
    flex-shrink: 0;
}

.attachment-remove-btn:hover {
    background-color: rgba(239, 68, 68, 0.2);
    border-color: rgba(239, 68, 68, 0.4);
}

.attachment-remove-btn .material-symbols-outlined {
    font-size: 18px;
    color: #ef4444;
}

/* Message attachment display */
.message-attachment {
    margin-top: 8px;
    border-radius: 8px;
    overflow: hidden;
    max-width: 300px;
}

.message-attachment img {
    width: 100%;
    height: auto;
    display: block;
    cursor: pointer;
    transition: opacity 0.2s;
}

.message-attachment img:hover {
    opacity: 0.9;
}

.message-attachment-file {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    transition: all 0.15s ease;
}

.message-attachment-file:hover {
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(255, 255, 255, 0.2);
}

.message-attachment-file .material-symbols-outlined {
    font-size: 24px;
}

.message-attachment-file.pdf {
    color: #ef4444;
}

.message-attachment-file.video {
    color: #a855f7;
}

.message-attachment-info {
    flex: 1;
    min-width: 0;
}

.message-attachment-name {
    font-size: 0.813rem;
    font-weight: 600;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.message-attachment-size {
    font-size: 0.75rem;
    opacity: 0.7;
}


/* ============================================
   EMOJI PICKER BOTTOM SHEET - FUTURISTIC THEME
   ============================================ */

/* Overlay backdrop */
.emoji-picker-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(8px);
  z-index: 9999;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease;
}

.emoji-picker-overlay.active {
  opacity: 1;
  pointer-events: auto;
}

/* Bottom sheet container */
.emoji-picker-sheet {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  max-height: 70vh;
  background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
  border-top-left-radius: 24px;
  border-top-right-radius: 24px;
  border: 1px solid #30363d;
  box-shadow: 0 -20px 60px rgba(0, 0, 0, 0.6), 0 0 1px rgba(6, 182, 212, 0.3);
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 10000;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.emoji-picker-overlay.active .emoji-picker-sheet {
  transform: translateY(0);
}

/* Handle bar */
.emoji-picker-handle {
  width: 40px;
  height: 4px;
  background: #30363d;
  border-radius: 2px;
  margin: 12px auto 8px;
  flex-shrink: 0;
}

/* Header */
.emoji-picker-header {
  padding: 0 20px 16px;
  border-bottom: 1px solid #30363d;
  flex-shrink: 0;
}

.emoji-picker-title {
  font-size: 1.125rem;
  font-weight: 700;
  color: #f0f6fc;
  margin-bottom: 12px;
  text-align: center;
}

/* Search input */
.emoji-search-input {
  width: 100%;
  padding: 12px 16px;
  background: #1c2128;
  border: 1px solid #30363d;
  border-radius: 12px;
  color: #c9d1d9;
  font-size: 0.875rem;
  transition: all 0.15s ease;
}

.emoji-search-input::placeholder {
  color: #8b949e;
}

.emoji-search-input:focus {
  outline: none;
  border-color: #06b6d4;
  background: #0d1117;
  box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.1);
}

/* Category tabs */
.emoji-categories {
  display: flex;
  gap: 8px;
  padding: 12px 20px;
  overflow-x: auto;
  border-bottom: 1px solid #30363d;
  flex-shrink: 0;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.emoji-categories::-webkit-scrollbar {
  display: none;
}

.emoji-category-tab {
  padding: 8px 16px;
  background: #1c2128;
  border: 1px solid #30363d;
  border-radius: 8px;
  color: #8b949e;
  font-size: 0.813rem;
  font-weight: 600;
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.15s ease;
  text-transform: capitalize;
}

.emoji-category-tab:hover {
  background: #21262d;
  border-color: #444c56;
}

.emoji-category-tab.active {
  background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%);
  border-color: #22d3ee;
  color: white;
  box-shadow: 0 0 15px rgba(6, 182, 212, 0.3);
}

/* Emoji grid container */
.emoji-grid-container {
  flex: 1;
  overflow-y: auto;
  padding: 16px 20px 24px;
  min-height: 0;
}

.emoji-grid-container::-webkit-scrollbar {
  width: 8px;
}

.emoji-grid-container::-webkit-scrollbar-track {
  background: #0d1117;
}

.emoji-grid-container::-webkit-scrollbar-thumb {
  background: #30363d;
  border-radius: 4px;
}

.emoji-grid-container::-webkit-scrollbar-thumb:hover {
  background: #444c56;
}

/* Emoji grid */
.emoji-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
  gap: 8px;
  animation: fadeInUp 0.3s ease-out;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Emoji item */
.emoji-item {
  aspect-ratio: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #1c2128;
  border: 1px solid #30363d;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.15s ease;
  font-size: 1.75rem;
  user-select: none;
}

.emoji-item:hover {
  background: #21262d;
  border-color: #06b6d4;
  box-shadow: 0 0 15px rgba(6, 182, 212, 0.2);
  transform: scale(1.1);
}

.emoji-item:active {
  transform: scale(0.95);
}

/* Loading state */
.emoji-loading {
  text-align: center;
  padding: 40px 20px;
  color: #8b949e;
  font-size: 0.875rem;
}

.emoji-loading-spinner {
  display: inline-block;
  width: 24px;
  height: 24px;
  border: 3px solid #30363d;
  border-top-color: #06b6d4;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-bottom: 12px;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Error state */
.emoji-error {
  text-align: center;
  padding: 40px 20px;
  color: #ef4444;
  font-size: 0.875rem;
}

/* Empty state */
.emoji-empty {
  text-align: center;
  padding: 40px 20px;
  color: #8b949e;
  font-size: 0.875rem;
}

/* Mobile adjustments */
@media (max-width: 640px) {
  .emoji-picker-sheet {
    max-height: 75vh;
  }
  
  .emoji-grid {
    grid-template-columns: repeat(auto-fill, minmax(44px, 1fr));
    gap: 6px;
  }
  
  .emoji-item {
    font-size: 1.5rem;
  }
  
  .emoji-categories {
    padding: 12px 16px;
  }
  
  .emoji-grid-container {
    padding: 12px 16px 20px;
  }
}
    
    
</style>
</head>
<body class="bg-background-light main-container flex flex-col overflow-hidden">
    <header class="sticky top-0 z-50 w-full border-b border-gray-800 bg-[#1f2228]/95 backdrop-blur header-safe">
    <div class="mx-auto flex h-14 sm:h-16 max-w-full items-center justify-between px-3 sm:px-6">
        <div class="flex items-center gap-2 sm:gap-3 flex-1 min-w-0">
            <button id="sidebarToggle" class="sidebar-toggle p-2 hover:bg-gray-800 rounded-lg md:hidden flex-shrink-0">
                <span class="material-symbols-outlined text-gray-400">menu</span>
            </button>
            
            <div class="min-w-0 flex-1">
                <h2 class="text-base sm:text-lg font-bold truncate text-white">Mindful Space</h2>
                <div class="flex items-center gap-1.5 sm:gap-2 text-xs text-gray-400">
                    <span class="flex h-2 w-2 rounded-full bg-green-500 flex-shrink-0"></span>
                    <span id="onlineCount" class="truncate">Loading...</span>
                </div>
            </div>
        </div>
        
        <div class="flex items-center gap-3 flex-shrink-0">
            <!-- Timer Display -->
            <div class="hidden sm:flex items-center gap-2 px-3 py-1.5 bg-[#2a2d33] rounded-lg border border-gray-700">
                <span class="material-symbols-outlined text-gray-400 text-base">schedule</span>
                <span id="timeRemaining" class="text-xs text-gray-300 font-medium">--:--</span>
            </div>
            
            <!-- Call Buttons -->
            <div class="call-buttons-container flex-row">
                <button id="audioCallBtn" 
                    class="w-9 h-9 sm:w-10 sm:h-10 flex items-center justify-center rounded-full bg-[#33bfcc] text-white hover:bg-[#2aa5b0] transition-all"
                    title="Start Audio Call">
                    <span class="material-symbols-outlined text-lg sm:text-xl">call</span>
                </button>
                <button id="videoCallBtn" 
                    class="w-9 h-9 sm:w-10 sm:h-10 flex items-center justify-center rounded-full bg-[#33bfcc] text-white hover:bg-[#2aa5b0] transition-all"
                    title="Start Video Call">
                    <span class="material-symbols-outlined text-lg sm:text-xl">videocam</span>
                </button>
                <button id="joinCallBtn" 
                    class="hidden items-center gap-1.5 px-3 sm:px-4 h-9 sm:h-10 rounded-full bg-green-600 text-white hover:bg-green-700 transition-all text-xs sm:text-sm font-semibold"
                    title="Join Active Call">
                    <span class="material-symbols-outlined text-base sm:text-lg">login</span>
                    <span class="hidden sm:inline">Join Call</span>
                    <span class="sm:hidden">Join</span>
                </button>
            </div>
            
            <button id="leaveBtn" class="text-xs sm:text-sm font-medium text-gray-400 hover:text-gray-300 px-2 sm:px-3 py-1.5 sm:py-2 whitespace-nowrap">
                <span class="hidden sm:inline">Leave Room</span>
                <span class="sm:hidden material-symbols-outlined text-xl">logout</span>
            </button>
        </div>
    </div>
</header>

    <div class="flex flex-1 overflow-hidden relative chat-main">
        <div id="sidebarOverlay" class="sidebar-overlay"></div>
        
        <aside id="sidebar" class="sidebar border-r border-gray-800 bg-[#22252a] overflow-y-auto">
    <div class="p-3 sm:p-4">
        <div class="flex items-center justify-between mb-3 sm:mb-4">
            <h3 class="text-xs font-bold text-gray-400 uppercase">Active Users</h3>
            <button id="sidebarClose" class="md:hidden p-1 hover:bg-gray-800 rounded">
                <span class="material-symbols-outlined text-gray-400 text-xl">close</span>
            </button>
        </div>
        <div id="usersList" class="space-y-2 sm:space-y-3"></div>
    </div>
</aside>

        <main class="flex-1 flex flex-col min-h-0 bg-[#1a1d23]">
    <div id="messagesList" class="flex-1 overflow-y-auto px-2 sm:px-4 py-3 sm:py-6 space-y-2 sm:space-y-4 min-h-0">
        <div class="text-center text-xs sm:text-sm text-gray-500 mb-4">
            Welcome to the safe space. Be kind and supportive.
        </div>
    </div>

    <div class="border-t border-gray-800 bg-[#1f2228] flex-shrink-0 sticky bottom-0 left-0 right-0 z-10" style="padding-bottom: env(safe-area-inset-bottom, 0px);">
    <div id="replyPreview" class="reply-preview hidden border-b border-gray-800 px-3 py-2 bg-[#22252a]">
        <div class="flex items-start justify-between gap-2">
            <div class="flex-1 min-w-0">
                <div class="flex items-center gap-1.5 mb-1">
                    <span class="material-symbols-outlined text-[#33bfcc] text-sm">subdirectory_arrow_left</span>
                    <span class="text-xs font-medium text-[#33bfcc]" id="replyToUsername">Replying to User</span>
                </div>
                <p class="text-xs text-gray-400 truncate" id="replyToMessage">Original message text</p>
            </div>
            <button id="cancelReply" class="text-gray-500 hover:text-gray-400 p-1">
                <span class="material-symbols-outlined text-lg">close</span>
            </button>
        </div>
    </div>
    
    <!-- Attachment Preview -->
    <div id="attachmentPreview" class="hidden px-3 pt-3">
        <div class="attachment-preview-container">
            <div class="attachment-preview-content">
                <div id="attachmentIconWrapper" class="attachment-icon-wrapper">
                    <!-- Icon or image preview will be inserted here -->
                </div>
                <div class="attachment-info">
                    <div id="attachmentName" class="attachment-name">filename.png</div>
                    <div id="attachmentSize" class="attachment-size">0 KB</div>
                </div>
                <button id="removeAttachment" class="attachment-remove-btn" title="Remove attachment">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
        </div>
    </div>
    
    <div class="p-3 pb-4">
        <form id="messageForm" class="flex gap-2 items-end">
            <button type="button" class="emoji-btn flex-shrink-0" title="Add emoji">
                <span class="material-symbols-outlined text-xl">sentiment_satisfied</span>
            </button>
            <button type="button" class="attachment-btn flex-shrink-0" title="Attach file">
                <span class="material-symbols-outlined text-xl">attach_file</span>
            </button>
            <input type="text" id="messageInput" maxlength="500"
                class="flex-1 px-4 py-3 text-sm border border-gray-700 rounded-xl focus:border-[#33bfcc] focus:outline-none bg-[#2a2d33] text-gray-200"
                placeholder="Type a message..." style="min-width: 0; -webkit-appearance: none;">
            <button type="submit" class="w-11 h-11 flex-shrink-0 flex items-center justify-center bg-[#33bfcc] text-white rounded-xl hover:bg-[#2aa5b0] active:scale-95 transition-transform">
                <span class="material-symbols-outlined">send</span>
            </button>
        </form>
    </div>
</div>
</main>
    </div>

    <div id="incomingCallModal" class="hidden fixed inset-0 bg-black/85 backdrop-blur-sm z-[100] flex items-center justify-center p-4">
    <div style="background: linear-gradient(135deg, #0d1117 0%, #161b22 100%); border-radius: 20px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 0 1px rgba(6, 182, 212, 0.3); border: 1px solid #30363d; padding: 2rem; max-width: 400px; width: 100%;">
        <div class="text-center">
            <div class="mb-6">
                <div id="callerAvatar" class="w-24 h-24 mx-auto rounded-full overflow-hidden bg-gradient-to-br from-cyan-500/20 to-cyan-600/30 flex items-center justify-center border border-cyan-500/30">
                    <span class="text-4xl">ðŸ“ž</span>
                </div>
            </div>
            <h3 class="text-xl font-bold mb-2 text-gray-100" id="callerName">Incoming Call</h3>
            <p class="text-base text-gray-400 mb-8" id="callType">Audio Call</p>
            
            <div class="flex gap-4 justify-center">
                <button id="declineCallBtn" 
                    style="display: flex; align-items: center; gap: 0.5rem; padding: 0.875rem 1.5rem; border-radius: 12px; background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%); color: white; border: 1px solid #f87171; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);">
                    <span class="material-symbols-outlined">call_end</span>
                    <span>Decline</span>
                </button>
                <button id="acceptCallBtn" 
                    style="display: flex; align-items: center; gap: 0.5rem; padding: 0.875rem 1.5rem; border-radius: 12px; background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%); color: white; border: 1px solid #22d3ee; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 0 20px rgba(6, 182, 212, 0.4);">
                    <span class="material-symbols-outlined">call</span>
                    <span>Accept</span>
                </button>
            </div>
        </div>
    </div>
</div>

    <!-- Confirmation Dialog (hidden by default) -->
    <div id="confirmationOverlay" style="display: none;"></div>
    
    
    
    <!-- Emoji Picker Bottom Sheet -->
<div id="emojiPickerOverlay" class="emoji-picker-overlay">
  <div class="emoji-picker-sheet">
    <!-- Handle bar -->
    <div class="emoji-picker-handle"></div>
    
    <!-- Header -->
    <div class="emoji-picker-header">
      <h3 class="emoji-picker-title">Emojis</h3>
      <input 
        type="text" 
        id="emojiSearchInput" 
        class="emoji-search-input" 
        placeholder="Search emojis..."
        autocomplete="off"
      >
    </div>
    
    <!-- Category tabs -->
    <div id="emojiCategories" class="emoji-categories"></div>
    
    <!-- Emoji grid -->
    <div class="emoji-grid-container">
      <div id="emojiGrid" class="emoji-grid"></div>
    </div>
  </div>
</div>
  

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };

      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>

    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="app.js"></script>

    <script>
(async () => {
  const MoodApp = window.MoodApp || {};
  const _Auth = MoodApp.Auth;
  const _API = MoodApp.API;
  const _Toast = MoodApp.Toast;
  const _Utils = MoodApp.Utils;

const toast = (m, t='success') => { 
  if (_Toast) {
    // Handle 'info' type by mapping to 'success' if no info function exists
    const toastType = (t === 'info' && typeof _Toast.info !== 'function') ? 'success' : t;
    if (typeof _Toast[toastType] === 'function') {
      return _Toast[toastType](m);
    }
  }
  console[t==='error'?'error':'log'](m); 
};

  // ============================================
  // STORAGE KEYS
  // ============================================
  const CHAT_STATE_KEY = 'chat_state';
  const CHAT_MESSAGES_KEY = 'chat_messages';
  const CHAT_TIMESTAMP_KEY = 'chat_timestamp';
  const ACTIVE_CALL_KEY = 'activeCall';
  
  // NEW: State preservation keys
const ROOM_USER_LIST_KEY = 'room_user_list';
const ROOM_SYSTEM_MESSAGES_KEY = 'room_system_messages';
const ROOM_ALERT_STATE_KEY = 'room_alert_state';
const ROOM_PARTICIPATION_KEY = 'room_participation';
const STATE_VERSION = '1.0.0';
  
  
  const CACHED_CALL_KEY = 'cachedIncomingCall';
const CALL_CACHE_TIMEOUT = 60000; // 60 seconds max cache time
let cachedCallCheckInterval = null;

let pendingAttachment = null;
  // ============================================
  // STATE MANAGEMENT
  // ============================================
  let replyingTo = null;
  let isInitiatingCall = false;
  let pendingCallData = null;
  let navigatingToCall = false;
  let messagesCache = [];
  let activeCallInRoom = null;
  let backButtonHandled = false;
  let timerInterval = null;
  let socketInstance = null;
  let currentUser = null;
  let roomData = null;
  let serverClockOffset = 0; // Milliseconds to add to client time to get server time
  let serverExpiresAt = null; // Absolute server timestamp for expiry
  
  // NEW: Enhanced state tracking
let roomUserList = new Map(); // userId -> user object
let systemMessages = []; // Array of system messages
let isAlertDialogVisible = false;
let isPageRefresh = false;
let hasJoinedRoom = false;
  
  // ============================================
// EMOJI PICKER STATE
// ============================================
let emojiData = null; // Cached emoji data from API
let emojiCache = null; // Parsed and optimized emoji cache
let currentEmojiCategory = 'all'; // Currently selected category
let emojiSearchTerm = ''; // Current search query
let isEmojiPickerOpen = false; // Picker open state
  
  let floatingCallPopup = null;
let floatingCallSocket = null;
let currentSpeaker = null;
let isInBackgroundCall = false;
  
  // ============================================
  // DOM ELEMENTS (Initialized early)
  // ============================================
  const sidebar = document.getElementById('sidebar');
  const sidebarToggle = document.getElementById('sidebarToggle');
  const sidebarClose = document.getElementById('sidebarClose');
  const sidebarOverlay = document.getElementById('sidebarOverlay');
  const messagesList = document.getElementById('messagesList');
  const messageForm = document.getElementById('messageForm');
  const messageInput = document.getElementById('messageInput');
  const usersList = document.getElementById('usersList');
  const onlineCount = document.getElementById('onlineCount');
  const timeRemaining = document.getElementById('timeRemaining');
  const leaveBtn = document.getElementById('leaveBtn');
  const cancelReplyBtn = document.getElementById('cancelReply');
  const audioCallBtn = document.getElementById('audioCallBtn');
  const videoCallBtn = document.getElementById('videoCallBtn');
  const joinCallBtn = document.getElementById('joinCallBtn');
  const incomingCallModal = document.getElementById('incomingCallModal');
  const acceptCallBtn = document.getElementById('acceptCallBtn');
  const declineCallBtn = document.getElementById('declineCallBtn');
  
  // ============================================
  // UTILITY FUNCTIONS
  // ============================================
  
  
  // ============================================
// AUTHENTICATION STATE MANAGEMENT
// ============================================
let isSocketAuthenticated = false;
let authenticationPromise = null;


// ============================================
// STATE PERSISTENCE FUNCTIONS
// ============================================

function serializeState(data) {
  try {
    return JSON.stringify(data);
  } catch (err) {
    console.error('âŒ State serialization failed:', err);
    return null;
  }
}

function deserializeState(str) {
  if (!str) return null;
  try {
    return JSON.parse(str);
  } catch (err) {
    console.error('âŒ State deserialization failed:', err);
    return null;
  }
}

function saveUserList(roomId) {
  if (!roomId) return;
  try {
    const userArray = Array.from(roomUserList.values());
    const key = `${ROOM_USER_LIST_KEY}_${roomId}`;
    const stateData = {
      version: STATE_VERSION,
      timestamp: Date.now(),
      roomId: roomId,
      users: userArray
    };
    localStorage.setItem(key, serializeState(stateData));
  } catch (err) {
    console.error('âŒ Failed to save user list:', err);
  }
}

function loadUserList(roomId) {
  if (!roomId) return false;
  try {
    const key = `${ROOM_USER_LIST_KEY}_${roomId}`;
    const stored = localStorage.getItem(key);
    if (!stored) return false;
    
    const stateData = deserializeState(stored);
    if (!stateData || stateData.version !== STATE_VERSION || stateData.roomId !== roomId) {
      return false;
    }
    
    roomUserList.clear();
    if (Array.isArray(stateData.users)) {
      stateData.users.forEach(user => {
        if (user && user.userId) {
          roomUserList.set(user.userId, user);
        }
      });
    }
    return true;
  } catch (err) {
    console.error('âŒ Failed to load user list:', err);
    return false;
  }
}

function saveSystemMessages(roomId) {
  if (!roomId) return;
  try {
    const key = `${ROOM_SYSTEM_MESSAGES_KEY}_${roomId}`;
    const stateData = {
      version: STATE_VERSION,
      timestamp: Date.now(),
      roomId: roomId,
      messages: systemMessages
    };
    localStorage.setItem(key, serializeState(stateData));
  } catch (err) {
    console.error('âŒ Failed to save system messages:', err);
  }
}

function loadSystemMessages(roomId) {
  if (!roomId) return false;
  try {
    const key = `${ROOM_SYSTEM_MESSAGES_KEY}_${roomId}`;
    const stored = localStorage.getItem(key);
    if (!stored) return false;
    
    const stateData = deserializeState(stored);
    if (!stateData || stateData.version !== STATE_VERSION || stateData.roomId !== roomId) {
      return false;
    }
    
    systemMessages = Array.isArray(stateData.messages) ? stateData.messages : [];
    return true;
  } catch (err) {
    console.error('âŒ Failed to load system messages:', err);
    return false;
  }
}

function saveAlertState(roomId, isVisible) {
  if (!roomId) return;
  try {
    const key = `${ROOM_ALERT_STATE_KEY}_${roomId}`;
    const stateData = {
      version: STATE_VERSION,
      timestamp: Date.now(),
      roomId: roomId,
      isVisible: isVisible
    };
    localStorage.setItem(key, serializeState(stateData));
  } catch (err) {
    console.error('âŒ Failed to save alert state:', err);
  }
}

function loadAlertState(roomId) {
  if (!roomId) return false;
  try {
    const key = `${ROOM_ALERT_STATE_KEY}_${roomId}`;
    const stored = localStorage.getItem(key);
    if (!stored) return false;
    
    const stateData = deserializeState(stored);
    if (!stateData || stateData.version !== STATE_VERSION || stateData.roomId !== roomId) {
      return false;
    }
    return stateData.isVisible === true;
  } catch (err) {
    console.error('âŒ Failed to load alert state:', err);
    return false;
  }
}

function saveParticipationState(roomId, hasJoined) {
  if (!roomId) return;
  try {
    const key = `${ROOM_PARTICIPATION_KEY}_${roomId}`;
    const stateData = {
      version: STATE_VERSION,
      timestamp: Date.now(),
      roomId: roomId,
      hasJoined: hasJoined,
      userId: currentUser?.userId
    };
    sessionStorage.setItem(key, serializeState(stateData));
  } catch (err) {
    console.error('âŒ Failed to save participation state:', err);
  }
}

function loadParticipationState(roomId) {
  if (!roomId) return false;
  try {
    const key = `${ROOM_PARTICIPATION_KEY}_${roomId}`;
    const stored = sessionStorage.getItem(key);
    if (!stored) return false;
    
    const stateData = deserializeState(stored);
    if (!stateData || stateData.version !== STATE_VERSION || stateData.roomId !== roomId) {
      return false;
    }
    if (stateData.userId !== currentUser?.userId) {
      return false;
    }
    return stateData.hasJoined === true;
  } catch (err) {
    console.error('âŒ Failed to load participation state:', err);
    return false;
  }
}

function clearRoomState(roomId) {
  if (!roomId) return;
  try {
    localStorage.removeItem(`${ROOM_USER_LIST_KEY}_${roomId}`);
    localStorage.removeItem(`${ROOM_SYSTEM_MESSAGES_KEY}_${roomId}`);
    localStorage.removeItem(`${ROOM_ALERT_STATE_KEY}_${roomId}`);
    sessionStorage.removeItem(`${ROOM_PARTICIPATION_KEY}_${roomId}`);
    roomUserList.clear();
    systemMessages = [];
    isAlertDialogVisible = false;
    hasJoinedRoom = false;
  } catch (err) {
    console.error('âŒ Failed to clear room state:', err);
  }
}

function detectPageRefresh() {
  if (window.performance && window.performance.getEntriesByType) {
    const navEntries = window.performance.getEntriesByType('navigation');
    if (navEntries.length > 0 && navEntries[0].type === 'reload') {
      return true;
    }
  }
  if (window.performance && window.performance.navigation) {
    const navType = window.performance.navigation.type;
    if (navType === 1) {
      return true;
    }
  }
  return false;
}

function restoreStateAfterRefresh(roomId) {
  console.log('ðŸ”„ RESTORING STATE AFTER REFRESH');
  let restored = false;
  if (loadUserList(roomId)) {
    restored = true;
    renderUserList();
  }
  if (loadSystemMessages(roomId)) {
    restored = true;
    renderSystemMessages();
  }
  isAlertDialogVisible = loadAlertState(roomId);
  hasJoinedRoom = loadParticipationState(roomId);
  return restored;
}

function addUserToRoom(user) {
  if (!user || !user.userId) {
    return false;
  }
  if (roomUserList.has(user.userId)) {
    return false;
  }
  roomUserList.set(user.userId, {
    userId: user.userId,
    username: user.username,
    pfpUrl: user.pfpUrl
  });
  return true;
}

function removeUserFromRoom(userId) {
  if (!userId) return false;
  const user = roomUserList.get(userId);
  if (!user) {
    return false;
  }
  roomUserList.delete(userId);
  return true;
}

function addSystemMessage(type, username, timestamp) {
  const message = {
    id: `system_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    type: type,
    username: username,
    timestamp: timestamp || Date.now(),
    isSystemMessage: true
  };
  systemMessages.push(message);
  return message;
}

function renderSystemMessages() {
  if (!messagesList) return;
  systemMessages.forEach(msg => {
    renderSystemMessageInChat(msg);
  });
}

function renderSystemMessageInChat(message) {
  if (!messagesList) return;
  const existing = messagesList.querySelector(`[data-message-id="${message.id}"]`);
  if (existing) {
    return;
  }
  const messageDiv = document.createElement('div');
  messageDiv.className = 'system-message text-center text-xs text-gray-500 my-2';
  messageDiv.dataset.messageId = message.id;
  messageDiv.dataset.timestamp = message.timestamp;
  const text = message.type === 'join' ? `${message.username} joined` : `${message.username} left`;
  messageDiv.textContent = text;
  
  const messages = Array.from(messagesList.children);
  let inserted = false;
  for (let i = 0; i < messages.length; i++) {
    const existingTimestamp = parseInt(messages[i].dataset.timestamp || '0');
    if (message.timestamp < existingTimestamp) {
      messagesList.insertBefore(messageDiv, messages[i]);
      inserted = true;
      break;
    }
  }
  if (!inserted) {
    messagesList.appendChild(messageDiv);
  }
  const shouldScroll = messagesList.scrollHeight - messagesList.scrollTop <= messagesList.clientHeight + 100;
  if (shouldScroll) {
    messagesList.scrollTop = messagesList.scrollHeight;
  }
}

function renderUserList() {
  if (!usersList) return;
  usersList.innerHTML = '';
  const users = Array.from(roomUserList.values()).sort((a, b) => 
    (a.username || '').localeCompare(b.username || '')
  );
  users.forEach(user => {
    const userCard = document.createElement('div');
    userCard.className = 'user-card flex items-center gap-2 sm:gap-3 p-2 sm:p-3 rounded-lg hover:bg-gray-50 transition-all cursor-pointer';
    userCard.dataset.userId = user.userId;
    const pfpElement = createProfilePictureElement(user.pfpUrl, user.username, 'w-10 h-10 sm:w-12 sm:h-12');
    const userInfo = document.createElement('div');
    userInfo.className = 'flex-1 min-w-0';
    const nameSpan = document.createElement('div');
    nameSpan.className = 'text-sm font-semibold truncate';
    nameSpan.textContent = user.username || 'User';
    const statusSpan = document.createElement('div');
    statusSpan.className = 'text-xs text-gray-500 flex items-center gap-1';
    statusSpan.innerHTML = '<span class="flex h-2 w-2 rounded-full bg-green-500 flex-shrink-0"></span> Online';
    userInfo.appendChild(nameSpan);
    userInfo.appendChild(statusSpan);
    userCard.appendChild(pfpElement);
    userCard.appendChild(userInfo);
    usersList.appendChild(userCard);
  });
  setupUserCardClick();
  if (onlineCount) {
    onlineCount.textContent = `${roomUserList.size} Online`;
  }
}

// ============================================
// EMOJI PICKER FUNCTIONS
// ============================================

/**
 * Fetch all emojis from EmojiHub API
 * Implements caching to avoid repeated API calls
 */

function findActiveSocketForUser(userId) {
  // CRITICAL FIX: O(1) lookup instead of O(n)
  const socketId = userToSocketId.get(userId);
  if (!socketId) {
    return null;
  }
  
  const socketInstance = io.sockets.sockets.get(socketId);
  if (socketInstance && socketInstance.connected) {
    return socketInstance;
  }
  
  // Socket disconnected but index not cleaned - remove stale entry
  userToSocketId.delete(userId);
  return null;
}

    
async function fetchEmojis() {
  console.log('ðŸ˜€ ========================================');
  console.log('ðŸ˜€ FETCHING EMOJIS FROM API');
  console.log('ðŸ˜€ ========================================');
  
  // Return cached data if available
  if (emojiData) {
    console.log('âœ… Using cached emoji data');
    console.log('ðŸ˜€ ========================================\n');
    return emojiData;
  }
  
  try {
    console.log('ðŸ“¡ Fetching from: https://emojihub.yurace.pro/api/all');
    const response = await fetch('https://emojihub.yurace.pro/api/all');
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    emojiData = await response.json();
    
    console.log(`âœ… Fetched ${emojiData.length} emojis`);
    console.log(`   Categories: ${[...new Set(emojiData.map(e => e.category))].length}`);
    console.log('ðŸ˜€ ========================================\n');
    
    return emojiData;
    
  } catch (error) {
    console.error('âŒ ========================================');
    console.error('âŒ EMOJI FETCH FAILED');
    console.error('âŒ ========================================');
    console.error('   Error:', error.message);
    console.error('   Stack:', error.stack);
    console.error('âŒ ========================================\n');
    throw error;
  }
}


  const emojiBtn = document.querySelector('.emoji-btn');
if (emojiBtn) {
  emojiBtn.addEventListener('click', openEmojiPicker, { passive: true });
  console.log('âœ… Emoji button listener attached');
}

// Emoji picker overlay click - close picker
const emojiPickerOverlay = document.getElementById('emojiPickerOverlay');
if (emojiPickerOverlay) {
  emojiPickerOverlay.addEventListener('click', (e) => {
    // Only close if clicking the overlay itself, not the sheet
    if (e.target === emojiPickerOverlay) {
      closeEmojiPicker();
    }
  }, { passive: true });
  console.log('âœ… Emoji overlay listener attached');
}

// Emoji search input - filter emojis
const emojiSearchInput = document.getElementById('emojiSearchInput');
if (emojiSearchInput) {
  const debouncedSearch = debounceEmojiSearch((value) => {
    emojiSearchTerm = value;
    renderEmojiGrid();
  }, 150);
  
  emojiSearchInput.addEventListener('input', (e) => {
    debouncedSearch(e.target.value);
  }, { passive: true });
  
  console.log('âœ… Emoji search listener attached');
}

// ESC key - close emoji picker
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && isEmojiPickerOpen) {
    closeEmojiPicker();
  }
});


    

/**
 * Process emoji data into optimized cache structure
 * Groups by category and creates search index
 */
function processEmojiData(rawData) {
  console.log('âš™ï¸ Processing emoji data for optimized access...');
  
  const categories = {};
  const searchIndex = [];
  
  rawData.forEach((emoji, index) => {
    // Parse HTML code to actual emoji character
    const emojiChar = emoji.htmlCode
      .map(code => String.fromCodePoint(parseInt(code.replace('&#', '').replace(';', ''))))
      .join('');
    
    const processed = {
      id: index,
      char: emojiChar,
      name: emoji.name,
      category: emoji.category,
      group: emoji.group,
      searchText: `${emoji.name} ${emoji.category} ${emoji.group}`.toLowerCase()
    };
    
    // Group by category
    if (!categories[emoji.category]) {
      categories[emoji.category] = [];
    }
    categories[emoji.category].push(processed);
    
    // Add to search index
    searchIndex.push(processed);
  });
  
  console.log(`âœ… Processed ${searchIndex.length} emojis into ${Object.keys(categories).length} categories`);
  
  return { categories, searchIndex, all: searchIndex };
}

/**
 * Filter emojis based on search term and category
 */
function filterEmojis(searchTerm, category) {
  if (!emojiCache) return [];
  
  let emojis = category === 'all' 
    ? emojiCache.all 
    : emojiCache.categories[category] || [];
  
  if (searchTerm) {
    const search = searchTerm.toLowerCase().trim();
    emojis = emojis.filter(emoji => emoji.searchText.includes(search));
  }
  
  return emojis;
}

/**
 * Render category tabs
 */
function renderEmojiCategories() {
  const container = document.getElementById('emojiCategories');
  if (!container || !emojiCache) return;
  
  const categories = ['all', ...Object.keys(emojiCache.categories).sort()];
  
  container.innerHTML = categories.map(cat => {
    const isActive = cat === currentEmojiCategory;
    const displayName = cat === 'all' ? 'All' : cat;
    return `
      <button 
        class="emoji-category-tab ${isActive ? 'active' : ''}" 
        data-category="${cat}"
      >
        ${displayName}
      </button>
    `;
  }).join('');
  
  // Add click handlers
  container.querySelectorAll('.emoji-category-tab').forEach(btn => {
    btn.addEventListener('click', () => {
      currentEmojiCategory = btn.dataset.category;
      renderEmojiCategories();
      renderEmojiGrid();
    }, { passive: true });
  });
}


function setupAndroidBackButtonHandler() {
  console.log('ðŸ“± Setting up Android back button handler');
  
  // Detect if we're in a WebView or mobile browser
  const isAndroid = /android/i.test(navigator.userAgent);
  const isInWebView = window.matchMedia('(display-mode: standalone)').matches;
  
  if (isAndroid || isInWebView) {
    console.log('âœ… Android/WebView detected - back button handler active');
    
    // Push a dummy state to history
    history.pushState({ page: 'chat' }, '', window.location.href);
    
    window.addEventListener('popstate', async (event) => {
      console.log('ðŸ”™ ========================================');
      console.log('ðŸ”™ ANDROID BACK BUTTON PRESSED');
      console.log('ðŸ”™ ========================================');
      
      // Prevent default back navigation
      event.preventDefault();
      
      // Show confirmation dialog
      const shouldLeave = await showConfirmationDialog();
      
      if (shouldLeave) {
        console.log('âœ… User confirmed leave via back button');
        
        // Execute EXACT same leave sequence as Leave button
        try {
          stopCachedCallMonitoring();
          
          const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
          if (activeCallStr) {
            const callData = JSON.parse(activeCallStr);
            if (socketInstance?.connected) {
              socketInstance.emit('leave_call', { callId: callData.callId });
              await new Promise(resolve => setTimeout(resolve, 300));
            }
            localStorage.removeItem(ACTIVE_CALL_KEY);
            sessionStorage.removeItem('hasBackgroundCall');
            sessionStorage.removeItem('returningFromCall');
            sessionStorage.removeItem('backgroundCallMode');
            sessionStorage.removeItem('returningToBackgroundCall');
          }
          
          if (socketInstance?.connected) {
            socketInstance.emit('leave_room');
            await new Promise(resolve => setTimeout(resolve, 300));
          }
          
          await clearChatState(true);
          
          console.log('âœ… Leave sequence complete - navigating to mood.html');
          window.location.href = '/mood.html';
          
        } catch (error) {
          console.error('âŒ Error in back button leave sequence:', error);
          window.location.href = '/mood.html';
        }
      } else {
        console.log('âŒ User cancelled leave via back button');
        // Push state again to prevent navigation
        history.pushState({ page: 'chat' }, '', window.location.href);
      }
      
      console.log('ðŸ”™ ========================================\n');
    });
  } else {
    console.log('â„¹ï¸ Not Android/WebView - standard back button behavior');
  }
}


/**
 * Render emoji grid with current filters
 * Uses virtual scrolling concept by limiting initial render
 */
function renderEmojiGrid() {
  const container = document.getElementById('emojiGrid');
  if (!container) return;
  
  const filteredEmojis = filterEmojis(emojiSearchTerm, currentEmojiCategory);
  
  console.log(`ðŸŽ¨ Rendering ${filteredEmojis.length} emojis (category: ${currentEmojiCategory}, search: "${emojiSearchTerm}")`);
  
  if (filteredEmojis.length === 0) {
    container.innerHTML = '<div class="emoji-empty">No emojis found</div>';
    return;
  }
  
  // Render first 200 emojis immediately for performance
  // Load more on scroll if needed (simplified approach)
  const toRender = filteredEmojis.slice(0, 200);
  
  container.innerHTML = toRender.map(emoji => `
    <div 
      class="emoji-item" 
      data-emoji="${emoji.char}"
      title="${emoji.name}"
    >
      ${emoji.char}
    </div>
  `).join('');
  
  // Add click handlers
  container.querySelectorAll('.emoji-item').forEach(item => {
    item.addEventListener('click', () => {
      insertEmojiIntoInput(item.dataset.emoji);
    }, { passive: true });
  });
}

/**
 * Insert emoji into message input at cursor position
 * CRITICAL: Maintains cursor position and existing text
 */
function insertEmojiIntoInput(emoji) {
  if (!messageInput) {
    console.error('âŒ Message input not found');
    return;
  }
  
  console.log(`ðŸ˜€ Inserting emoji: ${emoji}`);
  
  // Get current cursor position
  const start = messageInput.selectionStart;
  const end = messageInput.selectionEnd;
  const currentValue = messageInput.value;
  
  // Insert emoji at cursor position
  const newValue = currentValue.substring(0, start) + emoji + currentValue.substring(end);
  messageInput.value = newValue;
  
  // Restore cursor position (after the inserted emoji)
  const newCursorPos = start + emoji.length;
  messageInput.setSelectionRange(newCursorPos, newCursorPos);
  
  // Focus input
  messageInput.focus();
  
  console.log(`âœ… Emoji inserted at position ${start}, cursor now at ${newCursorPos}`);
  
  // Close picker after selection
  closeEmojiPicker();
}

/**
 * Open emoji picker bottom sheet
 */
async function openEmojiPicker() {
  console.log('ðŸ˜€ ========================================');
  console.log('ðŸ˜€ OPENING EMOJI PICKER');
  console.log('ðŸ˜€ ========================================');
  
  const overlay = document.getElementById('emojiPickerOverlay');
  if (!overlay) {
    console.error('âŒ Emoji picker overlay not found');
    return;
  }
  
  if (isEmojiPickerOpen) {
    console.log('âš ï¸ Picker already open');
    console.log('ðŸ˜€ ========================================\n');
    return;
  }
  
  isEmojiPickerOpen = true;
  
  // Show loading state
  const grid = document.getElementById('emojiGrid');
  if (grid) {
    grid.innerHTML = `
      <div class="emoji-loading">
        <div class="emoji-loading-spinner"></div>
        <div>Loading emojis...</div>
      </div>
    `;
  }
  
  // Show overlay with animation
  overlay.classList.add('active');
  console.log('âœ… Overlay shown');
  
  try {
    // Fetch emojis if not cached
    if (!emojiCache) {
      console.log('ðŸ“¡ Fetching emoji data...');
      const rawData = await fetchEmojis();
      emojiCache = processEmojiData(rawData);
      console.log('âœ… Emoji cache ready');
    }
    
    // Render UI
    renderEmojiCategories();
    renderEmojiGrid();
    
    console.log('âœ… Emoji picker rendered successfully');
    
  } catch (error) {
    console.error('âŒ Failed to load emojis:', error);
    
    if (grid) {
      grid.innerHTML = `
        <div class="emoji-error">
          <div style="font-size: 2rem; margin-bottom: 8px;">ðŸ˜ž</div>
          <div>Failed to load emojis</div>
          <div style="font-size: 0.75rem; margin-top: 4px; opacity: 0.7;">Please try again</div>
        </div>
      `;
    }
  }
  
  console.log('ðŸ˜€ ========================================\n');
}

/**
 * Close emoji picker bottom sheet
 */
function closeEmojiPicker() {
  console.log('ðŸ˜€ Closing emoji picker');
  
  const overlay = document.getElementById('emojiPickerOverlay');
  if (overlay) {
    overlay.classList.remove('active');
  }
  
  isEmojiPickerOpen = false;
  
  // Reset search
  emojiSearchTerm = '';
  const searchInput = document.getElementById('emojiSearchInput');
  if (searchInput) {
    searchInput.value = '';
  }
  
  // Reset to "all" category
  currentEmojiCategory = 'all';
  
  console.log('âœ… Emoji picker closed');
}

/**
 * Debounce function for search input
 */
function debounceEmojiSearch(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}


function setAuthenticationState(authenticated) {
  console.log(`ðŸ” ========================================`);
  console.log(`ðŸ” AUTHENTICATION STATE CHANGE`);
  console.log(`ðŸ” ========================================`);
  console.log(`   Previous state: ${isSocketAuthenticated}`);
  console.log(`   New state: ${authenticated}`);
  
  isSocketAuthenticated = authenticated;
  
  if (authenticated) {
    console.log(`âœ… Socket fully authenticated - enabling call features`);
    enableCallButtons();
  } else {
    console.log(`ðŸ”’ Socket not authenticated - disabling call features`);
    disableCallButtons(true); // true = show loading state
  }
  
  console.log(`ðŸ” ========================================\n`);
}



// ============================================
// INDEXEDDB SETUP FOR FILE ATTACHMENTS
// ============================================
const DB_NAME = 'MoodLogChatFiles';
const DB_VERSION = 1;
const FILE_STORE_NAME = 'attachments';


let dbInstance = null;

/**
 * Initialize IndexedDB for file storage
 * Returns promise that resolves to DB instance
 */
function initFileDB() {
  return new Promise((resolve, reject) => {
    if (dbInstance) {
      resolve(dbInstance);
      return;
    }
    
    console.log('ðŸ“‚ Initializing IndexedDB for file attachments...');
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    
    request.onerror = () => {
      console.error('âŒ IndexedDB open failed:', request.error);
      reject(request.error);
    };
    
    request.onsuccess = () => {
      dbInstance = request.result;
      console.log('âœ… IndexedDB initialized successfully');
      resolve(dbInstance);
    };
    
    request.onupgradeneeded = (event) => {
      console.log('ðŸ”§ IndexedDB upgrade needed - creating object stores');
      const db = event.target.result;
      
      // Create object store for file attachments
      if (!db.objectStoreNames.contains(FILE_STORE_NAME)) {
        const store = db.createObjectStore(FILE_STORE_NAME, { keyPath: 'id' });
        store.createIndex('roomId', 'roomId', { unique: false });
        store.createIndex('messageId', 'messageId', { unique: false });
        store.createIndex('timestamp', 'timestamp', { unique: false });
        console.log('âœ… Object store created:', FILE_STORE_NAME);
      }
    };
  });
}

/**
 * Store file in IndexedDB without keeping in RAM
 * Uses chunked reading for large files
 */
async function storeFileToIndexedDB(file, roomId, messageId = null) {
  console.log('ðŸ’¾ ========================================');
  console.log('ðŸ’¾ STORING FILE TO INDEXEDDB');
  console.log('ðŸ’¾ ========================================');
  console.log(`   File: ${file.name}`);
  console.log(`   Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
  console.log(`   Type: ${file.type}`);
  console.log(`   Room: ${roomId}`);
  
  try {
    const db = await initFileDB();
    
    // Generate unique ID
    const fileId = `file_${roomId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Read file in chunks to avoid memory issues
    const chunks = [];
    let offset = 0;
    
    while (offset < file.size) {
      const chunk = file.slice(offset, offset + CHUNK_SIZE);
      const arrayBuffer = await readChunkAsArrayBuffer(chunk);
      chunks.push(arrayBuffer);
      offset += CHUNK_SIZE;
      
      // Log progress for large files
      if (file.size > 5 * 1024 * 1024) {
        const progress = ((offset / file.size) * 100).toFixed(1);
        console.log(`   Progress: ${progress}%`);
      }
    }
    
    // Combine chunks into single Blob (IndexedDB can store Blobs efficiently)
    const blob = new Blob(chunks, { type: file.type });
    
    // Clear chunks array to free memory
    chunks.length = 0;
    
    // Store file metadata and blob
    const fileRecord = {
      id: fileId,
      roomId: roomId,
      messageId: messageId,
      name: file.name,
      type: file.type,
      size: file.size,
      blob: blob, // IndexedDB stores this on disk, not in RAM
      timestamp: Date.now()
    };
    
    await new Promise((resolve, reject) => {
      const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
      const store = transaction.objectStore(FILE_STORE_NAME);
      const request = store.add(fileRecord);
      
      request.onsuccess = () => {
        console.log(`âœ… File stored to IndexedDB: ${fileId}`);
        console.log(`   Disk-backed storage (not in RAM)`);
        resolve(fileId);
      };
      
      request.onerror = () => {
        console.error('âŒ Failed to store file:', request.error);
        reject(request.error);
      };
    });
    
    console.log('ðŸ’¾ ========================================\n');
    return fileId;
    
  } catch (error) {
    console.error('âŒ Error storing file to IndexedDB:', error);
    console.log('ðŸ’¾ ========================================\n');
    throw error;
  }
}

/**
 * Read file chunk as ArrayBuffer without blocking main thread
 */
function readChunkAsArrayBuffer(chunk) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
    reader.readAsArrayBuffer(chunk);
  });
}

/**
 * Retrieve file from IndexedDB
 */
async function getFileFromIndexedDB(fileId) {
  console.log(`ðŸ“‚ Retrieving file: ${fileId}`);
  
  try {
    const db = await initFileDB();
    
    return await new Promise((resolve, reject) => {
      const transaction = db.transaction([FILE_STORE_NAME], 'readonly');
      const store = transaction.objectStore(FILE_STORE_NAME);
      const request = store.get(fileId);
      
      request.onsuccess = () => {
        if (request.result) {
          console.log(`âœ… File retrieved: ${request.result.name}`);
          resolve(request.result);
        } else {
          console.warn(`âš ï¸ File not found: ${fileId}`);
          resolve(null);
        }
      };
      
      request.onerror = () => {
        console.error('âŒ Failed to retrieve file:', request.error);
        reject(request.error);
      };
    });
    
  } catch (error) {
    console.error('âŒ Error retrieving file:', error);
    throw error;
  }
}

/**
 * CRITICAL: Delete ALL files associated with a room
 * Called when room is destroyed, expired, or left
 */
async function deleteRoomFiles(roomId) {
  console.log('ðŸ—‘ï¸ ========================================');
  console.log('ðŸ—‘ï¸ DELETING ALL FILES FOR ROOM');
  console.log('ðŸ—‘ï¸ ========================================');
  console.log(`   Room ID: ${roomId}`);
  
  try {
    const db = await initFileDB();
    
    return await new Promise((resolve, reject) => {
      const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
      const store = transaction.objectStore(FILE_STORE_NAME);
      const index = store.index('roomId');
      const request = index.openCursor(IDBKeyRange.only(roomId));
      
      let deletedCount = 0;
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          console.log(`   ðŸ—‘ï¸ Deleting file: ${cursor.value.name} (${cursor.value.id})`);
          cursor.delete();
          deletedCount++;
          cursor.continue();
        } else {
          console.log(`âœ… Deleted ${deletedCount} file(s) for room ${roomId}`);
          console.log('ðŸ—‘ï¸ ========================================\n');
          resolve(deletedCount);
        }
      };
      
      request.onerror = () => {
        console.error('âŒ Failed to delete room files:', request.error);
        console.log('ðŸ—‘ï¸ ========================================\n');
        reject(request.error);
      };
    });
    
  } catch (error) {
    console.error('âŒ Error deleting room files:', error);
    console.log('ðŸ—‘ï¸ ========================================\n');
    throw error;
  }
}

/**
 * Delete specific file by ID
 */
async function deleteFileFromIndexedDB(fileId) {
  console.log(`ðŸ—‘ï¸ Deleting file: ${fileId}`);
  
  try {
    const db = await initFileDB();
    
    await new Promise((resolve, reject) => {
      const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
      const store = transaction.objectStore(FILE_STORE_NAME);
      const request = store.delete(fileId);
      
      request.onsuccess = () => {
        console.log(`âœ… File deleted: ${fileId}`);
        resolve();
      };
      
      request.onerror = () => {
        console.error('âŒ Failed to delete file:', request.error);
        reject(request.error);
      };
    });
    
  } catch (error) {
    console.error('âŒ Error deleting file:', error);
    throw error;
  }
}

/**
 * Get count of files for a room (for debugging/monitoring)
 */
async function getRoomFileCount(roomId) {
  try {
    const db = await initFileDB();
    
    return await new Promise((resolve, reject) => {
      const transaction = db.transaction([FILE_STORE_NAME], 'readonly');
      const store = transaction.objectStore(FILE_STORE_NAME);
      const index = store.index('roomId');
      const request = index.count(IDBKeyRange.only(roomId));
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
    
  } catch (error) {
    console.error('âŒ Error counting room files:', error);
    return 0;
  }
}


// ============================================
// FILE VALIDATION
// ============================================
const SUPPORTED_FILE_TYPES = {
  // Images - 10MB max
  'image/jpeg': { ext: ['.jpg', '.jpeg'], maxSize: 10 * 1024 * 1024 },
  'image/png': { ext: ['.png'], maxSize: 10 * 1024 * 1024 },
  'image/gif': { ext: ['.gif'], maxSize: 10 * 1024 * 1024 },
  'image/webp': { ext: ['.webp'], maxSize: 10 * 1024 * 1024 },
  
  // Videos - 10MB max (production should use CDN for larger)
  'video/mp4': { ext: ['.mp4'], maxSize: 10 * 1024 * 1024 },
  'video/webm': { ext: ['.webm'], maxSize: 10 * 1024 * 1024 },
  'video/quicktime': { ext: ['.mov'], maxSize: 10 * 1024 * 1024 },
  
  // Documents - 10MB max
  'application/pdf': { ext: ['.pdf'], maxSize: 10 * 1024 * 1024 },
};

const ABSOLUTE_MAX_FILE_SIZE = 10 * 1024 * 1024;

/**
 * Validate file before processing
 * Returns { valid: boolean, error: string|null }
 */
function validateFile(file) {
  console.log('ðŸ” ========================================');
  console.log('ðŸ” FILE VALIDATION');
  console.log('ðŸ” ========================================');
  console.log(`   File: ${file.name}`);
  console.log(`   Type: ${file.type}`);
  console.log(`   Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
  
  // CRITICAL: Absolute size check first
  if (file.size > ABSOLUTE_MAX_FILE_SIZE) {
    const sizeMB = (file.size / 1024 / 1024).toFixed(2);
    const maxMB = (ABSOLUTE_MAX_FILE_SIZE / 1024 / 1024).toFixed(0);
    console.error(`âŒ File exceeds absolute limit: ${sizeMB}MB > ${maxMB}MB`);
    console.log('ðŸ” ========================================\n');
    return {
      valid: false,
      error: `File too large (${sizeMB}MB). Maximum file size is ${maxMB}MB.`
    };
  }
  
  // Check file type
  const typeConfig = SUPPORTED_FILE_TYPES[file.type];
  if (!typeConfig) {
    console.error(`âŒ Unsupported file type: ${file.type}`);
    console.log('ðŸ” ========================================\n');
    return {
      valid: false,
      error: `Unsupported file type. Supported: images (JPG, PNG, GIF, WebP), videos (MP4, WebM, MOV), and PDFs.`
    };
  }
  
  // Check file extension matches MIME type
  const fileName = file.name.toLowerCase();
  const hasValidExtension = typeConfig.ext.some(ext => fileName.endsWith(ext));
  if (!hasValidExtension) {
    console.error(`âŒ File extension doesn't match type: ${file.name}`);
    console.log('ðŸ” ========================================\n');
    return {
      valid: false,
      error: `File extension doesn't match its type. Expected: ${typeConfig.ext.join(', ')}`
    };
  }
  
  // Check type-specific size limit
  if (file.size > typeConfig.maxSize) {
    const sizeMB = (file.size / 1024 / 1024).toFixed(2);
    const maxMB = (typeConfig.maxSize / 1024 / 1024).toFixed(0);
    console.error(`âŒ File exceeds type limit: ${sizeMB}MB > ${maxMB}MB`);
    console.log('ðŸ” ========================================\n');
    return {
      valid: false,
      error: `${file.type} files must be under ${maxMB}MB. Your file is ${sizeMB}MB.`
    };
  }
  
  console.log('âœ… File validation passed');
  console.log('ðŸ” ========================================\n');
  return { valid: true, error: null };
}



// ============================================
// CHUNKED FILE TRANSMISSION CONFIGURATION
// ============================================
const CHUNK_SIZE = 256 * 1024; // 256KB chunks (safe for Socket.IO)
const CHUNK_TIMEOUT = 30000; // 30s timeout per chunk
const MAX_RETRIES = 3; // Retry failed chunks up to 3 times

/**
 * Chunk file into manageable pieces for transmission
 * Returns array of { index, data: base64, size }
 */
async function chunkFile(file) {
  console.log('âœ‚ï¸ ========================================');
  console.log('âœ‚ï¸ CHUNKING FILE FOR TRANSMISSION');
  console.log('âœ‚ï¸ ========================================');
  console.log(`   File: ${file.name}`);
  console.log(`   Total size: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
  console.log(`   Chunk size: ${(CHUNK_SIZE / 1024).toFixed(0)} KB`);
  
  const chunks = [];
  const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
  console.log(`   Total chunks: ${totalChunks}`);
  
  for (let i = 0; i < totalChunks; i++) {
    const start = i * CHUNK_SIZE;
    const end = Math.min(start + CHUNK_SIZE, file.size);
    const blob = file.slice(start, end);
    
    // Convert chunk to base64
    const base64 = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64Data = reader.result.split(',')[1];
        resolve(base64Data);
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    
    chunks.push({
      index: i,
      data: base64,
      size: blob.size
    });
    
    // Log progress every 10 chunks
    if ((i + 1) % 10 === 0 || i === totalChunks - 1) {
      const progress = ((i + 1) / totalChunks * 100).toFixed(1);
      console.log(`   Chunking progress: ${progress}% (${i + 1}/${totalChunks})`);
    }
  }
  
  console.log(`âœ… File chunked: ${chunks.length} chunks ready`);
  console.log('âœ‚ï¸ ========================================\n');
  
  return chunks;
}

/**
 * Send file using chunked transmission protocol
 * Returns Promise that resolves when all chunks are acknowledged
 */
async function sendFileInChunks(fileId, fileName, fileType, fileSize, chunks, roomId) {
  console.log('ðŸ“¤ ========================================');
  console.log('ðŸ“¤ CHUNKED FILE TRANSMISSION START');
  console.log('ðŸ“¤ ========================================');
  console.log(`   FileID: ${fileId}`);
  console.log(`   File: ${fileName}`);
  console.log(`   Chunks: ${chunks.length}`);
  console.log(`   Room: ${roomId}`);
  
  return new Promise((resolve, reject) => {
    let currentChunk = 0;
    let ackReceived = false;
    let timeoutHandle = null;
    let retryCount = 0;
    
    // Listen for chunk acknowledgments
    const ackHandler = (data) => {
      if (data.fileId !== fileId) return;
      
      console.log(`âœ… Chunk ${data.chunkIndex}/${chunks.length - 1} acknowledged`);
      ackReceived = true;
      clearTimeout(timeoutHandle);
      
      currentChunk++;
      
      // Update progress UI
      const progress = Math.round((currentChunk / chunks.length) * 100);
      const progressText = document.getElementById('uploadProgressText');
      if (progressText) {
        progressText.textContent = `Uploading: ${progress}%`;
      }
      
      if (currentChunk < chunks.length) {
        retryCount = 0; // Reset retry counter on success
        sendNextChunk();
      } else {
        console.log('âœ… All chunks transmitted successfully');
        socketInstance.off('file_chunk_ack', ackHandler);
        resolve();
      }
    };
    
    socketInstance.on('file_chunk_ack', ackHandler);
    
    const sendNextChunk = () => {
      if (currentChunk >= chunks.length) return;
      
      ackReceived = false;
      const chunk = chunks[currentChunk];
      
      console.log(`ðŸ“¤ Sending chunk ${currentChunk}/${chunks.length - 1} (${(chunk.size / 1024).toFixed(2)} KB)`);
      
      socketInstance.emit('file_chunk', {
        fileId,
        fileName,
        fileType,
        fileSize,
        roomId,
        chunkIndex: currentChunk,
        totalChunks: chunks.length,
        chunkData: chunk.data,
        chunkSize: chunk.size
      });
      
      // Set timeout for this chunk
      timeoutHandle = setTimeout(() => {
        if (!ackReceived) {
          console.error(`âŒ Chunk ${currentChunk} timeout (no ACK received)`);
          
          if (retryCount < MAX_RETRIES) {
            retryCount++;
            console.log(`ðŸ”„ Retrying chunk ${currentChunk} (attempt ${retryCount}/${MAX_RETRIES})`);
            sendNextChunk();
          } else {
            socketInstance.off('file_chunk_ack', ackHandler);
            reject(new Error(`Chunk ${currentChunk} failed after ${MAX_RETRIES} retries`));
          }
        }
      }, CHUNK_TIMEOUT);
    };
    
    // Start transmission
    sendNextChunk();
  });
}

class ChunkedFileReceiver {
  constructor() {
    this.activeTransfers = new Map();
  }
  
  async handleChunk(data) {
    const { fileId, fileName, fileType, fileSize, roomId, chunkIndex, totalChunks, chunkData, chunkSize } = data;
    
    console.log(`ðŸ“¥ Received chunk ${chunkIndex}/${totalChunks - 1} for ${fileName}`);
    
    if (!this.activeTransfers.has(fileId)) {
      console.log(`ðŸ†• Starting new file transfer: ${fileId}`);
      this.activeTransfers.set(fileId, {
        chunks: new Array(totalChunks),
        metadata: { fileName, fileType, fileSize, roomId, totalChunks },
        receivedCount: 0
      });
    }
    
    const transfer = this.activeTransfers.get(fileId);
    
    transfer.chunks[chunkIndex] = chunkData;
    transfer.receivedCount++;
    
    socketInstance.emit('file_chunk_ack', { fileId, chunkIndex });
    
    const progress = Math.round((transfer.receivedCount / totalChunks) * 100);
    console.log(`ðŸ“Š Transfer progress: ${progress}% (${transfer.receivedCount}/${totalChunks})`);
    
    if (transfer.receivedCount === totalChunks) {
      console.log('âœ… All chunks received, reconstructing file...');
      await this.reconstructFile(fileId, transfer);
    }
  }
  
  async reconstructFile(fileId, transfer) {
    const { chunks, metadata } = transfer;
    const { fileName, fileType, fileSize, roomId } = metadata;
    
    console.log('ðŸ”§ ========================================');
    console.log('ðŸ”§ RECONSTRUCTING FILE FROM CHUNKS');
    console.log('ðŸ”§ ========================================');
    console.log(`   FileID: ${fileId}`);
    console.log(`   File: ${fileName}`);
    console.log(`   Chunks: ${chunks.length}`);
    
    try {
      const binaryChunks = [];
      let totalBytes = 0;
      
      for (let i = 0; i < chunks.length; i++) {
        const base64Chunk = chunks[i];
        
        const byteCharacters = atob(base64Chunk);
        const byteNumbers = new Array(byteCharacters.length);
        for (let j = 0; j < byteCharacters.length; j++) {
          byteNumbers[j] = byteCharacters.charCodeAt(j);
        }
        const byteArray = new Uint8Array(byteNumbers);
        
        binaryChunks.push(byteArray);
        totalBytes += byteArray.length;
      }
      
      console.log(`âœ… All chunks decoded: ${totalBytes} bytes`);
      
      const combinedArray = new Uint8Array(totalBytes);
      let offset = 0;
      for (const chunk of binaryChunks) {
        combinedArray.set(chunk, offset);
        offset += chunk.length;
      }
      
      const blob = new Blob([combinedArray], { type: fileType });
      console.log(`âœ… Blob created: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
      
      const db = await initFileDB();
      
      await new Promise((resolve, reject) => {
        const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(FILE_STORE_NAME);
        
        const fileRecord = {
          id: fileId,
          roomId: roomId,
          messageId: null,
          name: fileName,
          type: fileType,
          size: blob.size,
          blob: blob,
          timestamp: Date.now()
        };
        
        const request = store.put(fileRecord);
        
        request.onsuccess = () => {
          console.log(`âœ… File stored to IndexedDB: ${fileId}`);
          resolve();
        };
        
        request.onerror = () => {
          console.error('âŒ Failed to store file:', request.error);
          reject(request.error);
        };
      });
      
      this.activeTransfers.delete(fileId);
      
      console.log('âœ… File reconstruction complete');
      console.log('ðŸ”§ ========================================\n');
      
      const imgElements = document.querySelectorAll(`img[data-file-id="${fileId}"]`);
      if (imgElements.length > 0) {
        console.log(`ðŸ–¼ï¸ Updating ${imgElements.length} image element(s)`);
        imgElements.forEach(img => loadImageAttachment(fileId, img));
      }
      
      toast(`Received: ${fileName}`, 'success');
      
    } catch (error) {
      console.error('âŒ File reconstruction failed:', error);
      console.log('ðŸ”§ ========================================\n');
      this.activeTransfers.delete(fileId);
      toast(`Failed to receive: ${fileName}`, 'error');
      throw error;
    }
  }
  
  cleanup(fileId) {
    if (this.activeTransfers.has(fileId)) {
      console.log(`ðŸ§¹ Cleaning up incomplete transfer: ${fileId}`);
      this.activeTransfers.delete(fileId);
    }
  }
}

// Initialize global receiver
const fileReceiver = new ChunkedFileReceiver();



function waitForAuthentication() {
  if (isSocketAuthenticated) {
    console.log(`âœ… Already authenticated, proceeding immediately`);
    return Promise.resolve();
  }
  
  if (!authenticationPromise) {
    console.log(`â³ Creating authentication promise...`);
    authenticationPromise = new Promise((resolve) => {
      const checkAuth = () => {
        if (isSocketAuthenticated) {
          console.log(`âœ… Authentication promise resolved`);
          resolve();
        } else {
          setTimeout(checkAuth, 50);
        }
      };
      checkAuth();
    });
  }
  
  return authenticationPromise;
}

function enableCallButtons() {
  console.log(`ðŸŽšï¸ Enabling call buttons`);
  
  if (audioCallBtn) {
    audioCallBtn.disabled = false;
    audioCallBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'animate-pulse');
    audioCallBtn.title = 'Start Audio Call';
    console.log(`   âœ… Audio button enabled`);
  }
  
  if (videoCallBtn) {
    videoCallBtn.disabled = false;
    videoCallBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'animate-pulse');
    videoCallBtn.title = 'Start Video Call';
    console.log(`   âœ… Video button enabled`);
  }
}

function disableCallButtons(showLoading = false) {
  console.log(`ðŸ”’ Disabling call buttons (loading: ${showLoading})`);
  
  if (audioCallBtn) {
    audioCallBtn.disabled = true;
    audioCallBtn.classList.add('opacity-50', 'cursor-not-allowed');
    if (showLoading) {
      audioCallBtn.classList.add('animate-pulse');
      audioCallBtn.title = 'Connecting...';
    } else {
      audioCallBtn.title = 'Authenticating...';
    }
    console.log(`   ðŸ”’ Audio button disabled`);
  }
  
  if (videoCallBtn) {
    videoCallBtn.disabled = true;
    videoCallBtn.classList.add('opacity-50', 'cursor-not-allowed');
    if (showLoading) {
      videoCallBtn.classList.add('animate-pulse');
      videoCallBtn.title = 'Connecting...';
    } else {
      videoCallBtn.title = 'Authenticating...';
    }
    console.log(`   ðŸ”’ Video button disabled`);
  }
}



/**
 * Format bytes to human readable size
 */
function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
}

/**
 * Get file type category for icon display
 */
function getFileTypeCategory(mimeType) {
  if (mimeType.startsWith('image/')) return 'image';
  if (mimeType.startsWith('video/')) return 'video';
  if (mimeType === 'application/pdf') return 'pdf';
  return 'document';
}

/**
 * Create Blob URL for image preview (must be revoked after use)
 */
function createImagePreviewUrl(blob) {
  if (blob.type.startsWith('image/')) {
    return URL.createObjectURL(blob);
  }
  return null;
}

/**
 * Show attachment preview in UI
 */
async function showAttachmentPreview(fileId, fileName, fileType, fileSize, blob) {
  console.log('ðŸ–¼ï¸ ========================================');
  console.log('ðŸ–¼ï¸ SHOWING ATTACHMENT PREVIEW');
  console.log('ðŸ–¼ï¸ ========================================');
  console.log(`   File: ${fileName}`);
  console.log(`   Type: ${fileType}`);
  console.log(`   Size: ${formatFileSize(fileSize)}`);
  
  const previewContainer = document.getElementById('attachmentPreview');
  const iconWrapper = document.getElementById('attachmentIconWrapper');
  const nameElement = document.getElementById('attachmentName');
  const sizeElement = document.getElementById('attachmentSize');
  
  if (!previewContainer || !iconWrapper || !nameElement || !sizeElement) {
    console.error('âŒ Preview elements not found');
    return;
  }
  
  // Clear previous preview
  iconWrapper.innerHTML = '';
  iconWrapper.className = 'attachment-icon-wrapper';
  
  const fileCategory = getFileTypeCategory(fileType);
  let previewUrl = null;
  
  // Generate appropriate preview based on file type
  if (fileCategory === 'image') {
    // Show image thumbnail
    previewUrl = createImagePreviewUrl(blob);
    if (previewUrl) {
      iconWrapper.classList.add('image-preview');
      const img = document.createElement('img');
      img.src = previewUrl;
      img.alt = fileName;
      iconWrapper.appendChild(img);
      console.log('âœ… Image preview created');
    }
  } else if (fileCategory === 'pdf') {
    // Show PDF icon
    iconWrapper.classList.add('pdf-preview');
    iconWrapper.innerHTML = '<span class="material-symbols-outlined">picture_as_pdf</span>';
    console.log('âœ… PDF icon displayed');
  } else if (fileCategory === 'video') {
    // Show video icon
    iconWrapper.classList.add('video-preview');
    iconWrapper.innerHTML = '<span class="material-symbols-outlined">videocam</span>';
    console.log('âœ… Video icon displayed');
  } else {
    // Show generic document icon
    iconWrapper.classList.add('pdf-preview');
    iconWrapper.innerHTML = '<span class="material-symbols-outlined">description</span>';
    console.log('âœ… Document icon displayed');
  }
  
  // Update file info
  nameElement.textContent = fileName;
  sizeElement.textContent = formatFileSize(fileSize);
  
  // Store attachment data
  pendingAttachment = {
    fileId,
    name: fileName,
    type: fileType,
    size: fileSize,
    previewUrl // Store for cleanup
  };
  
  // Show preview
  previewContainer.classList.remove('hidden');
  
  console.log('âœ… Attachment preview displayed');
  console.log('ðŸ–¼ï¸ ========================================\n');
}

/**
 * Hide and cleanup attachment preview
 */
function hideAttachmentPreview() {
  console.log('ðŸ§¹ Hiding attachment preview');
  
  const previewContainer = document.getElementById('attachmentPreview');
  if (previewContainer) {
    previewContainer.classList.add('hidden');
  }
  
  // Revoke blob URL to prevent memory leak
  if (pendingAttachment?.previewUrl) {
    URL.revokeObjectURL(pendingAttachment.previewUrl);
    console.log('âœ… Blob URL revoked');
  }
  
  pendingAttachment = null;
  console.log('âœ… Attachment preview cleaned up');
}
  
  
  
  
  function checkForCachedCall() {
    console.log('ðŸ” Checking for cached incoming call...');
    
    const cachedCallStr = localStorage.getItem(CACHED_CALL_KEY);
    
    if (!cachedCallStr) {
        console.log('â„¹ï¸ No cached call found');
        return;
    }
    
    try {
        const cachedCall = JSON.parse(cachedCallStr);
        const cacheAge = Date.now() - cachedCall.timestamp;
        
        console.log(`ðŸ“ž Found cached call from ${cachedCall.callerUsername}`);
        console.log(`   Age: ${(cacheAge / 1000).toFixed(1)}s`);
        console.log(`   Call ID: ${cachedCall.callId}`);
        
        // Check if cache is expired
        if (cacheAge > CALL_CACHE_TIMEOUT) {
            console.log(`â° Cached call expired (${(cacheAge / 1000).toFixed(1)}s > ${CALL_CACHE_TIMEOUT / 1000}s)`);
            localStorage.removeItem(CACHED_CALL_KEY);
            return;
        }
        
        // Check if call is still valid on server
        if (socketInstance && socketInstance.connected) {
            console.log(`ðŸ“¡ Validating cached call ${cachedCall.callId} with server...`);
            
            socketInstance.emit('validate_cached_call', {
                callId: cachedCall.callId,
                roomId: roomData.roomId
            });
        } else {
            console.warn('âš ï¸ Socket not connected, will retry validation');
        }
        
    } catch (e) {
        console.error('âŒ Failed to parse cached call:', e);
        localStorage.removeItem(CACHED_CALL_KEY);
    }
}

function showCachedCallModal(callData) {
    console.log('ðŸ“ž ========================================');
    console.log('ðŸ“ž SHOWING CACHED INCOMING CALL');
    console.log('ðŸ“ž ========================================');
    console.log(`   Caller: ${callData.callerUsername}`);
    console.log(`   Call ID: ${callData.callId}`);
    console.log(`   Type: ${callData.callType}`);
    
    // Set pending call data
    pendingCallData = {
        callId: callData.callId,
        callerUsername: callData.callerUsername,
        callerPfp: callData.callerPfp,
        callType: callData.callType,
        fromCache: true
    };
    
    // Update modal UI
    const callerName = document.getElementById('callerName');
    const callType = document.getElementById('callType');
    const callerAvatar = document.getElementById('callerAvatar');
    
    if (callerName) callerName.textContent = `${callData.callerUsername} is calling`;
    if (callType) callType.textContent = callData.callType === 'video' ? 'Video Call' : 'Audio Call';
    if (callerAvatar) {
        callerAvatar.innerHTML = '';
        const pfp = createProfilePictureElement(callData.callerPfp, callData.callerUsername, 'w-full h-full');
        callerAvatar.appendChild(pfp);
    }
    
    // Show modal immediately (no delay for cached calls)
    incomingCallModal?.classList.remove('hidden');
    
    console.log('âœ… Cached call modal displayed');
    console.log('ðŸ“ž ========================================\n');
}

function startCachedCallMonitoring() {
    console.log('ðŸ”„ Starting cached call monitoring...');
    
    // Check immediately on load
    checkForCachedCall();
    
    // Check every 2 seconds for cached calls
    cachedCallCheckInterval = setInterval(() => {
        checkForCachedCall();
    }, 2000);
    
    console.log('âœ… Cached call monitoring started (checks every 2s)');
}

function stopCachedCallMonitoring() {
    if (cachedCallCheckInterval) {
        clearInterval(cachedCallCheckInterval);
        cachedCallCheckInterval = null;
        console.log('ðŸ›‘ Cached call monitoring stopped');
    }
}
  
  
  // Function to cleanup parent call.html page
function cleanupParentCallPage() {
  console.log('ðŸ§¹ ========================================');
  console.log('ðŸ§¹ CLEANING UP PARENT CALL PAGE');
  console.log('ðŸ§¹ ========================================');
  
  // Check if we're in an iframe (chat overlay on call.html)
  if (window.parent && window.parent !== window) {
    console.log('ðŸ“± We are in iframe - accessing parent window');
    try {
      // Hide the floating button
      const parentFloatingBtn = window.parent.document.getElementById('floatingReturnToCall');
      if (parentFloatingBtn) {
        parentFloatingBtn.classList.add('hidden');
        console.log('âœ… Parent floating button hidden');
      }
      
      // Navigate parent window to mood.html (this will trigger call.html cleanup)
      console.log('ðŸ”„ Navigating parent window to mood.html');
      window.parent.location.href = '/mood.html';
      
      console.log('âœ… Parent window navigation initiated');
    } catch (e) {
      console.error('âŒ Cannot access parent window:', e);
      // Fallback: just navigate ourselves
      window.location.href = '/mood.html';
    }
  } else {
    console.log('â„¹ï¸ Not in iframe - navigating directly');
    window.location.href = '/mood.html';
  }
  
  console.log('ðŸ§¹ ========================================\n');
}
  
  
  // Function to hide floating button in parent call.html
function hideCallPageFloatingButton() {
  console.log('ðŸŽˆ Attempting to hide call.html floating button');
  
  // Check if we're in an iframe (chat overlay)
  if (window.parent && window.parent !== window) {
    console.log('ðŸ“± We are in iframe - accessing parent window');
    try {
      const parentFloatingBtn = window.parent.document.getElementById('floatingReturnToCall');
      if (parentFloatingBtn) {
        parentFloatingBtn.classList.add('hidden');
        console.log('âœ… Parent floating button hidden');
      } else {
        console.warn('âš ï¸ Parent floating button not found');
      }
    } catch (e) {
      console.error('âŒ Cannot access parent window (CORS?):', e);
    }
  } else {
    console.log('â„¹ï¸ Not in iframe - checking local DOM');
    // If not in iframe, might be standalone chat page
    const localFloatingBtn = document.getElementById('floatingReturnToCall');
    if (localFloatingBtn) {
      localFloatingBtn.classList.add('hidden');
      console.log('âœ… Local floating button hidden');
    }
  }
}
  


function returnToActiveCall() {
  console.log('ðŸ”™ ========================================');
  console.log('ðŸ”™ RETURNING TO ACTIVE CALL FROM CHAT');
  console.log('ðŸ”™ ========================================');
  
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  if (!activeCallStr) {
    console.error('âŒ No active call data found');
    toast('No active call found', 'error');
    return;
  }
  
  try {
    const activeCallData = JSON.parse(activeCallStr);
    console.log(`   callId: ${activeCallData.callId}`);
    console.log(`   callType: ${activeCallData.callType}`);
    console.log(`   backgroundMode: ${activeCallData.backgroundMode}`);
    
    // Mark that we're returning to call (not starting new call)
    navigatingToCall = true;
    
    // CRITICAL: Remove background mode flag so call page knows we're coming back
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    
    // Mark that we're returning to existing call
    sessionStorage.setItem('returningToBackgroundCall', 'true');
    
    // Save current chat state
    saveChatState(roomData.roomId, messagesCache);
    
    // Disconnect floating socket before navigating
    if (floatingCallSocket) {
      console.log('ðŸ”Œ Disconnecting floating socket (will reconnect on call page)');
      floatingCallSocket.disconnect();
      floatingCallSocket = null;
    }
    
    console.log('âœ… Navigating back to call page');
    window.location.href = '/call.html';
    
  } catch (e) {
    console.error('âŒ Failed to parse active call data:', e);
    toast('Failed to return to call', 'error');
  }
  
  console.log('ðŸ”™ ========================================\n');
}

function checkForBackgroundCall() {
  const hasBackgroundCall = sessionStorage.getItem('hasBackgroundCall') === 'true';
  const activeCallStr = localStorage.getItem('activeCall');
  
  console.log('ðŸ” Checking for background call...');
  console.log(`   hasBackgroundCall flag: ${hasBackgroundCall}`);
  console.log(`   activeCall in storage: ${!!activeCallStr}`);
  
  if (hasBackgroundCall && activeCallStr) {
    console.log('âœ… Background call detected - showing return button');
    
    const returnBtn = document.getElementById('floatingReturnToCall');
    if (returnBtn) {
      returnBtn.classList.remove('hidden');
      
      returnBtn.onclick = () => {
        console.log('ðŸ“ž Return to call clicked');
        sessionStorage.removeItem('hasBackgroundCall');
        window.location.href = '/call.html';
      };
      
      console.log('âœ… Return to call button activated');
    }
  } else {
    console.log('â„¹ï¸ No background call detected');
  }
}
  
  
  
function saveChatState(roomId, messages) {
  try {
    console.log('ðŸ’¾ ========================================');
    console.log('ðŸ’¾ SAVING CHAT STATE');
    console.log('ðŸ’¾ ========================================');
    console.log(`   Room: ${roomId}`);
    console.log(`   Messages: ${messages?.length || 0}`);
    
    // CRITICAL FIX: Validate input data
    if (!roomId) {
      console.error('âŒ Cannot save state: roomId missing');
      return;
    }
    
    if (!Array.isArray(messages)) {
      console.error('âŒ Cannot save state: messages not an array');
      return;
    }
    
    // Validate messages have required fields
    const validMessages = messages.filter(msg => {
      const isValid = msg.userId && msg.timestamp && (msg.message || msg.attachment);
      if (!isValid) {
        console.warn(`âš ï¸ Skipping invalid message in cache save:`, msg);
      }
      return isValid;
    });
    
    if (validMessages.length < messages.length) {
      console.warn(`âš ï¸ Filtered out ${messages.length - validMessages.length} invalid messages`);
    }
    
    // Determine call button state
    let callButtonState = 'none';
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomId;
    
    if (userInCall) {
      callButtonState = 'back';
    } else if (activeCallInRoom) {
      callButtonState = 'join';
    }
    
    const callInRoomToSave = activeCallInRoom || null;
    
    const state = {
      roomId,
      messages: validMessages, // Use validated messages
      timestamp: Date.now(),
      callButtonState,
      activeCallInRoom: callInRoomToSave,
      version: 2 // Add version for future migrations
    };
    
    // CRITICAL FIX: Use try-catch for localStorage quota errors
    try {
      localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(state));
      localStorage.setItem(CHAT_TIMESTAMP_KEY, Date.now().toString());
      
      console.log('âœ… Chat state saved successfully:');
      console.log(`   Valid messages: ${validMessages.length}`);
      console.log(`   Button state: ${callButtonState}`);
      console.log(`   Has active call: ${!!callInRoomToSave}`);
      console.log('ðŸ’¾ ========================================\n');
      
    } catch (storageError) {
      if (storageError.name === 'QuotaExceededError') {
        console.error('âŒ LocalStorage quota exceeded - attempting cleanup');
        
        // Emergency cleanup: keep only last 50 messages
        const trimmedMessages = validMessages.slice(-50);
        const trimmedState = { ...state, messages: trimmedMessages };
        
        try {
          localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(trimmedState));
          console.warn(`âš ï¸ Saved trimmed state (${trimmedMessages.length} messages)`);
        } catch (retryError) {
          console.error('âŒ Failed to save even trimmed state:', retryError);
          // Clear old state to free space
          localStorage.removeItem(CHAT_STATE_KEY);
          localStorage.removeItem(CHAT_MESSAGES_KEY);
        }
      } else {
        throw storageError; // Re-throw non-quota errors
      }
    }
    
  } catch (e) {
    console.error('âŒ ========================================');
    console.error('âŒ FAILED TO SAVE CHAT STATE');
    console.error('âŒ ========================================');
    console.error('   Error:', e.message);
    console.error('   Stack:', e.stack);
    console.error('âŒ ========================================\n');
  }
}
  
  function loadChatState() {
    try {
      const stateStr = localStorage.getItem(CHAT_STATE_KEY);
      if (!stateStr) return null;
      
      const state = JSON.parse(stateStr);
      console.log('âœ… Chat state loaded:', state.messages?.length || 0, 'messages');
      return state;
    } catch (e) {
      console.warn('âš ï¸ Failed to load chat state:', e);
      return null;
    }
  }
  
// Replace the existing clearChatState function with this version:
async function clearChatState(force = false) {
    console.log('ðŸ§¹ ========================================');
    console.log('ðŸ§¹ CLEARING CHAT STATE');
    console.log('ðŸ§¹ ========================================');
    console.log(`   Force: ${force}`);
    
    // Only clear if room is actually expiring/ended, or if forced
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    
    if (!force && activeCallStr) {
        console.log('âš ï¸ Active call exists - preserving chat state');
        console.log('ðŸ§¹ ========================================\n');
        return;
    }
    
    // CRITICAL: Delete all files for this room from IndexedDB
    if (roomData?.roomId) {
        try {
            console.log(`ðŸ—‘ï¸ Deleting all files for room: ${roomData.roomId}`);
            const deletedCount = await deleteRoomFiles(roomData.roomId);
            console.log(`âœ… Deleted ${deletedCount} file(s) from IndexedDB`);
        } catch (error) {
            console.error('âŒ Failed to delete room files:', error);
            // Continue with other cleanup even if file deletion fails
        }
    }
    
    // Clear localStorage
    localStorage.removeItem(CHAT_STATE_KEY);
    localStorage.removeItem(CHAT_MESSAGES_KEY);
    localStorage.removeItem(CHAT_TIMESTAMP_KEY);
    
    console.log('âœ… Chat state cleared');
    console.log('ðŸ§¹ ========================================\n');
}

  function clearAllChatData() {
    // CRITICAL: Clear ALL chat-related data on entry
    localStorage.removeItem(CHAT_STATE_KEY);
    localStorage.removeItem(CHAT_MESSAGES_KEY);
    localStorage.removeItem(CHAT_TIMESTAMP_KEY);
    // Don't clear currentRoom or activeCall - those are needed
    console.log('ðŸ§¹ All chat state cleared on entry');
  }
  
  function escapeHtml(text) {
    if (_Utils && typeof _Utils.escapeHtml === 'function') {
      return _Utils.escapeHtml(text);
    }
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function formatTimestamp(timestamp) {
    if (_Utils && typeof _Utils.formatDate === 'function') {
      return _Utils.formatDate(timestamp);
    }
    return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

function setInitialCallButtonState() {
    console.log('ðŸ” Checking for active call in localStorage...');
    
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    
    if (activeCallStr) {
        try {
            const activeCallData = JSON.parse(activeCallStr);
            
            if (activeCallData.roomId === roomData?.roomId) {
                console.log(`ðŸ“ž Active call found: ${activeCallData.callId} in room ${activeCallData.roomId}`);
                console.log(`âœ… User is IN the call - will show "Back to Call" button`);
                
                // Hide audio/video buttons
                if (audioCallBtn) {
                    audioCallBtn.classList.add('hidden');
                }
                if (videoCallBtn) {
                    videoCallBtn.classList.add('hidden');
                }
                
                // Show join button as "Back to Call" button
                if (joinCallBtn) {
                    joinCallBtn.classList.remove('hidden');
                    joinCallBtn.classList.add('flex');
                    joinCallBtn.disabled = false;
                    
                    // Update button text and icon
                    const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
                    const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
                    const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
                    
                    if (btnIcon) btnIcon.textContent = 'call';
                    if (btnTextLong) btnTextLong.textContent = 'Back to Call';
                    if (btnTextShort) btnTextShort.textContent = 'Back';
                    
                    // Change color to green
                    joinCallBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    joinCallBtn.classList.add('bg-primary', 'hover:bg-primary/90');
                    
                    console.log('âœ… "Back to Call" button configured');
                }
                
                return true;
            } else {
                console.log(`âŒ Room mismatch: ${activeCallData.roomId} !== ${roomData?.roomId}`);
            }
        } catch (e) {
            console.error('âŒ Failed to parse activeCall:', e);
            localStorage.removeItem(ACTIVE_CALL_KEY);
        }
    }
    
    // No active call - show normal buttons
    console.log('â„¹ï¸ No active call - showing audio/video buttons');
    if (audioCallBtn) {
        audioCallBtn.classList.remove('hidden');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('hidden');
        videoCallBtn.disabled = false;
    }
    if (joinCallBtn) {
        joinCallBtn.classList.add('hidden');
        joinCallBtn.classList.remove('flex');
    }
    
    return false;
}
  
function updateCallButtonState(isActive, callData = null) {
    console.log('ðŸ”„ Updating call button state:', { isActive, participantCount: callData?.participantCount });
    
    // Remove loading states and re-enable buttons
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.disabled = false;
    }
    if (joinCallBtn) {
        joinCallBtn.classList.remove('join-btn-loading');
    }
    
    // Check if user is already in the call
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomData?.roomId;
    
    if (userInCall) {
        console.log('ðŸ“ž User is IN call - showing "Back to Call" button');
        
        // Hide audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.add('hidden');
            audioCallBtn.disabled = true;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.add('hidden');
            videoCallBtn.disabled = true;
        }
        
        // Show "Back to Call" button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('hidden');
            joinCallBtn.classList.add('flex');
            joinCallBtn.disabled = false;
            
            // Update button text and icon
            const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
            const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
            const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
            
            if (btnIcon) btnIcon.textContent = 'call';
            if (btnTextLong) btnTextLong.textContent = 'Back to Call';
            if (btnTextShort) btnTextShort.textContent = 'Back';
            
            // Change to primary color (teal)
            joinCallBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            joinCallBtn.classList.add('bg-primary', 'hover:bg-primary/90');
            
            console.log('âœ… "Back to Call" button displayed');
        }
    } else if (isActive && callData) {
        console.log('ðŸ“ž Active call in room but user NOT in it - showing "Join Call" button');
        
        // Hide audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.add('hidden');
            audioCallBtn.disabled = true;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.add('hidden');
            videoCallBtn.disabled = true;
        }
        
        // Show "Join Call" button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('hidden');
            joinCallBtn.classList.add('flex');
            joinCallBtn.disabled = false;
            
            // Update button text and icon for join
            const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
            const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
            const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
            
            if (btnIcon) btnIcon.textContent = 'login';
            if (btnTextLong) btnTextLong.textContent = 'Join Call';
            if (btnTextShort) btnTextShort.textContent = 'Join';
            
            // Green color for join
            joinCallBtn.classList.remove('bg-primary', 'hover:bg-primary/90');
            joinCallBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            
            console.log(`âœ… "Join Call" button displayed (${callData.participantCount} participants)`);
        }
    } else {
        console.log('ðŸ“ž No active call - showing audio/video buttons');
        
        // Show audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.remove('hidden');
            audioCallBtn.disabled = false;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.remove('hidden');
            videoCallBtn.disabled = false;
        }
        
        // Hide join button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('flex');
            joinCallBtn.classList.add('hidden');
            joinCallBtn.disabled = true;
        }
        
        console.log('âœ… Audio/Video buttons displayed');
    }
}

  // ============================================
  // UI FUNCTIONS
  // ============================================
  
  function openSidebar() {
    if (!sidebar || !sidebarOverlay) return;
    sidebar.classList.add('show');
    sidebarOverlay.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  function closeSidebar() {
    if (!sidebar || !sidebarOverlay) return;
    sidebar.classList.remove('show');
    sidebarOverlay.classList.remove('active');
    document.body.style.overflow = '';
  }

  function toggleSidebar() {
    if (!sidebar) return;
    sidebar.classList.contains('show') ? closeSidebar() : openSidebar();
  }

  function setupUserCardClick() {
    if (window.innerWidth <= 768) {
      document.querySelectorAll('.user-card').forEach(card => {
        card.addEventListener('click', closeSidebar, { passive: true });
      });
    }
  }
  

  function createProfilePictureElement(pfpUrl, username, size = 'w-10 h-10') {
    const initial = username ? username.charAt(0).toUpperCase() : 'U';
    const container = document.createElement('div');
    container.className = `${size} rounded-full overflow-hidden bg-slate-100 border-2 border-white shadow-sm flex-shrink-0`;
    
    if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
      const img = document.createElement('img');
      img.src = pfpUrl;
      img.alt = username;
      img.className = 'h-full w-full object-cover';
      img.loading = 'lazy';
      img.onerror = function() {
        this.onerror = null;
        container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-sm">${initial}</div>`;
      };
      container.appendChild(img);
    } else {
      container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-sm">${initial}</div>`;
    }
    
    return container;
  }

  function showReplyPreview(messageData) {
    replyingTo = messageData;
    const replyPreview = document.getElementById('replyPreview');
    const replyToUsername = document.getElementById('replyToUsername');
    const replyToMessage = document.getElementById('replyToMessage');
    
    if (replyPreview && replyToUsername && replyToMessage) {
      replyToUsername.textContent = `Replying to ${messageData.username}`;
      replyToMessage.textContent = messageData.message;
      replyPreview.classList.remove('hidden');
      
      if (messageInput) messageInput.focus();
    }
  }

  function hideReplyPreview() {
    replyingTo = null;
    const replyPreview = document.getElementById('replyPreview');
    if (replyPreview) replyPreview.classList.add('hidden');
  }

function createMessageElement(data, isCurrentUser) {
    const messageItem = document.createElement('div');
    messageItem.className = `message-item flex gap-2 items-start ${isCurrentUser ? 'flex-row-reverse' : ''} animate-fade-in-up`;
    messageItem.dataset.messageId = data.messageId || `msg-${Date.now()}-${Math.random()}`;
    
    const pfpContainer = createProfilePictureElement(data.pfpUrl, data.username, 'w-8 h-8 sm:w-10 sm:h-10');
    const messageContent = document.createElement('div');
    messageContent.className = `flex flex-col ${isCurrentUser ? 'items-end' : 'items-start'} flex-1 min-w-0`;

    const headerDiv = document.createElement('div');
    headerDiv.className = `flex items-center gap-1.5 sm:gap-2 mb-1 px-1 ${isCurrentUser ? 'flex-row-reverse' : ''}`;
    
    const usernameSpan = document.createElement('span');
    usernameSpan.className = 'text-xs sm:text-sm font-semibold text-gray-200 truncate';
    usernameSpan.textContent = data.username || 'User';
    
    const timestampSpan = document.createElement('span');
    timestampSpan.className = 'text-[10px] sm:text-xs text-gray-500 whitespace-nowrap';
    timestampSpan.textContent = data.timestamp ? formatTimestamp(data.timestamp) : 'Just now';
    
    headerDiv.appendChild(usernameSpan);
    headerDiv.appendChild(timestampSpan);
    messageContent.appendChild(headerDiv);

    const bubbleWrapper = document.createElement('div');
    bubbleWrapper.className = `flex items-center gap-1`;

    const messageBubble = document.createElement('div');
    messageBubble.className = `px-3 sm:px-4 py-2 rounded-2xl ${isCurrentUser ? 'bg-[#33bfcc] text-white' : 'bg-[#2a2d33] text-gray-200'} break-words text-sm sm:text-base max-w-full`;

    if (data.replyTo) {
        const quotedDiv = document.createElement('div');
        quotedDiv.className = `quoted-message ${isCurrentUser ? '' : 'quoted-message-light'}`;
        
        const quotedUsername = document.createElement('div');
        quotedUsername.className = `text-xs font-semibold mb-1 ${isCurrentUser ? 'text-white/80' : 'text-[#33bfcc]'}`;
        quotedUsername.textContent = data.replyTo.username;
        
        const quotedText = document.createElement('div');
        quotedText.className = `text-xs ${isCurrentUser ? 'text-white/70' : 'text-gray-400'} break-words`;
        quotedText.textContent = data.replyTo.message;
        
        quotedDiv.appendChild(quotedUsername);
        quotedDiv.appendChild(quotedText);
        messageBubble.appendChild(quotedDiv);
    }

    // Add message text if present
    if (data.message) {
        const messageText = document.createElement('div');
        messageText.className = 'text-sm sm:text-base break-words';
        messageText.innerHTML = escapeHtml(data.message);
        messageBubble.appendChild(messageText);
    }

// Add attachment if present
if (data.attachment) {
  console.log(`ðŸ“Ž Rendering attachment in message: ${data.attachment.name} (${data.attachment.type})`);
  
  const attachmentDiv = document.createElement('div');
  attachmentDiv.className = 'message-attachment';
  
  const fileCategory = getFileTypeCategory(data.attachment.type);
  console.log(`   Category: ${fileCategory}`);
  
  if (fileCategory === 'image') {
    // Show image preview (will be loaded from IndexedDB)
    console.log(`   Creating image preview element`);
    attachmentDiv.innerHTML = `
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='300' height='200'%3E%3Crect width='300' height='200' fill='%23161b22'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%238b949e' font-family='sans-serif' font-size='14'%3ELoading image...%3C/text%3E%3C/svg%3E" 
           alt="${escapeHtml(data.attachment.name)}" 
           data-file-id="${data.attachment.fileId}"
           loading="lazy"
           style="max-width: 100%; border-radius: 8px;">
    `;
    
    // Load actual image from IndexedDB
    const imgElement = attachmentDiv.querySelector('img');
    loadImageAttachment(data.attachment.fileId, imgElement);
    
  } else if (fileCategory === 'video') {
    // Show video preview with play button
    console.log(`   Creating video file element (download on click)`);
    attachmentDiv.innerHTML = `
      <div class="message-attachment-file video" 
           data-file-id="${data.attachment.fileId}"
           style="cursor: pointer;">
        <span class="material-symbols-outlined" style="font-size: 28px; color: #a855f7;">play_circle</span>
        <div class="message-attachment-info">
          <div class="message-attachment-name">${escapeHtml(data.attachment.name)}</div>
          <div class="message-attachment-size">${formatFileSize(data.attachment.size)}</div>
          <div style="font-size: 0.7rem; opacity: 0.6; margin-top: 2px;">Click to open in video player</div>
        </div>
        <span class="material-symbols-outlined" style="font-size: 18px; opacity: 0.5;">download</span>
      </div>
    `;
    
    // Add click handler for download
    const fileElement = attachmentDiv.querySelector('.message-attachment-file');
    if (fileElement) {
      fileElement.addEventListener('click', () => {
        console.log(`ðŸŽ¬ Opening video: ${data.attachment.name}`);
        downloadAttachment(data.attachment.fileId, data.attachment.name);
      }, { passive: true });
    }
    
  } else if (fileCategory === 'pdf') {
    // Show PDF icon with viewer option
    console.log(`   Creating PDF file element`);
    attachmentDiv.innerHTML = `
      <div class="message-attachment-file pdf" 
           data-file-id="${data.attachment.fileId}"
           style="cursor: pointer;">
        <span class="material-symbols-outlined" style="font-size: 28px; color: #ef4444;">picture_as_pdf</span>
        <div class="message-attachment-info">
          <div class="message-attachment-name">${escapeHtml(data.attachment.name)}</div>
          <div class="message-attachment-size">${formatFileSize(data.attachment.size)}</div>
          <div style="font-size: 0.7rem; opacity: 0.6; margin-top: 2px;">Click to open in PDF reader</div>
        </div>
        <span class="material-symbols-outlined" style="font-size: 18px; opacity: 0.5;">download</span>
      </div>
    `;
    
    // Add click handler for download
    const fileElement = attachmentDiv.querySelector('.message-attachment-file');
    if (fileElement) {
      fileElement.addEventListener('click', () => {
        console.log(`ðŸ“„ Opening PDF: ${data.attachment.name}`);
        downloadAttachment(data.attachment.fileId, data.attachment.name);
      }, { passive: true });
    }
    
    
  } else {
    // Generic document
    console.log(`   Creating generic document element`);
    attachmentDiv.innerHTML = `
      <div class="message-attachment-file document" 
           data-file-id="${data.attachment.fileId}"
           style="cursor: pointer;">
        <span class="material-symbols-outlined" style="font-size: 28px;">description</span>
        <div class="message-attachment-info">
          <div class="message-attachment-name">${escapeHtml(data.attachment.name)}</div>
          <div class="message-attachment-size">${formatFileSize(data.attachment.size)}</div>
          <div style="font-size: 0.7rem; opacity: 0.6; margin-top: 2px;">Click to download</div>
        </div>
        <span class="material-symbols-outlined" style="font-size: 18px; opacity: 0.5;">download</span>
      </div>
    `;
    
    // Add click handler for download
    const fileElement = attachmentDiv.querySelector('.message-attachment-file');
    if (fileElement) {
      fileElement.addEventListener('click', () => {
        console.log(`ðŸ“ Downloading document: ${data.attachment.name}`);
        downloadAttachment(data.attachment.fileId, data.attachment.name);
      }, { passive: true });
    }
  }
  
  
  messageBubble.appendChild(attachmentDiv);
  console.log(`âœ… Attachment element added to message bubble`);
}

    const replyBtn = document.createElement('button');
    replyBtn.className = 'reply-btn p-1 sm:p-1.5 hover:bg-gray-800 rounded-full transition-colors flex-shrink-0';
    replyBtn.title = 'Reply';
    replyBtn.innerHTML = '<span class="material-symbols-outlined text-gray-500 text-base sm:text-lg">reply</span>';
    replyBtn.addEventListener('click', () => {
        showReplyPreview({
            messageId: messageItem.dataset.messageId,
            username: data.username,
            message: data.message || `[${data.attachment?.name}]`,
            userId: data.userId
        });
    }, { passive: true });

    if (isCurrentUser) {
        bubbleWrapper.appendChild(replyBtn);
        bubbleWrapper.appendChild(messageBubble);
    } else {
        bubbleWrapper.appendChild(messageBubble);
        bubbleWrapper.appendChild(replyBtn);
    }

    messageContent.appendChild(bubbleWrapper);
    messageItem.appendChild(pfpContainer);
    messageItem.appendChild(messageContent);
    
    return messageItem;
}


/**
 * Load image attachment from IndexedDB and display
 * Now includes retry mechanism and peer request fallback
 */
async function loadImageAttachment(fileId, imgElement) {
  if (!imgElement) {
    console.error('âŒ Image element not provided for fileId:', fileId);
    return;
  }
  
  console.log(`ðŸ–¼ï¸ Loading image attachment: ${fileId}`);
  
  try {
    let fileData = await getFileFromIndexedDB(fileId);
    
    // ============================================
    // CRITICAL FIX: If file not found locally, it may be loading
    // Wait briefly and retry before showing error
    // ============================================
    if (!fileData || !fileData.blob) {
      console.log(`â³ File not found, waiting 2s for peer transfer...`);
      
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Retry once
      fileData = await getFileFromIndexedDB(fileId);
      
      if (!fileData || !fileData.blob) {
        console.error(`âŒ File ${fileId} still not found after retry`);
        
        imgElement.alt = 'Loading...';
        imgElement.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="300" height="200"%3E%3Crect width="300" height="200" fill="%23161b22"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" fill="%238b949e" font-family="sans-serif" font-size="14"%3ERequesting file...%3C/text%3E%3C/svg%3E';
        
        return;
      }
    }
    
    console.log(`âœ… File data retrieved: ${fileData.name} (${(fileData.size / 1024).toFixed(2)} KB)`);
    
    const blobUrl = URL.createObjectURL(fileData.blob);
    console.log(`ðŸ”— Created blob URL for display`);
    
    imgElement.src = blobUrl;
    imgElement.alt = fileData.name;
    imgElement.dataset.blobUrl = blobUrl;
    
    imgElement.onload = () => {
      console.log(`âœ… Image loaded successfully: ${fileData.name}`);
    };
    
    imgElement.onerror = () => {
      console.error(`âŒ Failed to load image: ${fileData.name}`);
      URL.revokeObjectURL(blobUrl);
      imgElement.alt = 'Failed to load image';
    };
    
    imgElement.style.cursor = 'pointer';
    
    const newImg = imgElement.cloneNode(true);
    imgElement.parentNode?.replaceChild(newImg, imgElement);
    
    newImg.addEventListener('click', async () => {
      console.log(`ðŸ” Opening full-size image: ${fileData.name}`);
      
      try {
        const freshBlob = await getFileFromIndexedDB(fileId);
        if (!freshBlob || !freshBlob.blob) {
          toast('Failed to open image', 'error');
          return;
        }
        
        const freshBlobUrl = URL.createObjectURL(freshBlob.blob);
        const newWindow = window.open(freshBlobUrl, '_blank');
        
        console.log(`âœ… Opened image in new window`);
        
        if (newWindow) {
          newWindow.addEventListener('load', () => {
            setTimeout(() => {
              URL.revokeObjectURL(freshBlobUrl);
              console.log('ðŸ§¹ Revoked blob URL from new window');
            }, 1000);
          });
        } else {
          URL.revokeObjectURL(freshBlobUrl);
          toast('Please allow popups to view full image', 'warning');
        }
        
      } catch (error) {
        console.error('âŒ Failed to open full-size image:', error);
        toast('Failed to open image', 'error');
      }
    }, { passive: true });
    
  } catch (error) {
    console.error('âŒ Error loading image attachment:', error);
    imgElement.alt = 'Failed to load image';
    imgElement.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="300" height="200"%3E%3Crect width="300" height="200" fill="%23161b22"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" fill="%23ef4444" font-family="sans-serif" font-size="14"%3EError loading image%3C/text%3E%3C/svg%3E';
  }
}

/**
 * Download attachment file
 */
async function downloadAttachment(fileId, fileName) {
  console.log('ðŸ“¥ ========================================');
  console.log('ðŸ“¥ DOWNLOAD ATTACHMENT REQUESTED');
  console.log('ðŸ“¥ ========================================');
  console.log(`   FileID: ${fileId}`);
  console.log(`   Filename: ${fileName}`);
  
  try {
    const fileData = await getFileFromIndexedDB(fileId);
    
    if (!fileData || !fileData.blob) {
      console.error('âŒ File not found in IndexedDB');
      toast('File not found', 'error');
      console.log('ðŸ“¥ ========================================\n');
      return;
    }
    
    console.log(`âœ… File retrieved from IndexedDB`);
    console.log(`   Size: ${(fileData.size / 1024).toFixed(2)} KB`);
    console.log(`   Type: ${fileData.type}`);
    
    // Create download link
    const blobUrl = URL.createObjectURL(fileData.blob);
    const a = document.createElement('a');
    a.href = blobUrl;
    a.download = fileName;
    a.style.display = 'none';
    document.body.appendChild(a);
    
    console.log('ðŸ”½ Triggering download...');
    a.click();
    
    // Cleanup
    document.body.removeChild(a);
    setTimeout(() => {
      URL.revokeObjectURL(blobUrl);
      console.log('ðŸ§¹ Download blob URL revoked');
    }, 1000);
    
    toast(`Downloading ${fileName}`, 'success');
    console.log(`âœ… Download initiated successfully`);
    console.log('ðŸ“¥ ========================================\n');
    
  } catch (error) {
    console.error('âŒ Download error:', error);
    console.error('   Stack:', error.stack);
    toast('Download failed', 'error');
    console.log('ðŸ“¥ ========================================\n');
  }
}

  // ============================================
  // CONFIRMATION DIALOG
  // ============================================
  
function showConfirmationDialog() {
  return new Promise((resolve) => {
    const overlay = document.getElementById('confirmationOverlay');
    if (!overlay) return resolve(false);
    
    const dialogHTML = `
      <div class="confirmation-overlay" style="position: fixed; inset: 0; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(8px); display: flex; align-items: center; justify-content: center; z-index: 9999;">
        <div class="confirmation-dialog" style="background: linear-gradient(135deg, #0d1117 0%, #161b22 100%); border: 1px solid #30363d; border-radius: 16px; padding: 2rem; max-width: 400px; width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 1px rgba(6, 182, 212, 0.3);">
          <div style="text-align: center; margin-bottom: 1.5rem;">
            <div style="width: 64px; height: 64px; margin: 0 auto 1rem; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(220, 38, 38, 0.15) 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(239, 68, 68, 0.3);">
              <span class="material-symbols-outlined" style="font-size: 32px; color: #ef4444;">warning</span>
            </div>
            <h3 style="font-size: 1.35rem; font-weight: 700; margin-bottom: 0.75rem; color: #f0f6fc;">Leave Chat Room?</h3>
            <p style="color: #8b949e; font-size: 0.95rem; line-height: 1.6;">
              You're currently in an active chat room. If you leave, you'll be disconnected from the conversation.
            </p>
          </div>
          <div style="display: flex; gap: 0.75rem; justify-content: center;">
            <button class="btn-stay" id="btnStay" style="flex: 1; padding: 0.875rem 1.5rem; border-radius: 10px; font-weight: 600; font-size: 0.95rem; cursor: pointer; transition: all 0.2s; background-color: #1c2128; color: #c9d1d9; border: 1px solid #30363d;">Stay Here</button>
            <button class="btn-leave" id="btnLeave" style="flex: 1; padding: 0.875rem 1.5rem; border-radius: 10px; font-weight: 600; font-size: 0.95rem; cursor: pointer; transition: all 0.2s; background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%); color: white; border: 1px solid #f87171; box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);">Leave</button>
          </div>
        </div>
      </div>
    `;
    
    overlay.innerHTML = dialogHTML;
    overlay.style.display = 'flex';
    
    const btnStay = document.getElementById('btnStay');
    const btnLeave = document.getElementById('btnLeave');
    
    if (btnStay) {
      btnStay.addEventListener('mouseenter', () => {
        btnStay.style.backgroundColor = '#21262d';
        btnStay.style.borderColor = '#444c56';
      });
      btnStay.addEventListener('mouseleave', () => {
        btnStay.style.backgroundColor = '#1c2128';
        btnStay.style.borderColor = '#30363d';
      });
  btnStay.addEventListener('click', () => {
        console.log('âŒ User chose to stay');
        overlay.style.display = 'none';
        isAlertDialogVisible = false;
        saveAlertState(roomData?.roomId, false);
        resolve(false);
      }, { once: true });
    }
    
    if (btnLeave) {
      btnLeave.addEventListener('mouseenter', () => {
        btnLeave.style.background = 'linear-gradient(135deg, #ef4444 0%, #f87171 100%)';
        btnLeave.style.boxShadow = '0 0 25px rgba(239, 68, 68, 0.5)';
      });
      btnLeave.addEventListener('mouseleave', () => {
        btnLeave.style.background = 'linear-gradient(135deg, #dc2626 0%, #ef4444 100%)';
        btnLeave.style.boxShadow = '0 0 20px rgba(239, 68, 68, 0.3)';
      });
      btnLeave.addEventListener('click', () => {
        console.log('âœ… User chose to leave');
        overlay.style.display = 'none';
        isAlertDialogVisible = true;
        saveAlertState(roomData?.roomId, true);
        resolve(true);
      }, { once: true });
    }
  });
}


  // ============================================
  // BACK BUTTON HANDLER
  // ============================================
  
function setupBackButtonHandler() {
  console.log('ðŸ”§ ========================================');
  console.log('ðŸ”§ SETTING UP BACK BUTTON HANDLER');
  console.log('ðŸ”§ ========================================');
  
  let dialogOpen = false;
  let isLeaving = false;
  let historyGuardActive = true;
  
  // Push TWO states to create history guard
  history.pushState({ page: 'chat', guard: 1 }, '');
  history.pushState({ page: 'chat', guard: 2 }, '');
  console.log('âœ… History guard established');
  
  // Execute complete leave sequence
async function executeLeaveSequence() {
    if (isLeaving) {
      console.log('âš ï¸ Leave already in progress');
      return;
    }
    
    console.log('ðŸšª EXECUTING LEAVE SEQUENCE');
    isLeaving = true;
    backButtonHandled = true;
    historyGuardActive = false;
    
    try {
      stopCachedCallMonitoring();
      
      const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
      if (activeCallStr) {
        const callData = JSON.parse(activeCallStr);
        if (socketInstance?.connected) {
          socketInstance.emit('leave_call', { callId: callData.callId });
          await new Promise(resolve => setTimeout(resolve, 300));
        }
        localStorage.removeItem(ACTIVE_CALL_KEY);
        sessionStorage.removeItem('hasBackgroundCall');
        sessionStorage.removeItem('returningFromCall');
        sessionStorage.removeItem('backgroundCallMode');
        sessionStorage.removeItem('returningToBackgroundCall');
      }
      
      if (socketInstance?.connected) {
        socketInstance.emit('leave_room');
        await new Promise(resolve => setTimeout(resolve, 300));
      }
      
      // Clear room-specific state
      if (roomData?.roomId) {
        clearRoomState(roomData.roomId);
      }
      
      await clearChatState(true);
      
      window.location.href = '/mood.html';
      
    } catch (error) {
      console.error('âŒ Error during leave:', error);
      window.location.href = '/mood.html';
    }
  }
  
  // Popstate event handler
  window.addEventListener('popstate', async (event) => {
    console.log('â¬…ï¸ ========================================');
    console.log('â¬…ï¸ POPSTATE FIRED');
    console.log('â¬…ï¸ ========================================');
    console.log(`   Guard active: ${historyGuardActive}`);
    console.log(`   Dialog open: ${dialogOpen}`);
    console.log(`   Is leaving: ${isLeaving}`);
    
    if (isLeaving || !historyGuardActive) {
      console.log('   Guard inactive - allowing navigation');
      return;
    }
    
    // IMMEDIATELY re-push to cancel back navigation
    history.pushState({ page: 'chat', guard: Date.now() }, '');
    console.log('   âœ… Canceled back navigation');
    
    // SECOND BACK PRESS
    if (dialogOpen) {
      console.log('   ðŸ”´ SECOND BACK PRESS');
      const overlay = document.getElementById('confirmationOverlay');
      if (overlay) overlay.style.display = 'none';
      dialogOpen = false;
      console.log('â¬…ï¸ ========================================\n');
      await executeLeaveSequence();
      return;
    }
    
    // FIRST BACK PRESS
    console.log('   ðŸŸ¡ FIRST BACK PRESS');
    console.log('â¬…ï¸ ========================================\n');
    
    dialogOpen = true;
    const shouldLeave = await showConfirmationDialog();
    dialogOpen = false;
    
    console.log('ðŸ“‹ Dialog response:', shouldLeave ? 'LEAVE' : 'STAY');
    
    if (shouldLeave) {
      await executeLeaveSequence();
    }
  });
  
  console.log('âœ… Back button handler installed');
  console.log('ðŸ”§ ========================================\n');
}

  const updateTimer = () => {
    if (!serverExpiresAt) {
      console.warn('âš ï¸ No server expiresAt available');
      if (timeRemaining) {
        timeRemaining.textContent = '-- remaining';
      }
      return;
    }
    
    // CRITICAL: Always use server-adjusted time
    const clientNow = Date.now();
    const serverNow = clientNow + serverClockOffset;
    const remaining = Math.max(0, serverExpiresAt - serverNow);
    
    const minutes = Math.floor(remaining / 60000);
    const seconds = Math.floor((remaining % 60000) / 1000);
    
    if (timeRemaining) {
      timeRemaining.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} remaining`;
    }
    
    // Debug log every 10 seconds
    if (Math.floor(serverNow / 10000) !== Math.floor((serverNow - 1000) / 10000)) {
      console.log(`â° Timer: ${minutes}:${seconds.toString().padStart(2, '0')} (offset: ${(serverClockOffset/1000).toFixed(1)}s)`);
    }
    
    if (remaining === 0) {
      console.error('âŒ Room expired - redirecting');
      if (timerInterval) clearInterval(timerInterval);
      toast('Room has expired', 'warning');
      clearChatState(true);
      setTimeout(() => window.location.href = '/mood.html', 2000);
    }
  };

  // ============================================
  // SOCKET EVENT HANDLERS
  // ============================================
  
  function setupSocketHandlers() {
    if (!socketInstance) return;
    
    
    // ============================================
// CHUNKED FILE TRANSMISSION HANDLERS
// ============================================

socketInstance.on('file_chunk', async (data) => {
  try {
    await fileReceiver.handleChunk(data);
  } catch (error) {
    console.error('âŒ Error handling chunk:', error);
  }
});

socketInstance.on('file_transmission_complete', ({ fileId, fileName }) => {
  console.log(`âœ… File transmission complete: ${fileName} (${fileId})`);
  toast(`Received: ${fileName}`, 'success');
});

socketInstance.on('file_transmission_failed', ({ fileId, fileName, reason }) => {
  console.error(`âŒ File transmission failed: ${fileName}`);
  console.error(`   Reason: ${reason}`);
  
  fileReceiver.cleanup(fileId);
  toast(`Failed to receive: ${fileName}`, 'error');
});
    
    
    socketInstance.on('cached_call_valid', (data) => {
    console.log('âœ… Cached call validated by server:', data.callId);
    console.log(`   Showing modal for call from ${data.callerUsername}`);
    
    showCachedCallModal(data);
});

socketInstance.on('cached_call_invalid', (data) => {
    console.log('âŒ Cached call invalid:', data.callId);
    localStorage.removeItem(CACHED_CALL_KEY);
    console.log('ðŸ—‘ï¸ Cleared invalid cached call');
});
    
socketInstance.on('connect', () => {
  console.log('ðŸ”Œ ========================================');
  console.log('ðŸ”Œ SOCKET CONNECTED');
  console.log('ðŸ”Œ ========================================');
  console.log(`   Socket ID: ${socketInstance.id}`);
  console.log(`   User: ${currentUser?.username || 'unknown'}`);
  
  // CRITICAL: Reset auth state on new connection
  setAuthenticationState(false);
  
  firebase.auth().currentUser?.getIdToken().then(idToken => {
    console.log('ðŸ“¤ Sending authentication to server...');
    socketInstance.emit('authenticate', {
      token: idToken,
      userId: currentUser.userId
    });
  }).catch(err => {
    console.error('âŒ Failed to get token:', err);
    toast('Authentication failed. Please refresh.', 'error');
  });
  
  console.log('ðŸ”Œ ========================================\n');
});

socketInstance.on('connect_error', (error) => {
  console.error('âŒ Socket connection error:', error.message);
  setAuthenticationState(false);
  toast('Connection error. Retrying...', 'warning');
});

socketInstance.on('disconnect', (reason) => {
  console.log('ðŸ”Œ Socket disconnected:', reason);
  setAuthenticationState(false);
  
  if (reason === 'io server disconnect') {
    // Server disconnected us, need to reconnect manually
    socketInstance.connect();
  }
});

socketInstance.on('authenticated', async () => {
  console.log('âœ… ========================================');
  console.log('âœ… SOCKET AUTHENTICATED');
  console.log('âœ… ========================================');
  console.log(`   Socket ID: ${socketInstance.id}`);
  console.log(`   User: ${currentUser?.username} (${currentUser?.userId})`);
  
  // CRITICAL: Set authentication state FIRST
  setAuthenticationState(true);
  
  // Request room data from server for clock sync
  const roomStr = localStorage.getItem('currentRoom');
  if (roomStr) {
    try {
      const localRoomData = JSON.parse(roomStr);
      console.log('ðŸ“¦ Requesting fresh room data for clock sync...');
      
      socketInstance.emit('request_room_sync', { roomId: localRoomData.roomId });
      
    } catch (e) {
      console.error('âŒ Failed to parse room data:', e);
    }
  }
  
  startCachedCallMonitoring();
  socketInstance.emit('join_room', { roomId: roomData.roomId });
  
  console.log('âœ… ========================================\n');
});


socketInstance.on('call_created', (data) => {
  console.log('ðŸ“ž ========================================');
  console.log('ðŸ“ž CALL_CREATED EVENT RECEIVED');
  console.log('ðŸ“ž ========================================');
  console.log(`   callId: ${data.callId}`);
  console.log(`   callType: ${data.callType}`);
  console.log(`   isInitiator: ${data.isInitiator}`);
  
  // Only navigate if we're the initiator
  if (data.isInitiator) {
    console.log('âœ… We initiated this call - navigating to call page');
    
    // Mark that we're navigating to call
    navigatingToCall = true;
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading');
      audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading');
      videoCallBtn.disabled = false;
    }
    
    // Save chat state
    saveChatState(roomData.roomId, messagesCache);
    sessionStorage.setItem('returningFromCall', 'true');
    
    // Store call data
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
      callId: data.callId,
      roomId: roomData.roomId,
      callType: data.callType,
      users: data.participants || []
    }));
    
    console.log(`âœ… Stored call data, navigating to call.html`);
    console.log('ðŸ“ž ========================================\n');
    
    // Navigate to call page
    window.location.href = '/call.html';
  } else {
    console.log('â„¹ï¸ Call created by someone else - staying in chat, showing JOIN button');
    console.log('ðŸ“ž ========================================\n');
  }
});


socketInstance.on('room_joined', async (data) => {
  console.log('âœ… ========================================');
  console.log('âœ… ROOM_JOINED EVENT RECEIVED');
  console.log('âœ… ========================================');
  console.log(`   roomId: ${data.roomId}`);
  
  // [Keep existing clock sync code...]
  const clientNow = Date.now();
  
  if (data.serverTime) {
    serverClockOffset = data.serverTime - clientNow;
    console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
    console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
    console.log(`   â° CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);
    
    if (Math.abs(serverClockOffset) > 5000) {
      console.warn(`âš ï¸ WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
    }
  } else {
    console.warn('âš ï¸ No serverTime in room_joined, assuming no clock skew');
    serverClockOffset = 0;
  }
  
  if (data.expiresAt) {
    serverExpiresAt = data.expiresAt;
    
    const serverNow = clientNow + serverClockOffset;
    const timeRemaining = data.expiresAt - serverNow;
    
    console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
    console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
    console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);
    
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const localRoomData = JSON.parse(roomStr);
        localRoomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(localRoomData));
        console.log('âœ… Updated localStorage with server expiry time');
      } catch (e) {
        console.error('âŒ Failed to update localStorage:', e);
      }
    }
  } else {
    console.error('âŒ No expiresAt in room_joined data!');
  }
  
  const cachedState = loadChatState();
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  const isInIframe = window.parent && window.parent !== window;

  let shouldUseCache = false;

  if (activeCallStr && isInIframe) {
    try {
      const activeCall = JSON.parse(activeCallStr);
      const roomStr = localStorage.getItem('currentRoom');
      if (roomStr) {
        const room = JSON.parse(roomStr);
        if (activeCall.roomId === room.roomId && cachedState && cachedState.roomId === roomData.roomId) {
          shouldUseCache = true;
          console.log('ðŸ”„ Active call in iframe detected - will MERGE cache with server');
        }
      }
    } catch (e) {
      console.warn('Failed to check active call:', e);
    }
  }

  let mergedMessages = [];

  if (data.chatHistory?.length > 0) {
    console.log(`ðŸ“œ Server provided ${data.chatHistory.length} messages`);
    
    mergedMessages = [...data.chatHistory];
    
    if (shouldUseCache && cachedState?.messages?.length > 0) {
      console.log(`ðŸ“¦ Merging ${cachedState.messages.length} cached messages with server data`);
      
      const serverMessageIds = new Set(
        data.chatHistory.map(msg => msg.messageId || `${msg.userId}-${msg.timestamp}`)
      );
      
      const uniqueCachedMessages = cachedState.messages.filter(msg => {
        const msgId = msg.messageId || `${msg.userId}-${msg.timestamp}`;
        return !serverMessageIds.has(msgId);
      });
      
      if (uniqueCachedMessages.length > 0) {
        console.log(`âž• Adding ${uniqueCachedMessages.length} unique cached messages`);
        mergedMessages = [...mergedMessages, ...uniqueCachedMessages];
        mergedMessages.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
      }
    }
    
    // ============================================
    // CRITICAL FIX: REQUEST MISSING FILE DATA
    // ============================================
    console.log('ðŸ” Checking for attachments that need data...');
    
    for (const msg of mergedMessages) {
      if (msg.attachment && msg.attachment.fileId) {
        // Check if file exists in local IndexedDB
        try {
          const localFile = await getFileFromIndexedDB(msg.attachment.fileId);
          
          if (!localFile) {
            console.log(`ðŸ“‚ File ${msg.attachment.fileId} not in local storage`);
            
            // Only request if sent by someone else
            if (msg.userId !== currentUser.userId) {
              console.log(`ðŸ“¡ Requesting file data from peer for ${msg.attachment.name}`);
              
              // Request file from sender via socket
              socketInstance.emit('request_attachment_data', {
                fileId: msg.attachment.fileId,
                roomId: roomData.roomId
              });
            }
          } else {
            console.log(`âœ… File ${msg.attachment.name} already in local storage`);
          }
        } catch (e) {
          console.error(`âŒ Error checking file ${msg.attachment.fileId}:`, e);
        }
      }
    }
    
  } else if (shouldUseCache && cachedState?.messages?.length > 0) {
    console.log(`ðŸ“¦ No server history, using ${cachedState.messages.length} cached messages`);
    mergedMessages = [...cachedState.messages];
  } else {
    console.log('â„¹ï¸ No server history and no cache - starting fresh');
  }

  messagesCache = mergedMessages;

  console.log(`ðŸŽ¨ Rendering ${messagesCache.length} total messages`);
  messagesCache.forEach(msg => {
    const isCurrentUser = msg.userId === currentUser.userId;
    const msgEl = createMessageElement(msg, isCurrentUser);
    messagesList?.appendChild(msgEl);
  });

  if (messagesList && messagesCache.length > 0) {
    messagesList.scrollTop = messagesList.scrollHeight;
    console.log('âœ… Scrolled to latest message');
  }

  saveChatState(roomData.roomId, messagesCache);
  console.log(`ðŸ’¾ Saved ${messagesCache.length} messages to cache after merge`);
  
  // [Rest of room_joined handler...]
  if (shouldUseCache && cachedState) {
    console.log('ðŸ”„ Restoring call button state from cache:', cachedState.callButtonState);
    console.log('   Cached activeCallInRoom:', cachedState.activeCallInRoom);
    
    if (cachedState.activeCallInRoom) {
      activeCallInRoom = cachedState.activeCallInRoom;
      console.log('ðŸ’¾ Restored activeCallInRoom from cache:', activeCallInRoom);
    } else if (cachedState.callButtonState === 'back') {
      const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
      if (activeCallStr) {
        try {
          const activeCallData = JSON.parse(activeCallStr);
          activeCallInRoom = {
            callId: activeCallData.callId,
            callType: activeCallData.callType,
            participantCount: 2
          };
          console.log('ðŸ’¾ Reconstructed activeCallInRoom from ACTIVE_CALL_KEY:', activeCallInRoom);
        } catch (e) {
          console.error('Failed to reconstruct activeCallInRoom:', e);
        }
      }
    } else if (cachedState.callButtonState === 'join' && !activeCallInRoom) {
      console.warn('âš ï¸ Cache says "join" but no activeCallInRoom - will wait for server update');
    }
    
    if (cachedState.callButtonState === 'back') {
      updateCallButtonState(true, activeCallInRoom || { participantCount: 1 });
    } else if (cachedState.callButtonState === 'join' && activeCallInRoom) {
      updateCallButtonState(true, activeCallInRoom);
    } else {
      updateCallButtonState(false);
    }
    
    console.log('âœ… Call button state restored instantly');
  }
  
  if (data.activeCall) {
    console.log('ðŸ“ž Active call in room detected');
    
    activeCallInRoom = {
      callId: data.activeCall.callId,
      callType: data.activeCall.callType,
      participantCount: data.activeCall.participantCount
    };
    console.log('ðŸ’¾ Stored activeCallInRoom:', activeCallInRoom);
  } 
  
  // NEW CODE: Initialize users if not refresh or if user list is empty
  if (!isPageRefresh || roomUserList.size === 0) {
    console.log('ðŸ†• Initializing fresh user list from server');
    roomUserList.clear();
    if (Array.isArray(data.users)) {
      data.users.forEach(user => {
        addUserToRoom(user);
      });
    }
    renderUserList();
    saveUserList(roomData.roomId);
  } else {
    console.log('ðŸ”„ Using cached user list (refresh detected)');
  }
  
  // Mark as joined
  hasJoinedRoom = true;
  saveParticipationState(roomData.roomId, true);
  
  console.log('â° Starting timer updates with server-synced time...');
  updateTimer();
  
  console.log('âœ… ========================================\n');
});
  
  // Mark as joined
  hasJoinedRoom = true;
  saveParticipationState(roomData.roomId, true);
  
  console.log('â° Starting timer updates with server-synced time...');
  updateTimer();
  
  console.log('âœ… ========================================\n');
});



socketInstance.on('user_joined', (data) => {
  console.log('ðŸ‘¤ ========================================');
  console.log('ðŸ‘¤ USER_JOINED EVENT RECEIVED');
  console.log('ðŸ‘¤ ========================================');
  console.log(`   User: ${data.username} (${data.userId})`);
  console.log(`   Online count: ${data.onlineCount}`);
  console.log(`   Is refresh: ${isPageRefresh}`);
  console.log(`   Current user: ${currentUser?.userId}`);
  
  // CRITICAL: Don't process if this is the current user on page refresh
  if (isPageRefresh && data.userId === currentUser?.userId) {
    console.log('â„¹ï¸ Skipping user_joined for current user on refresh');
    console.log('ðŸ‘¤ ========================================\n');
    return;
  }
  
  // Add user to room (with automatic deduplication)
  const wasAdded = addUserToRoom({
    userId: data.userId,
    username: data.username,
    pfpUrl: data.pfpUrl
  });
  
  // Only show system message if user was actually added (not duplicate)
  if (wasAdded && data.userId !== currentUser?.userId) {
    const sysMsg = addSystemMessage('join', data.username, Date.now());
    renderSystemMessageInChat(sysMsg);
    saveSystemMessages(roomData?.roomId);
  }
  
  // Update UI
  renderUserList();
  saveUserList(roomData?.roomId);
  
  console.log('ðŸ‘¤ ========================================\n');
});


// ============================================
// PEER-TO-PEER FILE TRANSFER HANDLERS
// ============================================

socketInstance.on('send_attachment_to_peer', async ({ fileId, requesterId, requesterSocketId }) => {
  console.log('ðŸ“¤ ========================================');
  console.log('ðŸ“¤ PEER REQUESTING OUR FILE');
  console.log('ðŸ“¤ ========================================');
  console.log(`   FileID: ${fileId}`);
  console.log(`   Requester: ${requesterId}`);
  
  try {
    // Get file from our IndexedDB
    const fileData = await getFileFromIndexedDB(fileId);
    
    if (!fileData || !fileData.blob) {
      console.error(`âŒ File ${fileId} not found in our IndexedDB`);
      socketInstance.emit('attachment_data_response', {
        fileId,
        requesterId,
        requesterSocketId,
        data: null,
        metadata: null
      });
      return;
    }
    
    console.log(`âœ… File found: ${fileData.name} (${(fileData.size / 1024).toFixed(2)} KB)`);
    
    // Convert blob to base64
    const base64Data = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result.split(',')[1];
        resolve(base64);
      };
      reader.onerror = reject;
      reader.readAsDataURL(fileData.blob);
    });
    
    console.log(`âœ… Converted to base64: ${(base64Data.length / 1024).toFixed(2)} KB`);
    
    // Send to requester via server relay
    socketInstance.emit('attachment_data_response', {
      fileId,
      requesterId,
      requesterSocketId,
      data: base64Data,
      metadata: {
        name: fileData.name,
        type: fileData.type,
        size: fileData.size
      }
    });
    
    console.log(`ðŸ“¤ File data sent to requester`);
    console.log('ðŸ“¤ ========================================\n');
    
  } catch (error) {
    console.error('âŒ Error sending file to peer:', error);
    console.log('ðŸ“¤ ========================================\n');
  }
});

socketInstance.on('attachment_data_received', async ({ fileId, data, metadata }) => {
  console.log('ðŸ“¥ ========================================');
  console.log('ðŸ“¥ ATTACHMENT DATA RECEIVED FROM PEER');
  console.log('ðŸ“¥ ========================================');
  console.log(`   FileID: ${fileId}`);
  console.log(`   File: ${metadata?.name}`);
  console.log(`   Size: ${metadata?.size ? (metadata.size / 1024).toFixed(2) : 0} KB`);
  
  if (!data || !metadata) {
    console.error('âŒ Invalid data received');
    console.log('ðŸ“¥ ========================================\n');
    return;
  }
  
  try {
    // Convert base64 back to blob
    const byteCharacters = atob(data);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    const blob = new Blob([byteArray], { type: metadata.type });
    
    // Create File object
    const file = new File([blob], metadata.name, { type: metadata.type });
    
    // Store to our IndexedDB with SAME fileId
    await new Promise((resolve, reject) => {
      initFileDB().then(db => {
        const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(FILE_STORE_NAME);
        
        const fileRecord = {
          id: fileId, // Use same ID as sender
          roomId: roomData.roomId,
          messageId: null,
          name: metadata.name,
          type: metadata.type,
          size: metadata.size,
          blob: blob,
          timestamp: Date.now()
        };
        
        const request = store.add(fileRecord);
        
        request.onsuccess = () => {
          console.log(`âœ… File stored to local IndexedDB: ${fileId}`);
          resolve();
        };
        
        request.onerror = () => {
          console.error('âŒ Failed to store received file:', request.error);
          reject(request.error);
        };
      }).catch(reject);
    });
    
    // Find and update the image element if it's already rendered
    const imgElements = document.querySelectorAll(`img[data-file-id="${fileId}"]`);
    
    if (imgElements.length > 0) {
      console.log(`ðŸ–¼ï¸ Found ${imgElements.length} image element(s) to update`);
      
      imgElements.forEach(imgElement => {
        loadImageAttachment(fileId, imgElement);
      });
    } else {
      console.log('â„¹ï¸ No rendered elements found for this file (will load when message is rendered)');
    }
    
    console.log('âœ… File successfully received and stored');
    console.log('ðŸ“¥ ========================================\n');
    
  } catch (error) {
    console.error('âŒ Error processing received file:', error);
    console.log('ðŸ“¥ ========================================\n');
  }
});

socketInstance.on('attachment_data_unavailable', ({ fileId, reason }) => {
  console.warn('âš ï¸ ========================================');
  console.warn('âš ï¸ ATTACHMENT DATA UNAVAILABLE');
  console.warn('âš ï¸ ========================================');
  console.warn(`   FileID: ${fileId}`);
  console.warn(`   Reason: ${reason}`);
  
  // Update UI to show file unavailable
  const imgElements = document.querySelectorAll(`img[data-file-id="${fileId}"]`);
  
  imgElements.forEach(img => {
    img.alt = `File unavailable: ${reason}`;
    img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="300" height="200"%3E%3Crect width="300" height="200" fill="%23161b22"/%3E%3Ctext x="50%25" y="45%25" dominant-baseline="middle" text-anchor="middle" fill="%23ef4444" font-family="sans-serif" font-size="14"%3EFile unavailable%3C/text%3E%3Ctext x="50%25" y="60%25" dominant-baseline="middle" text-anchor="middle" fill="%238b949e" font-family="sans-serif" font-size="11"%3E' + encodeURIComponent(reason) + '%3C/text%3E%3C/svg%3E';
  });
  
  console.warn('âš ï¸ ========================================\n');
});

socketInstance.on('room_sync_data', (data) => {
  console.log('â° ========================================');
  console.log('â° ROOM SYNC DATA RECEIVED');
  console.log('â° ========================================');
  
  const clientNow = Date.now();
  
  if (!data.serverTime) {
    console.warn('âš ï¸ No serverTime in sync data, assuming no clock skew');
    data.serverTime = clientNow;
  }
  
  // Calculate clock offset
  serverClockOffset = data.serverTime - clientNow;
  
  console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
  console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
  console.log(`   â° CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);
  
  if (Math.abs(serverClockOffset) > 5000) {
    console.warn(`âš ï¸ WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
    console.warn(`   Timer will be adjusted to compensate`);
  }
  
  if (data.expiresAt) {
    serverExpiresAt = data.expiresAt;
    
    // Calculate time remaining using server-adjusted time
    const serverNow = clientNow + serverClockOffset;
    const timeRemaining = data.expiresAt - serverNow;
    
    console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
    console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
    console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);
    
    // Update localStorage with synced data
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const localRoomData = JSON.parse(roomStr);
        localRoomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(localRoomData));
        console.log('âœ… Updated localStorage with server expiry time');
      } catch (e) {
        console.error('âŒ Failed to update localStorage:', e);
      }
    }
  }
  
  console.log('â° ========================================\n');
  
  // Force timer update with new data
  updateTimer();
});

socketInstance.on('room_expiring_soon', (data) => {
  console.warn('âš ï¸ ========================================');
  console.warn('âš ï¸ ROOM EXPIRING SOON');
  console.warn('âš ï¸ ========================================');
  console.warn(`   Expires in: ${data.expiresIn / 1000} seconds`);
  console.warn(`   expiresAt: ${new Date(data.expiresAt).toISOString()}`);
  
  const clientNow = Date.now();
  const serverNow = clientNow + serverClockOffset;
  const remaining = data.expiresAt - serverNow;
  
  console.warn(`   Client now: ${new Date(clientNow).toISOString()}`);
  console.warn(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
  console.warn(`   Remaining (adjusted): ${(remaining / 1000).toFixed(1)}s`);
  console.warn('âš ï¸ ========================================\n');
  
  toast('Room expiring soon!', 'warning');
});

socketInstance.on('error', (data) => {
  console.error('âŒ ========================================');
  console.error('âŒ SOCKET ERROR EVENT');
  console.error('âŒ ========================================');
  console.error('   Error code:', data.code);
  console.error('   Error message:', data.message);
  console.error('   Timestamp:', new Date().toISOString());
  console.error('   isInitiatingCall:', isInitiatingCall);
  console.error('   isSocketAuthenticated:', isSocketAuthenticated);
  
  // CRITICAL: Always clear initiating state on any error
  const wasInitiating = isInitiatingCall;
  isInitiatingCall = false;
  
  // CRITICAL: Handle authentication errors with auto-recovery
  if (data.message === 'Not authenticated') {
    console.error('âŒ NOT AUTHENTICATED ERROR RECEIVED');
    console.error('   This indicates a race condition - call initiated before auth completed');
    console.error('   Current auth state:', isSocketAuthenticated);
    console.error('   Socket connected:', socketInstance?.connected);
    console.error('   User data exists:', !!currentUser);
    console.error('   Was initiating call:', wasInitiating);
    
    // Clear call loading states immediately
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
        console.error('   â° Cleared audio button timeout:', timeoutId);
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
        console.error('   â° Cleared video button timeout:', timeoutId);
      }
    }
    
    console.error('   ðŸ”’ Call loading states cleared');
    
    // Force re-authentication
    setAuthenticationState(false);
    
    // Attempt to recover
    if (socketInstance && socketInstance.connected && currentUser) {
      console.log('ðŸ”„ Attempting authentication recovery...');
      
      firebase.auth().currentUser?.getIdToken(true).then(idToken => {
        console.log('ðŸ“¤ Re-sending authentication with fresh token...');
        socketInstance.emit('authenticate', {
          token: idToken,
          userId: currentUser.userId
        });
        
        toast('Reconnecting...', 'info');
        
        // Set recovery timeout
        const recoveryTimeout = setTimeout(() => {
          if (!isSocketAuthenticated) {
            console.error('âŒ Recovery timeout - authentication failed after 10s');
            toast('Authentication failed. Please refresh the page.', 'error');
          } else {
            console.log('âœ… Authentication recovered successfully');
            
            // If user was trying to initiate a call, show helpful message
            if (wasInitiating) {
              toast('Connected! You can now start a call.', 'success');
            }
          }
        }, 10000);
        
        console.log('â° Recovery timeout set:', recoveryTimeout);
        
      }).catch(err => {
        console.error('âŒ Recovery authentication failed:', err);
        toast('Authentication failed. Please refresh the page.', 'error');
      });
    } else {
      console.error('âŒ Cannot recover - missing socket or user data');
      console.error('   Socket exists:', !!socketInstance);
      console.error('   Socket connected:', socketInstance?.connected);
      console.error('   Current user:', !!currentUser);
      toast('Connection lost. Please refresh the page.', 'error');
    }
    
    console.error('âŒ ========================================\n');
    return;
  }
  
  // CRITICAL FIX: Handle CALL_ALREADY_ACTIVE error - auto-join instead
  if (data.code === 'CALL_ALREADY_ACTIVE') {
    console.log('ðŸ”„ ========================================');
    console.log('ðŸ”„ CALL_ALREADY_ACTIVE ERROR HANDLING');
    console.log('ðŸ”„ ========================================');
    console.log(`   Existing callId: ${data.callId}`);
    console.log(`   callType: ${data.callType}`);
    console.log(`   participantCount: ${data.participantCount}`);
    console.log(`   Was initiating: ${wasInitiating}`);
    
    // Clear loading states from call initiation
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
        console.log('   â° Cleared audio button timeout');
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
        console.log('   â° Cleared video button timeout');
      }
    }
    
    // Re-enable buttons if authenticated
    if (isSocketAuthenticated) {
      console.log('   âœ… Re-enabling call buttons (authenticated)');
      enableCallButtons();
    } else {
      console.log('   â³ Keeping buttons disabled (not authenticated)');
    }
    
    // Store the active call info
    activeCallInRoom = {
      callId: data.callId,
      callType: data.callType || 'audio',
      participantCount: data.participantCount || 1
    };
    console.log('ðŸ’¾ Stored activeCallInRoom:', activeCallInRoom);
    
    // Update UI to show join button
    updateCallButtonState(true, activeCallInRoom);
    
    // Show friendly message
    toast('A call is already active. Click "Join Call" to join.', 'success');
    console.log('ðŸ”„ ========================================\n');
    return;
  }
  
  // Handle room-related errors
  if (data.code === 'ROOM_NOT_FOUND' || data.code === 'NOT_IN_ROOM') {
    console.error('âŒ ROOM ERROR:', data.code);
    console.error('   Message:', data.message);
    console.error('   Current room:', roomData?.roomId);
    console.error('   Was initiating:', wasInitiating);
    
    toast('Room no longer available', 'error');
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
      }
    }
    
    // Clear all storage
    clearChatState(true);
    localStorage.removeItem(ACTIVE_CALL_KEY);
    sessionStorage.removeItem('hasBackgroundCall');
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    sessionStorage.removeItem('returningToBackgroundCall');
    
    console.error('ðŸ—‘ï¸ Cleared all storage due to room error');
    
    // Navigate and cleanup parent if in iframe
    setTimeout(() => {
      console.error('ðŸ”„ Navigating to mood.html after room error');
      // cleanupParentCallPage();
    }, 2000);
    
    console.error('âŒ ========================================\n');
    return;
  }
  
  // Handle room expiry errors
  if (data.code === 'ROOM_EXPIRED') {
    console.error('ðŸ’¥ ROOM EXPIRED ERROR');
    console.error('   Message:', data.message);
    console.error('   Room:', roomData?.roomId);
    console.error('   Was initiating:', wasInitiating);
    
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    
    toast('Room has expired', 'warning');
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
      }
    }
    
    // Clear all storage
    clearChatState(true);
    localStorage.removeItem(ACTIVE_CALL_KEY);
    sessionStorage.removeItem('hasBackgroundCall');
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    sessionStorage.removeItem('returningToBackgroundCall');
    
    console.error('ðŸ—‘ï¸ Cleared all storage due to room expiry');
    
    setTimeout(() => {
      console.error('ðŸ”„ Navigating to mood.html after room expiry');
      // cleanupParentCallPage();
    }, 2000);
    
    console.error('âŒ ========================================\n');
    return;
  }
  
  // Handle call-related errors
  if (data.code === 'CALL_NOT_FOUND' || data.code === 'CALL_ENDED') {
    console.error('âŒ CALL ERROR:', data.code);
    console.error('   Message:', data.message);
    console.error('   Was initiating:', wasInitiating);
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
      }
    }
    if (joinCallBtn) {
      joinCallBtn.classList.remove('join-btn-loading');
      joinCallBtn.disabled = false;
    }
    
    // Re-enable buttons if authenticated
    if (isSocketAuthenticated) {
      console.log('   âœ… Re-enabling call buttons');
      enableCallButtons();
    }
    
    // Clear active call state
    activeCallInRoom = null;
    updateCallButtonState(false);
    
    toast(data.message || 'Call is no longer available', 'warning');
    console.error('âŒ ========================================\n');
    return;
  }
  
  // Handle join call failures
  if (data.code === 'JOIN_FAILED' || data.code === 'PARTICIPANT_RESOLUTION_FAILED' || data.code === 'STATE_MISMATCH') {
    console.error('âŒ JOIN CALL ERROR:', data.code);
    console.error('   Message:', data.message);
    
    // Clear join button loading state
    if (joinCallBtn) {
      joinCallBtn.classList.remove('join-btn-loading');
      joinCallBtn.disabled = false;
    }
    if (acceptCallBtn) {
      acceptCallBtn.classList.remove('join-btn-loading');
      acceptCallBtn.disabled = false;
    }
    
    toast(data.message || 'Failed to join call. Please try again.', 'error');
    console.error('âŒ ========================================\n');
    return;
  }
  
  // Generic error handling
  console.error('âŒ GENERIC ERROR');
  console.error('   Code:', data.code || 'UNKNOWN');
  console.error('   Message:', data.message || 'An error occurred');
  console.error('   Was initiating:', wasInitiating);
  
  // Clear any loading states on generic errors
  if (audioCallBtn) {
    audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
    const timeoutId = audioCallBtn.dataset.timeoutId;
    if (timeoutId) {
      clearTimeout(parseInt(timeoutId));
      delete audioCallBtn.dataset.timeoutId;
    }
  }
  if (videoCallBtn) {
    videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
    const timeoutId = videoCallBtn.dataset.timeoutId;
    if (timeoutId) {
      clearTimeout(parseInt(timeoutId));
      delete videoCallBtn.dataset.timeoutId;
    }
  }
  if (joinCallBtn) {
    joinCallBtn.classList.remove('join-btn-loading');
    joinCallBtn.disabled = false;
  }
  
  // Re-enable buttons if authenticated
  if (isSocketAuthenticated) {
    console.log('   âœ… Re-enabling call buttons');
    enableCallButtons();
  } else {
    console.log('   â³ Not authenticated - buttons will enable after auth completes');
  }
  
  toast(data.message || 'An error occurred', 'error');
  console.error('âŒ ========================================\n');
});

   socketInstance.on('chat_message', async (data) => {
  console.log('ðŸ’¬ ========================================');
  console.log('ðŸ’¬ INCOMING CHAT MESSAGE FROM SERVER');
  console.log('ðŸ’¬ ========================================');
  console.log(`   From: ${data.username} (${data.userId})`);
  console.log(`   MessageID: ${data.messageId}`);
  console.log(`   Has attachment: ${!!data.attachment}`);
  console.log(`   Attachment chunked: ${data.attachment?.chunked || false}`);
  
  const isOwnMessage = data.userId === currentUser.userId;
  console.log(`   Is own message: ${isOwnMessage}`);
  
  // ============================================
  // DEDUPLICATION - Check server messages only
  // ============================================
  if (isOwnMessage) {
    const optimisticIndex = messagesCache.findIndex(m => 
      m._localOnly && 
      m.userId === data.userId && 
      Math.abs((m.timestamp || 0) - (data.timestamp || 0)) < 2000
    );
    
    if (optimisticIndex !== -1) {
      console.log('ðŸ”„ Replacing optimistic message with server version');
      
      const optimisticMsg = messagesCache[optimisticIndex];
      messagesCache.splice(optimisticIndex, 1);
      
      const msgElements = messagesList?.querySelectorAll('.message-item');
      if (msgElements) {
        msgElements.forEach(el => {
          if (el.dataset.messageId === optimisticMsg.messageId) {
            el.remove();
            console.log('âœ… Removed optimistic message from DOM');
          }
        });
      }
    }
  }
  
  const isDuplicate = messagesCache.some(cached => {
    if (cached._localOnly) return false;
    
    if (cached.messageId && data.messageId && cached.messageId === data.messageId) {
      return true;
    }
    
    if (cached.userId === data.userId && 
        Math.abs((cached.timestamp || 0) - (data.timestamp || 0)) < 100) {
      return true;
    }
    
    return false;
  });
  
  if (isDuplicate) {
    console.warn(`âš ï¸ DUPLICATE MESSAGE DETECTED - SKIPPING`);
    console.log('ðŸ’¬ ========================================\n');
    return;
  }
  
  console.log(`âœ… New message validated - will render`);
  
  // ============================================
  // ATTACHMENT HANDLING - CHUNKED OR LEGACY
  // ============================================
  if (data.attachment) {
    console.log('ðŸ“Ž Message contains attachment');
    console.log(`   Chunked: ${data.attachment.chunked || false}`);
    
    if (data.attachment.chunked) {
      // CHUNKED: File will arrive via file_chunk events
      console.log('ðŸ“¦ Chunked attachment - file will be received separately');
      console.log(`   FileID: ${data.attachment.fileId}`);
      console.log(`   Total chunks: ${data.attachment.totalChunks}`);
      
      // Message will be rendered with placeholder
      // File will load when chunks complete
      
    } else if (data.userId !== currentUser.userId && data.attachment.data) {
      // LEGACY: Single base64 payload (for backward compatibility)
      console.log('ðŸ“¦ Legacy attachment format detected');
      
      try {
        const byteCharacters = atob(data.attachment.data);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], { type: data.attachment.type });
        
        const file = new File([blob], data.attachment.name, { type: data.attachment.type });
        const storedFileId = await storeFileToIndexedDB(file, roomData.roomId, data.messageId);
        
        data.attachment.fileId = storedFileId;
        delete data.attachment.data;
        console.log(`âœ… Legacy attachment stored: ${storedFileId}`);
        
      } catch (error) {
        console.error('âŒ Failed to store legacy attachment:', error);
      }
    } else if (data.userId === currentUser.userId) {
      console.log('â„¹ï¸ Own message - file already in IndexedDB');
      delete data.attachment.data;
    }
  }
  
  // ============================================
  // RENDER MESSAGE
  // ============================================
  console.log(`ðŸŽ¨ Rendering message`);
  const msgEl = createMessageElement(data, isOwnMessage);
  
  if (messagesList) {
    messagesList.appendChild(msgEl);
    messagesList.scrollTop = messagesList.scrollHeight;
    console.log(`âœ… Message rendered in UI`);
  }
  
  // ============================================
  // UPDATE CACHE AND SAVE
  // ============================================
  messagesCache.push(data);
  console.log(`âž• Added to cache (new size: ${messagesCache.length})`);
  
  saveChatState(roomData.roomId, messagesCache);
  console.log(`ðŸ’¾ Chat state saved`);
  
  console.log('ðŸ’¬ ========================================\n');
});

    socketInstance.on('user_left', (data) => {
  console.log('ðŸ‘‹ ========================================');
  console.log('ðŸ‘‹ USER_LEFT EVENT RECEIVED');
  console.log('ðŸ‘‹ ========================================');
  console.log(`   User: ${data.username} (${data.userId})`);
  
  // Remove user from room
  const wasRemoved = removeUserFromRoom(data.userId);
  
  // Only show system message if user was actually removed
  if (wasRemoved) {
    const sysMsg = addSystemMessage('leave', data.username, Date.now());
    renderSystemMessageInChat(sysMsg);
    saveSystemMessages(roomData?.roomId);
  }
  
  // Update UI
  renderUserList();
  saveUserList(roomData?.roomId);
  
  if (onlineCount && data.remainingUsers !== undefined) {
    onlineCount.textContent = `${data.remainingUsers} Online`;
  }
  
  if (data.remainingUsers <= 1) {
    toast('Room closing...', 'warning');
    if (roomData?.roomId) {
      clearRoomState(roomData.roomId);
    }
    clearChatState(true);
    setTimeout(() => window.location.href = '/mood.html', 2000);
  }
  
  console.log('ðŸ‘‹ ========================================\n');
});

socketInstance.on('left_room', (data) => {
  console.log('ðŸ‘‹ Received left_room confirmation from server');
  toast('Left room', 'success');
  
  // CRITICAL: Don't clear storage here - already done in leave button handler
  // Just disconnect socket
  if (socketInstance) {
    socketInstance.disconnect();
  }
  
  console.log('âœ… Socket disconnected after leaving room');
});

socketInstance.on('incoming_call', (data) => {
  console.log('ðŸ“ž ========================================');
  console.log('ðŸ“ž INCOMING_CALL EVENT RECEIVED');
  console.log('ðŸ“ž ========================================');
  console.log(`   Caller: ${data.callerUsername}`);
  console.log(`   Call ID: ${data.callId}`);
  console.log(`   Type: ${data.callType}`);
  
  // CRITICAL: Cache the call immediately
  const cachedCall = {
    callId: data.callId,
    callerUsername: data.callerUsername,
    callerPfp: data.callerPfp,
    callType: data.callType,
    roomId: data.roomId,
    timestamp: Date.now()
  };
  
  try {
    localStorage.setItem(CACHED_CALL_KEY, JSON.stringify(cachedCall));
    console.log('ðŸ’¾ Call cached to localStorage');
  } catch (e) {
    console.error('âŒ Failed to cache call:', e);
  }

  // Set pending call data
  pendingCallData = data;
  
  // Update modal UI
  const callerName = document.getElementById('callerName');
  const callType = document.getElementById('callType');
  const callerAvatar = document.getElementById('callerAvatar');
  
  if (callerName) callerName.textContent = `${data.callerUsername} is calling`;
  if (callType) callType.textContent = data.callType === 'video' ? 'Video Call' : 'Audio Call';
  if (callerAvatar) {
    callerAvatar.innerHTML = '';
    const pfp = createProfilePictureElement(data.callerPfp, data.callerUsername, 'w-full h-full');
    callerAvatar.appendChild(pfp);
  }
  
  // Show modal after 2 second delay
  setTimeout(() => {
    if (pendingCallData && pendingCallData.callId === data.callId) {
      incomingCallModal?.classList.remove('hidden');
      console.log(`âœ… Showing incoming call modal after 2s delay`);
    } else {
      console.log(`ðŸ“ž Call already handled, skipping modal display`);
    }
  }, 2000);
  
  console.log('ðŸ“ž ========================================\n');
});

    socketInstance.on('call_accepted', (data) => {
    console.log('âœ… Call accepted:', data);
    
    // Clear loading states
    isInitiatingCall = false;
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.classList.remove('calling');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.classList.remove('calling');
        videoCallBtn.disabled = false;
    }
    
    navigatingToCall = true;
    
    saveChatState(roomData.roomId, messagesCache);
    sessionStorage.setItem('returningFromCall', 'true');
    
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
        callId: data.callId,
        roomId: roomData.roomId,
        callType: data.callType,
        users: data.users
    }));
    
    console.log('ðŸš€ Navigating to call');
    window.location.href = '/call.html';
});

socketInstance.on('call_declined', (data) => {
    console.log('âŒ Call was declined');
    
    // Clear loading states
    toast('Call was declined', 'warning');
    isInitiatingCall = false;
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.classList.remove('calling');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.classList.remove('calling');
        videoCallBtn.disabled = false;
    }
});

    socketInstance.on('call_declined', (data) => {
      toast('Call was declined', 'warning');
      isInitiatingCall = false;
      audioCallBtn?.classList.remove('calling');
      videoCallBtn?.classList.remove('calling');
    });
    
    socketInstance.on('call_state_update', (data) => {
  console.log('ðŸ“ž Call state update:', data);
  
  if (data.isActive && data.participantCount > 0) {
    // CRITICAL FIX: Store call data so JOIN button can access it
    activeCallInRoom = {
      callId: data.callId,
      callType: data.callType,
      participantCount: data.participantCount
    };
    console.log(`ðŸ“ž Stored active call: ${data.callId} with ${data.participantCount} participants`);
    
    updateCallButtonState(true, data);
  } else {
    // CRITICAL FIX: Clear call data when call ends
    activeCallInRoom = null;
    console.log('ðŸ“ž Cleared active call - no participants');
    
    updateCallButtonState(false);
  }
});


    socketInstance.on('call_ended_notification', (data) => {
      console.log('ðŸ“ž Call ended:', data.callId);
      updateCallButtonState(false);
    });

socketInstance.on('join_existing_call_success', (data) => {
  console.log('âœ… ========================================');
  console.log('âœ… JOIN_EXISTING_CALL_SUCCESS');
  console.log('âœ… ========================================');
  console.log(`   callId: ${data.callId}`);
  console.log(`   callType: ${data.callType}`);
  console.log(`   roomId: ${data.roomId}`);
  
  // Remove loading states
  if (joinCallBtn) {
    joinCallBtn.classList.remove('join-btn-loading');
    joinCallBtn.disabled = false;
  }
  if (acceptCallBtn) {
    acceptCallBtn.classList.remove('join-btn-loading');
    acceptCallBtn.disabled = false;
  }
  
  // Mark navigating
  navigatingToCall = true;
  
  // Save chat state (if not already saved)
  saveChatState(roomData.roomId, messagesCache);
  sessionStorage.setItem('returningFromCall', 'true');
  
  // Ensure call data is stored (should already be, but verify)
  const storedCall = localStorage.getItem(ACTIVE_CALL_KEY);
  console.log(`   Stored call data exists: ${!!storedCall}`);
  
  if (!storedCall) {
    console.warn('âš ï¸ No stored call data - storing now');
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
      callId: data.callId,
      roomId: data.roomId,
      callType: data.callType,
      users: []
    }));
  }
  
  console.log('ðŸš€ Navigating to call page in 500ms...');
  console.log('âœ… ========================================\n');
  
  // Navigate to call with small delay to ensure storage is written
  setTimeout(() => {
    window.location.href = '/call.html';
  }, 500);
});
  }

  // ============================================
  // EVENT LISTENERS
  // ============================================
  
  function setupEventListeners() {
    // Sidebar
    sidebarToggle?.addEventListener('click', toggleSidebar, { passive: true });
    sidebarClose?.addEventListener('click', closeSidebar, { passive: true });
    sidebarOverlay?.addEventListener('click', closeSidebar, { passive: true });
    
    // Reply
    cancelReplyBtn?.addEventListener('click', hideReplyPreview, { passive: true });
    
    
    
    
const attachmentBtn = document.querySelector('.attachment-btn');
if (attachmentBtn) {
  attachmentBtn.addEventListener('click', async () => {
    console.log('ðŸ“Ž ========================================');
    console.log('ðŸ“Ž ATTACHMENT BUTTON CLICKED');
    console.log('ðŸ“Ž ========================================');
    
    // Create file input dynamically (ensures fresh state)
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = Object.keys(SUPPORTED_FILE_TYPES).join(',') + ',' + 
                       Object.values(SUPPORTED_FILE_TYPES).flatMap(t => t.ext).join(',');
    fileInput.style.display = 'none';
    
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) {
        console.log('â„¹ï¸ No file selected');
        console.log('ðŸ“Ž ========================================\n');
        return;
      }
      
      console.log(`ðŸ“„ File selected: ${file.name}`);
      console.log(`   Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
      console.log(`   Type: ${file.type}`);
      
      // Validate file
      const validation = validateFile(file);
      if (!validation.valid) {
        toast(validation.error, 'error');
        console.log('ðŸ“Ž ========================================\n');
        return;
      }
      
      try {
        // Show loading indicator
        attachmentBtn.disabled = true;
        attachmentBtn.classList.add('opacity-50', 'cursor-not-allowed');
        const originalIcon = attachmentBtn.innerHTML;
        attachmentBtn.innerHTML = '<span class="material-symbols-outlined text-xl animate-spin">progress_activity</span>';
        
        // Store file to IndexedDB (disk-backed, not RAM)
        const fileId = await storeFileToIndexedDB(file, roomData.roomId, null);
        
        console.log(`âœ… File stored successfully: ${fileId}`);
        
        // Get file back from IndexedDB to show preview
        const storedFile = await getFileFromIndexedDB(fileId);
        if (storedFile) {
          await showAttachmentPreview(
            fileId,
            storedFile.name,
            storedFile.type,
            storedFile.size,
            storedFile.blob
          );
          toast(`File attached`, 'success');
        }
        
        // Restore button state
        attachmentBtn.disabled = false;
        attachmentBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        attachmentBtn.innerHTML = originalIcon;
        
      } catch (error) {
        console.error('âŒ Failed to store file:', error);
        toast('Failed to attach file. Please try again.', 'error');
        
        // Restore button state
        attachmentBtn.disabled = false;
        attachmentBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        attachmentBtn.innerHTML = originalIcon;
      }
      
      console.log('ðŸ“Ž ========================================\n');
      
      // Clean up file input
      document.body.removeChild(fileInput);
    }, { once: true });
    
    // Trigger file picker
    document.body.appendChild(fileInput);
    fileInput.click();
    
  }, { passive: true });
}
    
    
    // Remove attachment button
const removeAttachmentBtn = document.getElementById('removeAttachment');
if (removeAttachmentBtn) {
  removeAttachmentBtn.addEventListener('click', async () => {
    console.log('ðŸ—‘ï¸ Remove attachment clicked');
    
    if (pendingAttachment) {
      try {
        // Delete from IndexedDB
        await deleteFileFromIndexedDB(pendingAttachment.fileId);
        console.log(`âœ… Deleted file: ${pendingAttachment.fileId}`);
        
        // Hide preview
        hideAttachmentPreview();
        
        toast('Attachment removed', 'success');
      } catch (error) {
        console.error('âŒ Failed to remove attachment:', error);
        toast('Failed to remove attachment', 'error');
      }
    }
  }, { passive: true });
}
    
    
if (audioCallBtn) {
  audioCallBtn.addEventListener('click', async () => {
    console.log('ðŸ“ž ========================================');
    console.log('ðŸ“ž AUDIO CALL BUTTON CLICKED');
    console.log('ðŸ“ž ========================================');
    console.log(`   Authentication state: ${isSocketAuthenticated}`);
    console.log(`   Socket connected: ${socketInstance?.connected}`);
    console.log(`   Already initiating: ${isInitiatingCall}`);
    
    // CRITICAL: Block if already initiating
    if (isInitiatingCall) {
      console.log('âš ï¸ Call already being initiated, ignoring click');
      console.log('ðŸ“ž ========================================\n');
      return;
    }
    
    // CRITICAL: Wait for authentication if not ready
    if (!isSocketAuthenticated) {
      console.log('â³ Not authenticated yet - waiting...');
      audioCallBtn.disabled = true;
      audioCallBtn.classList.add('animate-pulse');
      
      try {
        await waitForAuthentication();
        console.log('âœ… Authentication complete, proceeding with call');
      } catch (e) {
        console.error('âŒ Authentication wait failed:', e);
        toast('Connection failed. Please refresh.', 'error');
        audioCallBtn.disabled = false;
        audioCallBtn.classList.remove('animate-pulse');
        console.log('ðŸ“ž ========================================\n');
        return;
      }
    }
    
    // CRITICAL: Verify socket still connected
    if (!socketInstance || !socketInstance.connected) {
      console.error('âŒ Socket disconnected during call initiation');
      toast('Connection lost. Please refresh.', 'error');
      console.log('ðŸ“ž ========================================\n');
      return;
    }
    
    console.log('âœ… All checks passed - initiating audio call');
    isInitiatingCall = true;
    
    // Add loading state
    audioCallBtn.classList.add('call-btn-loading');
    audioCallBtn.disabled = true;
    if (videoCallBtn) {
      videoCallBtn.classList.add('calling');
      videoCallBtn.disabled = true;
    }
    
    socketInstance.emit('initiate_call', {
      roomId: roomData.roomId,
      callType: 'audio'
    });
    
    console.log('ðŸ“¤ Audio call initiation sent to server');
    toast('Calling...', 'success');
    
    // Timeout after 30 seconds with recovery
    const timeoutId = setTimeout(() => {
      if (isInitiatingCall) {
        console.log('â° Call initiation timeout (30s)');
        isInitiatingCall = false;
        audioCallBtn.classList.remove('call-btn-loading');
        if (videoCallBtn) {
          videoCallBtn.classList.remove('calling');
        }
        
        // CRITICAL: Re-enable buttons after timeout
        if (isSocketAuthenticated) {
          enableCallButtons();
        }
        
        toast('Call timeout - no response', 'warning');
      }
    }, 30000);
    
    // Store timeout for cleanup
    audioCallBtn.dataset.timeoutId = timeoutId;
    
    console.log('ðŸ“ž ========================================\n');
    
  }, { passive: true });
}

if (videoCallBtn) {
  videoCallBtn.addEventListener('click', async () => {
    console.log('ðŸ“ž ========================================');
    console.log('ðŸ“ž VIDEO CALL BUTTON CLICKED');
    console.log('ðŸ“ž ========================================');
    console.log(`   Authentication state: ${isSocketAuthenticated}`);
    console.log(`   Socket connected: ${socketInstance?.connected}`);
    console.log(`   Already initiating: ${isInitiatingCall}`);
    
    // CRITICAL: Block if already initiating
    if (isInitiatingCall) {
      console.log('âš ï¸ Call already being initiated, ignoring click');
      console.log('ðŸ“ž ========================================\n');
      return;
    }
    
    // CRITICAL: Wait for authentication if not ready
    if (!isSocketAuthenticated) {
      console.log('â³ Not authenticated yet - waiting...');
      videoCallBtn.disabled = true;
      videoCallBtn.classList.add('animate-pulse');
      
      try {
        await waitForAuthentication();
        console.log('âœ… Authentication complete, proceeding with call');
      } catch (e) {
        console.error('âŒ Authentication wait failed:', e);
        toast('Connection failed. Please refresh.', 'error');
        videoCallBtn.disabled = false;
        videoCallBtn.classList.remove('animate-pulse');
        console.log('ðŸ“ž ========================================\n');
        return;
      }
    }
    
    // CRITICAL: Verify socket still connected
    if (!socketInstance || !socketInstance.connected) {
      console.error('âŒ Socket disconnected during call initiation');
      toast('Connection lost. Please refresh.', 'error');
      console.log('ðŸ“ž ========================================\n');
      return;
    }
    
    console.log('âœ… All checks passed - initiating video call');
    isInitiatingCall = true;
    
    // Add loading state
    videoCallBtn.classList.add('call-btn-loading');
    videoCallBtn.disabled = true;
    if (audioCallBtn) {
      audioCallBtn.classList.add('calling');
      audioCallBtn.disabled = true;
    }
    
    socketInstance.emit('initiate_call', {
      roomId: roomData.roomId,
      callType: 'video'
    });
    
    console.log('ðŸ“¤ Video call initiation sent to server');
    toast('Calling...', 'success');
    
    // Timeout after 30 seconds with recovery
    const timeoutId = setTimeout(() => {
      if (isInitiatingCall) {
        console.log('â° Call initiation timeout (30s)');
        isInitiatingCall = false;
        videoCallBtn.classList.remove('call-btn-loading');
        if (audioCallBtn) {
          audioCallBtn.classList.remove('calling');
        }
        
        // CRITICAL: Re-enable buttons after timeout
        if (isSocketAuthenticated) {
          enableCallButtons();
        }
        
        toast('Call timeout - no response', 'warning');
      }
    }, 30000);
    
    // Store timeout for cleanup
    videoCallBtn.dataset.timeoutId = timeoutId;
    
    console.log('ðŸ“ž ========================================\n');
    
  }, { passive: true });
}



if (joinCallBtn) {
    joinCallBtn.addEventListener('click', () => {
        console.log('ðŸ”˜ ========================================');
        console.log('ðŸ”˜ JOIN CALL BUTTON CLICKED');
        console.log('ðŸ”˜ ========================================');
        
        // Check if this is "Back to Call" or "Join Call"
        const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
        const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomData?.roomId;
        
        console.log(`   activeCallStr exists: ${!!activeCallStr}`);
        console.log(`   userInCall: ${userInCall}`);
        console.log(`   activeCallInRoom exists: ${!!activeCallInRoom}`);
        
        if (userInCall) {
            // User is already in call - show call UI in iframe/overlay
            console.log('ðŸ“ž BACK TO CALL MODE');
            
            const activeCallData = JSON.parse(activeCallStr);
            console.log(`   callId: ${activeCallData.callId}`);
            console.log(`   Call is running in background - will hide chat overlay`);
            
            if (window.parent && window.parent !== window) {
                console.log('ðŸ“± We are in iframe - posting message to parent');
                window.parent.postMessage({ action: 'hideChat' }, '*');
            } else {
                console.log('âš ï¸ Not in iframe - navigating directly');
                window.location.href = '/call.html';
            }
            
            console.log('ðŸ”˜ ========================================\n');
        } else {
            // No active call - join existing call
            console.log('ðŸ“ž JOIN EXISTING CALL MODE');
            
            if (!activeCallInRoom) {
                console.error('âŒ activeCallInRoom is null/undefined!');
                console.log('   This should not happen - UI should not show Join button');
                toast('No active call to join', 'warning');
                console.log('ðŸ”˜ ========================================\n');
                return;
            }
            
            console.log(`   activeCallInRoom.callId: ${activeCallInRoom.callId}`);
            console.log(`   activeCallInRoom.callType: ${activeCallInRoom.callType}`);
            console.log(`   activeCallInRoom.participantCount: ${activeCallInRoom.participantCount}`);
            console.log(`   roomData.roomId: ${roomData.roomId}`);
            
            // Add loading state
            joinCallBtn.classList.add('join-btn-loading');
            joinCallBtn.disabled = true;
            console.log('â³ Join button set to loading state');
            
            // CRITICAL FIX: Store call data BEFORE emitting join_existing_call
            const callDataToStore = {
                callId: activeCallInRoom.callId,
                roomId: roomData.roomId,
                callType: activeCallInRoom.callType,
                users: []
            };
            
            localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify(callDataToStore));
            console.log('ðŸ’¾ Stored call data to localStorage (pre-join):');
            console.log('   ', JSON.stringify(callDataToStore, null, 2));
            
            const eventData = {
                callId: activeCallInRoom.callId,
                roomId: roomData.roomId
            };
            
            console.log('ðŸ“¤ Emitting join_existing_call with data:');
            console.log('   ', JSON.stringify(eventData, null, 2));
            
            if (!socketInstance || !socketInstance.connected) {
                console.error('âŒ Socket not connected!');
                toast('Connection lost. Please refresh the page.', 'error');
                joinCallBtn.classList.remove('join-btn-loading');
                joinCallBtn.disabled = false;
                console.log('ðŸ”˜ ========================================\n');
                return;
            }
            
            socketInstance.emit('join_existing_call', eventData);
            
            toast('Joining call...', 'success');
            console.log('âœ… Event emitted successfully');
            console.log('ðŸ”˜ ========================================\n');
        }
    }, { passive: true });
}

if (acceptCallBtn) {
  acceptCallBtn.addEventListener('click', () => {
    if (pendingCallData) {
      const callToAccept = pendingCallData;
      pendingCallData = null;
      
      console.log('âœ… ========================================');
      console.log('âœ… USER ACCEPTED INCOMING CALL');
      console.log('âœ… ========================================');
      console.log(`   callId: ${callToAccept.callId}`);
      
      // Clear cached call
      localStorage.removeItem(CACHED_CALL_KEY);
      
      // Hide modal
      incomingCallModal?.classList.add('hidden');
      
      // Mark navigating
      navigatingToCall = true;
      
      // Add loading state
      acceptCallBtn.classList.add('join-btn-loading');
      acceptCallBtn.disabled = true;
      
      // Save chat state
      saveChatState(roomData.roomId, messagesCache);
      sessionStorage.setItem('returningFromCall', 'true');
      
      // CRITICAL FIX: Store call data BEFORE emitting join_existing_call
      localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
        callId: callToAccept.callId,
        roomId: roomData.roomId,
        callType: callToAccept.callType,
        users: []
      }));
      console.log('ðŸ’¾ Stored call data to localStorage (pre-join)');
      
      console.log('ðŸ“¤ Emitting join_existing_call to server');
      
      // Use join_existing_call to ensure server adds us to participants list first
      socketInstance?.emit('join_existing_call', {
        callId: callToAccept.callId,
        roomId: roomData.roomId
      });
      
      console.log('âœ… Join request sent - will navigate on success');
      console.log('âœ… ========================================\n');
      
      // Don't navigate here - wait for join_existing_call_success event
    }
  }, { passive: true });
}

if (declineCallBtn) {
  declineCallBtn.addEventListener('click', () => {
    if (pendingCallData) {
      const callToDecline = pendingCallData;
      pendingCallData = null;
      
      console.log('âŒ ========================================');
      console.log('âŒ USER DECLINED INCOMING CALL');
      console.log('âŒ ========================================');
      console.log(`   callId: ${callToDecline.callId}`);
      console.log(`   Call remains active - user can still join via JOIN button`);
      
      // Clear cached call
      localStorage.removeItem(CACHED_CALL_KEY);
      console.log('ðŸ—‘ï¸ Cleared cached call after decline');
      
      // Hide modal
      incomingCallModal?.classList.add('hidden');
      
      console.log('âœ… Modal dismissed - call still active in room');
      console.log('âŒ ========================================\n');
    }
  }, { passive: true });
}

if (messageForm) {
  messageForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const message = messageInput?.value.trim();
    
    // Allow sending if there's a message OR an attachment
    if (!message && !pendingAttachment) {
      console.log('âš ï¸ No message or attachment to send');
      return;
    }

    console.log('ðŸ“¤ ========================================');
    console.log('ðŸ“¤ SENDING MESSAGE TO SERVER');
    console.log('ðŸ“¤ ========================================');
    console.log(`   Message: ${message || '[attachment only]'}`);
    console.log(`   Has attachment: ${!!pendingAttachment}`);

    // ============================================
    // PREPARE SERVER MESSAGE DATA
    // ============================================
    const serverMessageData = {
      roomId: roomData.roomId,
      message: message || ''
    };

    // Add reply data for server
    if (replyingTo) {
      serverMessageData.replyTo = {
        messageId: replyingTo.messageId,
        username: replyingTo.username,
        message: replyingTo.message,
        userId: replyingTo.userId
      };
      hideReplyPreview();
    }

    // ============================================
    // HANDLE ATTACHMENT - CHUNKED TRANSMISSION
    // ============================================
    if (pendingAttachment) {
      try {
        console.log('ðŸ“Ž ========================================');
        console.log('ðŸ“Ž PREPARING CHUNKED ATTACHMENT TRANSMISSION');
        console.log('ðŸ“Ž ========================================');
        console.log(`   FileID: ${pendingAttachment.fileId}`);
        console.log(`   File: ${pendingAttachment.name}`);
        console.log(`   Size: ${(pendingAttachment.size / 1024 / 1024).toFixed(2)} MB`);
        
        // Show upload progress UI
        const progressDiv = document.createElement('div');
        progressDiv.id = 'uploadProgress';
        progressDiv.className = 'fixed top-4 right-4 bg-[#161b22] border border-[#30363d] rounded-lg px-4 py-3 shadow-lg z-50';
        progressDiv.innerHTML = `
          <div class="flex items-center gap-3">
            <div class="animate-spin">
              <span class="material-symbols-outlined text-[#06b6d4]">progress_activity</span>
            </div>
            <div>
              <div class="text-sm font-semibold text-gray-200">${pendingAttachment.name}</div>
              <div id="uploadProgressText" class="text-xs text-gray-400">Preparing...</div>
            </div>
          </div>
        `;
        document.body.appendChild(progressDiv);
        
        // Get file from IndexedDB
        const fileData = await getFileFromIndexedDB(pendingAttachment.fileId);
        
        if (!fileData || !fileData.blob) {
          throw new Error('Failed to retrieve file from storage');
        }
        
        console.log(`âœ… File retrieved from IndexedDB`);
        
        // Create File object from blob
        const file = new File([fileData.blob], fileData.name, { type: fileData.type });
        
        // Chunk the file
        const progressText = document.getElementById('uploadProgressText');
        if (progressText) progressText.textContent = 'Chunking...';
        
        const chunks = await chunkFile(file);
        
        console.log(`âœ… File chunked into ${chunks.length} pieces`);
        
        // Add attachment metadata (no data - will be sent separately)
        serverMessageData.attachment = {
          fileId: pendingAttachment.fileId,
          name: pendingAttachment.name,
          type: pendingAttachment.type,
          size: pendingAttachment.size,
          chunked: true, // Signal that chunks will follow
          totalChunks: chunks.length
        };
        
        // Send message metadata first (creates message in UI)
        console.log('ðŸ“¤ Emitting message metadata to server...');
        socketInstance.emit('chat_message', serverMessageData);
        
        // Then send file chunks
        if (progressText) progressText.textContent = 'Uploading: 0%';
        
        await sendFileInChunks(
          pendingAttachment.fileId,
          pendingAttachment.name,
          pendingAttachment.type,
          pendingAttachment.size,
          chunks,
          roomData.roomId
        );
        
        console.log('âœ… File transmission complete');
        
        // Remove progress UI
        progressDiv.remove();
        
        toast(`File uploaded: ${pendingAttachment.name}`, 'success');
        
        console.log('ðŸ“Ž ========================================\n');
        
      } catch (error) {
        console.error('âŒ Attachment transmission failed:', error);
        
        // Remove progress UI
        const progressDiv = document.getElementById('uploadProgress');
        if (progressDiv) progressDiv.remove();
        
        toast('Failed to send attachment. Please try again.', 'error');
        console.log('ðŸ“Ž ========================================\n');
        return; // Don't clear input on failure
      }
    } else {
      // No attachment - send message normally
      console.log('ðŸ“¤ Emitting text-only message...');
      socketInstance.emit('chat_message', serverMessageData);
      console.log('âœ… Message sent to server');
    }

    console.log('ðŸ“¤ ========================================\n');

    // ============================================
    // CLEAR INPUT AND ATTACHMENTS
    // ============================================
    if (messageInput) messageInput.value = '';
    
    if (pendingAttachment) {
      hideAttachmentPreview();
    }
  });
}

leaveBtn?.addEventListener('click', async () => {
  console.log('ðŸšª Header Leave button clicked');
  
  const shouldLeave = await showConfirmationDialog();
  
  if (shouldLeave) {
    // âœ… CORRECT: This is the reference implementation
    // All other leave paths should match this exactly
    
    if (isLeaving) return;
    isLeaving = true;
    backButtonHandled = true;
    
    try {
      stopCachedCallMonitoring();
      
      // 1. Leave active call
      const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
      if (activeCallStr) {
        const callData = JSON.parse(activeCallStr);
        if (socketInstance?.connected) {
          socketInstance.emit('leave_call', { callId: callData.callId });
          await new Promise(resolve => setTimeout(resolve, 300));
        }
        localStorage.removeItem(ACTIVE_CALL_KEY);
        sessionStorage.removeItem('hasBackgroundCall');
        sessionStorage.removeItem('returningFromCall');
        sessionStorage.removeItem('backgroundCallMode');
        sessionStorage.removeItem('returningToBackgroundCall');
      }
      
      // 2. Leave room
      if (socketInstance?.connected) {
        socketInstance.emit('leave_room');
        await new Promise(resolve => setTimeout(resolve, 300));
      }
      
      // 3. Clear state and navigate
      await clearChatState(true);
      window.location.href = '/mood.html';
      
    } catch (error) {
      console.error('Error:', error);
      window.location.href = '/mood.html';
    }
  }
});

    // Visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        console.log('ðŸ“± Page hidden');
        saveChatState(roomData.roomId, messagesCache);
      } else {
        console.log('ðŸ“± Page visible');
      }
    });

// REPLACE LINES 4656-4703 WITH:

window.addEventListener('beforeunload', (e) => {
  console.log('ðŸšª ========================================');
  console.log('ðŸšª CHAT PAGE BEFOREUNLOAD EVENT');
  console.log('ðŸšª ========================================');
  console.log(`   Reason: Page unload/navigation/close`);
  console.log(`   Background call: ${isInBackgroundCall}`);
  console.log(`   Navigating to call: ${navigatingToCall}`);
  
  stopCachedCallMonitoring();
  
  // Clean up blob URLs
  console.log('ðŸ§¹ Cleaning up blob URLs...');
  const images = document.querySelectorAll('img[data-blob-url]');
  images.forEach(img => {
    const blobUrl = img.dataset.blobUrl;
    if (blobUrl) {
      URL.revokeObjectURL(blobUrl);
    }
  });
  console.log(`âœ… Revoked ${images.length} blob URL(s)`);
  
  // ============================================
  // EXCEPTION 1: BACKGROUND CALL MODE
  // ============================================
  if (isInBackgroundCall) {
    console.log('ðŸ”’ Background call active - preserving floating socket');
    saveChatState(roomData.roomId, messagesCache);
    
    // Don't disconnect floating socket - let it persist
    if (floatingCallSocket) {
      console.log('âœ… Keeping floating call socket alive');
    }
    
    // Only disconnect main chat socket (but DON'T leave room)
    if (socketInstance) {
      socketInstance.disconnect();
    }
    
    console.log('ðŸšª ========================================\n');
    return;
  }
  
  // ============================================
  // EXCEPTION 2: NAVIGATING TO CALL PAGE
  // ============================================
  if (navigatingToCall) {
    console.log('ðŸ”’ Navigating to call - preserving state');
    saveChatState(roomData.roomId, messagesCache);
    console.log('ðŸšª ========================================\n');
    return;
  }
  
  // ============================================
  // CRITICAL FIX: EXECUTE FULL LEAVE SEQUENCE
  // ============================================
  console.log('ðŸ—‘ï¸ EXECUTING FULL LEAVE SEQUENCE (same as Leave button)');
  
  try {
    // 1. Leave any active call
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    if (activeCallStr) {
      try {
        const callData = JSON.parse(activeCallStr);
        console.log(`ðŸ“ž Leaving active call: ${callData.callId}`);
        
        if (socketInstance?.connected) {
          // SYNCHRONOUS emit (beforeunload is synchronous)
          socketInstance.emit('leave_call', { callId: callData.callId });
        }
      } catch (e) {
        console.error('âŒ Error parsing call data:', e);
      }
      
      localStorage.removeItem(ACTIVE_CALL_KEY);
      sessionStorage.removeItem('hasBackgroundCall');
      sessionStorage.removeItem('returningFromCall');
      sessionStorage.removeItem('backgroundCallMode');
      sessionStorage.removeItem('returningToBackgroundCall');
      console.log('âœ… Call data cleared');
    }
    
    // 2. Leave the room
    if (socketInstance?.connected) {
      console.log('ðŸšª Emitting leave_room to server');
      // SYNCHRONOUS emit - critical for beforeunload
      socketInstance.emit('leave_room');
      console.log('âœ… leave_room emitted');
    }
    
    // 3. Clear all chat state
    clearChatState(true);
    console.log('âœ… Chat state cleared');
    
    // 4. Disconnect socket
    if (socketInstance) {
      socketInstance.disconnect();
      console.log('âœ… Socket disconnected');
    }
    
    // 5. Clear timer
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
      console.log('âœ… Timer cleared');
    }
    
    console.log('âœ… FULL LEAVE SEQUENCE COMPLETE');
    
  } catch (error) {
    console.error('âŒ Error in beforeunload leave sequence:', error);
    
    // Force cleanup even on error
    try {
      clearChatState(true);
      if (socketInstance) socketInstance.disconnect();
      if (timerInterval) clearInterval(timerInterval);
    } catch (e) {
      console.error('âŒ Cleanup failed:', e);
    }
  }
  
  console.log('ðŸšª ========================================\n');
});
  }

  // ============================================
  // INITIALIZATION
  // ============================================
  
  
  try {
  await initFileDB();
  console.log('âœ… File storage initialized');
  
  // Clean up any orphaned files from previous sessions
  if (roomData?.roomId) {
    const fileCount = await getRoomFileCount(roomData.roomId);
    if (fileCount > 0) {
      console.log(`â„¹ï¸ Found ${fileCount} existing file(s) for this room`);
    }
  }
} catch (error) {
  console.error('âš ï¸ File storage initialization failed:', error);
  console.error('   File attachments will be disabled');
  // Disable attachment button if IndexedDB fails
  const attachBtn = document.querySelector('.attachment-btn');
  if (attachBtn) {
    attachBtn.disabled = true;
    attachBtn.classList.add('opacity-50', 'cursor-not-allowed');
    attachBtn.title = 'File attachments unavailable';
  }
}
  
try {

 isPageRefresh = detectPageRefresh();
  console.log('ðŸ” Page load type:', isPageRefresh ? 'REFRESH' : 'NAVIGATION');
    // Check if we're returning from a call OR if we're in an iframe (chat overlay)
    const returningFromCall = sessionStorage.getItem('returningFromCall') === 'true';
    const isBackgroundCall = sessionStorage.getItem('backgroundCallMode') === 'true';
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    const isInIframe = window.parent && window.parent !== window;
    
    // CRITICAL: If there's an active call in this room, we're likely returning from it
    let shouldPreserveState = returningFromCall || isBackgroundCall;
    
    if (!shouldPreserveState && activeCallStr && isInIframe) {
        try {
            const activeCall = JSON.parse(activeCallStr);
            const roomStr = localStorage.getItem('currentRoom');
            if (roomStr) {
                const room = JSON.parse(roomStr);
                if (activeCall.roomId === room.roomId) {
                    console.log('ðŸ” Active call detected in iframe - treating as return from call');
                    shouldPreserveState = true;
                }
            }
        } catch (e) {
            console.warn('Failed to parse call/room data:', e);
        }
    }

    
    console.log('ðŸ” Page load context:', { 
        returningFromCall, 
        isBackgroundCall, 
        isInIframe,
        shouldPreserveState,
        hasActiveCall: !!activeCallStr
    });
    
    if (!shouldPreserveState) {
        // Only clear if this is a fresh entry to chat (not returning from call)
        console.log('ðŸ§¹ Fresh chat entry - clearing old state');
        clearAllChatData();
    } else {
        console.log('ðŸ”„ Returning from call - preserving chat state');
        // Don't clear - we want to restore the previous state
    }
    
    // Auth check
    await _Auth.requireAuth();
  } catch (err) {
    console.error('âŒ Auth failed:', err);
    window.location.href = '/login.html';
    return;
  }
  
  
// CRITICAL: Initialize floating call popup elements early
console.log('ðŸŽˆ Pre-initializing floating call popup');

// Check if returning from call
const returningFromCall = sessionStorage.getItem('returningFromCall');
if (returningFromCall === 'true') {
  console.log('ðŸ”„ Returning from call - popup will be shown after room_joined');
  console.log('ðŸ” Active call check:', !!localStorage.getItem(ACTIVE_CALL_KEY));
}

  const roomDataStr = localStorage.getItem('currentRoom');
  if (!roomDataStr) {
    console.error('âŒ No currentRoom in localStorage');
    toast('No active room found', 'error');
    setTimeout(() => window.location.href = '/mood.html', 1500);
    return;
  }

  try {
    roomData = JSON.parse(roomDataStr);
    console.log('ðŸ“¦ Loaded room data from localStorage:');
    console.log(`   roomId: ${roomData.roomId}`);
    
    // CRITICAL: Don't trust localStorage expiresAt - wait for server
    if (roomData.expiresAt) {
      console.log(`   LocalStorage expiresAt: ${new Date(roomData.expiresAt).toISOString()}`);
      console.log(`   âš ï¸ Will be replaced with server time after connection`);
    } else {
      console.log(`   No expiresAt in localStorage - will get from server`);
    }
    
    if (!roomData.roomId) {
      throw new Error('Invalid room data: missing roomId');
    }
    checkForBackgroundCall();
  } catch (err) {
    console.error('âŒ Invalid room data:', err);
    toast('Invalid room data', 'error');
    clearChatState(true);
    setTimeout(() => window.location.href = '/mood.html', 1500);
    return;
  }

  // Get Firebase user
  const firebaseUser = firebase.auth().currentUser;
  if (!firebaseUser) {
    window.location.href = '/login.html';
    return;
  }

  // Get current user data
  try {
    const userData = await _API.get('/api/users/me');
    currentUser = {
      userId: userData._id,
      username: userData.username,
      pfpUrl: userData.pfpUrl
    };
  } catch (err) {
    console.error('âŒ Failed to get user data:', err);
    toast('Failed to load user data', 'error');
    setTimeout(() => window.location.href = '/login.html', 1500);
    return;
  }
  
    if (isPageRefresh) {
    restoreStateAfterRefresh(roomData.roomId);
  }

  
// CRITICAL: Start with buttons DISABLED until authenticated
console.log('ðŸŽšï¸ Initializing call buttons (disabled until authenticated)');
disableCallButtons(false); // false = don't show loading, just disabled

const cachedState = loadChatState();

if (cachedState && cachedState.roomId === roomData.roomId) {
  console.log('ðŸŽ¨ Restoring UI from cache IMMEDIATELY on page load');
  console.log(`   Cached button state: ${cachedState.callButtonState}`);
  console.log(`   Cached activeCallInRoom:`, cachedState.activeCallInRoom);
  
  // Restore activeCallInRoom immediately
  if (cachedState.activeCallInRoom) {
    activeCallInRoom = cachedState.activeCallInRoom;
    console.log('ðŸ’¾ Pre-loaded activeCallInRoom from cache');
  } else if (cachedState.callButtonState === 'back') {
    // Reconstruct from ACTIVE_CALL_KEY
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    if (activeCallStr) {
      try {
        const activeCallData = JSON.parse(activeCallStr);
        activeCallInRoom = {
          callId: activeCallData.callId,
          callType: activeCallData.callType,
          participantCount: 2
        };
        console.log('ðŸ’¾ Pre-loaded activeCallInRoom from ACTIVE_CALL_KEY');
      } catch (e) {
        console.error('Failed to reconstruct activeCallInRoom:', e);
      }
    }
  }
  
  // Set button state immediately from cache (but keep disabled until auth)
  if (cachedState.callButtonState === 'back') {
    updateCallButtonState(true, activeCallInRoom || { participantCount: 1 });
    console.log('âœ… "Back to Call" button shown immediately from cache (disabled until auth)');
  } else if (cachedState.callButtonState === 'join' && activeCallInRoom) {
    updateCallButtonState(true, activeCallInRoom);
    console.log('âœ… "Join Call" button shown immediately from cache (disabled until auth)');
  } else {
    setInitialCallButtonState();
  }
} else {
  // No cache - use normal initial state (disabled)
  setInitialCallButtonState();
}

  
  // Mark as joined
  hasJoinedRoom = true;
  saveParticipationState(roomData.roomId, true);

  console.log('â° Starting timer interval (will update when server data arrives)');
  // Start timer interval (will show "--" until server data arrives)
  timerInterval = setInterval(updateTimer, 1000);
  updateTimer();

  // Initialize socket
  try {
    const idToken = await firebaseUser.getIdToken();
    const socketUrl = window.location.origin;
    
    socketInstance = io(socketUrl, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 500,
      reconnectionAttempts: 10,
      auth: { token: idToken },
      timeout: 10000
    });

    setupSocketHandlers();
  } catch (err) {
    console.error('âŒ Socket initialization failed:', err);
    toast('Connection failed', 'error');
  }

  // Setup all event listeners
  setupEventListeners();

  // Setup back button handler
  setupBackButtonHandler();
  setupAndroidBackButtonHandler();

  console.log('âœ… Chat initialization complete');

})();
</script>
</body>
</html>
