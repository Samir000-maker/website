
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat Room - MoodLog</title>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="global.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Manrope', sans-serif;
        }
        
        .reply-btn {
            opacity: 0;
            transition: opacity 0.15s ease;
            cursor: pointer;
        }
        .message-item:hover .reply-btn {
            opacity: 1;
        }
        
        .reply-preview {
            animation: slideUp 0.15s ease-out;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .quoted-message {
            border-left: 3px solid #93c5fd;
            padding-left: 8px;
            margin-bottom: 6px;
            background-color: rgba(255, 255, 255, 0.15);
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 0.813rem;
        }
        
        .quoted-message-light {
            background-color: rgba(0, 0, 0, 0.05);
            border-left-color: #4a9d9d;
        }

        .sidebar {
            transition: transform 0.2s ease;
        }
        
        .main-container {
            height: 100vh;
            height: 100dvh;
        }

        .chat-main {
            max-height: calc(100vh - 64px);
            max-height: calc(100dvh - 64px);
        }

        @media (max-width: 768px) {
            .chat-main {
                max-height: calc(100vh - 56px);
                max-height: calc(100dvh - 56px);
            }
        }
        
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100vh;
                width: 280px;
                z-index: 40;
                box-shadow: 2px 0 10px rgba(0,0,0,0.1);
                transform: translateX(-100%);
            }
            
            .sidebar.show {
                transform: translateX(0);
            }
            
            .sidebar-overlay {
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.5);
                z-index: 30;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.2s ease;
            }
            
            .sidebar-overlay.active {
                opacity: 1;
                pointer-events: auto;
            }
        }
        
        @media (min-width: 769px) {
            .sidebar {
                position: relative;
                width: 280px;
                min-width: 280px;
                display: block !important;
            }
            
            .sidebar-toggle {
                display: none;
            }
            
            .sidebar-overlay {
                display: none;
            }
        }

        .user-card {
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .user-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .calling {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .call-buttons-container {
            position: relative;
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        @media (max-width: 640px) {
            .call-buttons-container {
                gap: 8px;
            }
        }
        
        @supports (padding: max(0px)) {
            .header-safe {
                padding-top: max(1rem, env(safe-area-inset-top));
            }
            
            .bottom-safe {
                padding-bottom: max(1rem, env(safe-area-inset-bottom));
            }
        }
        
        @media (max-width: 640px) {
            #messageForm {
                gap: 8px;
            }
            
            #messageInput {
                font-size: 16px;
                min-height: 44px;
            }
            
            #messageForm button[type="submit"] {
                min-width: 44px;
                min-height: 44px;
            }
        }
        
        /* Confirmation Dialog Styles */
        .confirmation-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            opacity: 0;
            animation: fadeIn 0.15s ease-out forwards;
        }
        
        .confirmation-dialog {
            background: white;
            border-radius: 1.5rem;
            padding: 2rem;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            transform: scale(0.95) translateY(10px);
            animation: slideUpDialog 0.2s ease-out forwards;
        }
        
        .dark .confirmation-dialog {
            background: #22252a;
            border: 1px solid #374151;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        @keyframes slideUpDialog {
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        .confirmation-buttons {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }
        
        .confirmation-buttons button {
            flex: 1;
            padding: 0.875rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.15s ease;
            border: none;
            cursor: pointer;
        }
        
        .btn-stay {
            background: #367d7d;
            color: white;
        }
        
        .btn-stay:hover {
            background: #2d6666;
        }
        
        .btn-stay:active {
            transform: scale(0.97);
        }
        
        .btn-leave {
            background: #f3f4f6;
            color: #374151;
        }
        
        .dark .btn-leave {
            background: #374151;
            color: #e5e7eb;
        }
        
        .btn-leave:hover {
            background: #e5e7eb;
        }
        
        .dark .btn-leave:hover {
            background: #4b5563;
        }
        
        .btn-leave:active {
            transform: scale(0.97);
        }
        
        /* Animate message appearance */
        .animate-fade-in-up {
            animation: fadeInUp 0.2s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Loading state for buttons */
        .btn-loading {
            position: relative;
            pointer-events: none;
        }
        
        .btn-loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.6s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        
      

@keyframes slideOutToRight {
    from {
        opacity: 1;
        transform: translateX(0);
    }
    to {
        opacity: 0;
        transform: translateX(100px);
    }
}

/* Pulsing avatar border for active speaker */
.speaking-border {
    animation: pulseBorder 1.5s ease-in-out infinite;
}

@keyframes pulseBorder {
    0%, 100% {
        border-color: #33bfcc;
        box-shadow: 0 0 0 0 rgba(51, 191, 204, 0.4);
    }
    50% {
        border-color: #2aa5b0;
        box-shadow: 0 0 0 4px rgba(51, 191, 204, 0.2);
    }
}

/* Responsive adjustments */
@media (max-width: 640px) {
    #floatingCallPopup {
    display: none !important;
        right: 0.75rem;
        top: 4.5rem;
    }
}
        
        
        /* Call Button Loading States */
.call-btn-loading {
    position: relative;
    pointer-events: none;
    opacity: 0.7;
}

.call-btn-loading .material-symbols-outlined {
    opacity: 0;
}

.call-btn-loading::after {
    content: '';
    position: absolute;
    width: 20px;
    height: 20px;
    top: 50%;
    left: 50%;
    margin-left: -10px;
    margin-top: -10px;
    border: 2.5px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #ffffff;
    animation: spin 0.8s linear infinite;
}

.join-btn-loading {
    position: relative;
    pointer-events: none;
    opacity: 0.7;
}

.join-btn-loading .material-symbols-outlined,
.join-btn-loading span:not(.loader) {
    opacity: 0;
}

.join-btn-loading::after {
    content: '';
    position: absolute;
    width: 18px;
    height: 18px;
    top: 50%;
    left: 50%;
    margin-left: -9px;
    margin-top: -9px;
    border: 2.5px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #ffffff;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}


@keyframes pulse-slow {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.animate-pulse-slow {
    animation: pulse-slow 2s ease-in-out infinite;
}
        
    </style>
</head>
<body class="bg-background-light main-container flex flex-col overflow-hidden">
    <header class="sticky top-0 z-50 w-full border-b border-gray-200 bg-white/95 backdrop-blur header-safe">
        <div class="mx-auto flex h-14 sm:h-16 max-w-full items-center justify-between px-3 sm:px-6">
            <div class="flex items-center gap-2 sm:gap-3 flex-1 min-w-0">
                <button id="sidebarToggle" class="sidebar-toggle p-2 hover:bg-gray-100 rounded-lg md:hidden flex-shrink-0">
                    <span class="material-symbols-outlined text-gray-700">menu</span>
                </button>
                
                <div class="min-w-0 flex-1">
                    <h2 class="text-base sm:text-lg font-bold truncate">Mindful Space</h2>
                    <div class="flex items-center gap-1.5 sm:gap-2 text-xs text-gray-500">
                        <span class="flex h-2 w-2 rounded-full bg-green-500 flex-shrink-0"></span>
                        <span id="onlineCount" class="truncate">Loading...</span>
                        <span class="hidden sm:inline">‚Ä¢</span>
                        <span id="timeRemaining" class="hidden sm:inline truncate">--:-- remaining</span>
                    </div>
                </div>
            </div>
            
            <div class="flex items-center gap-2 sm:gap-3 flex-shrink-0">
                <div class="call-buttons-container">
                    <button id="audioCallBtn" 
                        class="w-9 h-9 sm:w-10 sm:h-10 flex items-center justify-center rounded-full bg-primary text-white hover:bg-primary/90 transition-all"
                        title="Start Audio Call">
                        <span class="material-symbols-outlined text-lg sm:text-xl">call</span>
                    </button>
                    <button id="videoCallBtn" 
                        class="w-9 h-9 sm:w-10 sm:h-10 flex items-center justify-center rounded-full bg-primary text-white hover:bg-primary/90 transition-all"
                        title="Start Video Call">
                        <span class="material-symbols-outlined text-lg sm:text-xl">videocam</span>
                    </button>
                    <button id="joinCallBtn" 
                        class="hidden items-center gap-1.5 px-3 sm:px-4 h-9 sm:h-10 rounded-full bg-green-600 text-white hover:bg-green-700 transition-all text-xs sm:text-sm font-semibold"
                        title="Join Active Call">
                        <span class="material-symbols-outlined text-base sm:text-lg">login</span>
                        <span class="hidden sm:inline">Join Call</span>
                        <span class="sm:hidden">Join</span>
                    </button>
                </div>
                
                <button id="leaveBtn" class="text-xs sm:text-sm font-medium text-red-600 hover:text-red-700 px-2 sm:px-3 py-1.5 sm:py-2 whitespace-nowrap">
                    <span class="hidden sm:inline">Leave Room</span>
                    <span class="sm:hidden material-symbols-outlined text-xl">logout</span>
                </button>
            </div>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative chat-main">
        <div id="sidebarOverlay" class="sidebar-overlay"></div>
        
        <aside id="sidebar" class="sidebar border-r border-gray-200 bg-white overflow-y-auto">
            <div class="p-3 sm:p-4">
                <div class="flex items-center justify-between mb-3 sm:mb-4">
                    <h3 class="text-xs font-bold text-gray-500 uppercase">Active Users</h3>
                    <button id="sidebarClose" class="md:hidden p-1 hover:bg-gray-100 rounded">
                        <span class="material-symbols-outlined text-gray-500 text-xl">close</span>
                    </button>
                </div>
                <div id="usersList" class="space-y-2 sm:space-y-3"></div>
            </div>
        </aside>

        <main class="flex-1 flex flex-col min-h-0 bg-white">
            <div id="messagesList" class="flex-1 overflow-y-auto px-2 sm:px-4 py-3 sm:py-6 space-y-2 sm:space-y-4 min-h-0">
                <div class="text-center text-xs sm:text-sm text-gray-400 mb-4">
                    Welcome to the safe space. Be kind and supportive.
                </div>
            </div>

            <div class="border-t border-gray-200 bg-white flex-shrink-0 sticky bottom-0 left-0 right-0 z-10" style="padding-bottom: env(safe-area-inset-bottom, 0px);">
                <div id="replyPreview" class="reply-preview hidden border-b border-gray-200 px-3 py-2 bg-gray-50">
                    <div class="flex items-start justify-between gap-2">
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-1.5 mb-1">
                                <span class="material-symbols-outlined text-primary text-sm">subdirectory_arrow_left</span>
                                <span class="text-xs font-medium text-primary" id="replyToUsername">Replying to User</span>
                            </div>
                            <p class="text-xs text-gray-600 truncate" id="replyToMessage">Original message text</p>
                        </div>
                        <button id="cancelReply" class="text-gray-400 hover:text-gray-600 p-1">
                            <span class="material-symbols-outlined text-lg">close</span>
                        </button>
                    </div>
                </div>
                
                <div class="p-3 pb-4">
                    <form id="messageForm" class="flex gap-2 items-center">
                        <input type="text" id="messageInput" required maxlength="500"
                            class="flex-1 px-4 py-3 text-base border-2 border-gray-300 rounded-xl focus:border-primary focus:outline-none bg-white"
                            placeholder="Type a message..." style="min-width: 0; -webkit-appearance: none;">
                        <button type="submit" class="w-12 h-12 flex-shrink-0 flex items-center justify-center bg-primary text-white rounded-xl hover:bg-primary/90 active:scale-95 transition-transform">
                            <span class="material-symbols-outlined">send</span>
                        </button>
                    </form>
                </div>
            </div>
        </main>
    </div>

    <div id="incomingCallModal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[100] flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl shadow-2xl p-6 sm:p-8 max-w-sm w-full animate-fade-in">
            <div class="text-center">
                <div class="mb-4 sm:mb-6">
                    <div id="callerAvatar" class="w-20 h-20 sm:w-24 sm:h-24 mx-auto rounded-full overflow-hidden bg-primary/20 flex items-center justify-center">
                        <span class="text-3xl sm:text-4xl">üìû</span>
                    </div>
                </div>
                <h3 class="text-lg sm:text-xl font-bold mb-2" id="callerName">Incoming Call</h3>
                <p class="text-sm sm:text-base text-gray-600 mb-6 sm:mb-8" id="callType">Audio Call</p>
                
                <div class="flex gap-3 sm:gap-4 justify-center">
                    <button id="declineCallBtn" 
                        class="flex items-center gap-2 px-5 sm:px-6 py-2.5 sm:py-3 rounded-xl bg-red-500 text-white hover:bg-red-600 transition-all text-sm sm:text-base">
                        <span class="material-symbols-outlined text-lg sm:text-xl">call_end</span>
                        <span class="font-medium">Decline</span>
                    </button>
                    <button id="acceptCallBtn" 
                        class="flex items-center gap-2 px-5 sm:px-6 py-2.5 sm:py-3 rounded-xl bg-green-500 text-white hover:bg-green-600 transition-all text-sm sm:text-base">
                        <span class="material-symbols-outlined text-lg sm:text-xl">call</span>
                        <span class="font-medium">Accept</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Dialog (hidden by default) -->
    <div id="confirmationOverlay" style="display: none;"></div>
    
    
  

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };

      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>

    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="app.js"></script>

    <script>
(async () => {
  const MoodApp = window.MoodApp || {};
  const _Auth = MoodApp.Auth;
  const _API = MoodApp.API;
  const _Toast = MoodApp.Toast;
  const _Utils = MoodApp.Utils;

const toast = (m, t='success') => { 
  if (_Toast) {
    // Handle 'info' type by mapping to 'success' if no info function exists
    const toastType = (t === 'info' && typeof _Toast.info !== 'function') ? 'success' : t;
    if (typeof _Toast[toastType] === 'function') {
      return _Toast[toastType](m);
    }
  }
  console[t==='error'?'error':'log'](m); 
};

  // ============================================
  // STORAGE KEYS
  // ============================================
  const CHAT_STATE_KEY = 'chat_state';
  const CHAT_MESSAGES_KEY = 'chat_messages';
  const CHAT_TIMESTAMP_KEY = 'chat_timestamp';
  const ACTIVE_CALL_KEY = 'activeCall';
  
  
  const CACHED_CALL_KEY = 'cachedIncomingCall';
const CALL_CACHE_TIMEOUT = 60000; // 60 seconds max cache time
let cachedCallCheckInterval = null;
  // ============================================
  // STATE MANAGEMENT
  // ============================================
  let replyingTo = null;
  let isInitiatingCall = false;
  let pendingCallData = null;
  let navigatingToCall = false;
  let messagesCache = [];
  let activeCallInRoom = null;
  let backButtonHandled = false;
  let timerInterval = null;
  let socketInstance = null;
  let currentUser = null;
  let roomData = null;
  let serverClockOffset = 0; // Milliseconds to add to client time to get server time
  let serverExpiresAt = null; // Absolute server timestamp for expiry
  
  let floatingCallPopup = null;
let floatingCallSocket = null;
let currentSpeaker = null;
let isInBackgroundCall = false;
  
  // ============================================
  // DOM ELEMENTS (Initialized early)
  // ============================================
  const sidebar = document.getElementById('sidebar');
  const sidebarToggle = document.getElementById('sidebarToggle');
  const sidebarClose = document.getElementById('sidebarClose');
  const sidebarOverlay = document.getElementById('sidebarOverlay');
  const messagesList = document.getElementById('messagesList');
  const messageForm = document.getElementById('messageForm');
  const messageInput = document.getElementById('messageInput');
  const usersList = document.getElementById('usersList');
  const onlineCount = document.getElementById('onlineCount');
  const timeRemaining = document.getElementById('timeRemaining');
  const leaveBtn = document.getElementById('leaveBtn');
  const cancelReplyBtn = document.getElementById('cancelReply');
  const audioCallBtn = document.getElementById('audioCallBtn');
  const videoCallBtn = document.getElementById('videoCallBtn');
  const joinCallBtn = document.getElementById('joinCallBtn');
  const incomingCallModal = document.getElementById('incomingCallModal');
  const acceptCallBtn = document.getElementById('acceptCallBtn');
  const declineCallBtn = document.getElementById('declineCallBtn');
  
  // ============================================
  // UTILITY FUNCTIONS
  // ============================================
  
  
  function checkForCachedCall() {
    console.log('üîç Checking for cached incoming call...');
    
    const cachedCallStr = localStorage.getItem(CACHED_CALL_KEY);
    
    if (!cachedCallStr) {
        console.log('‚ÑπÔ∏è No cached call found');
        return;
    }
    
    try {
        const cachedCall = JSON.parse(cachedCallStr);
        const cacheAge = Date.now() - cachedCall.timestamp;
        
        console.log(`üìû Found cached call from ${cachedCall.callerUsername}`);
        console.log(`   Age: ${(cacheAge / 1000).toFixed(1)}s`);
        console.log(`   Call ID: ${cachedCall.callId}`);
        
        // Check if cache is expired
        if (cacheAge > CALL_CACHE_TIMEOUT) {
            console.log(`‚è∞ Cached call expired (${(cacheAge / 1000).toFixed(1)}s > ${CALL_CACHE_TIMEOUT / 1000}s)`);
            localStorage.removeItem(CACHED_CALL_KEY);
            return;
        }
        
        // Check if call is still valid on server
        if (socketInstance && socketInstance.connected) {
            console.log(`üì° Validating cached call ${cachedCall.callId} with server...`);
            
            socketInstance.emit('validate_cached_call', {
                callId: cachedCall.callId,
                roomId: roomData.roomId
            });
        } else {
            console.warn('‚ö†Ô∏è Socket not connected, will retry validation');
        }
        
    } catch (e) {
        console.error('‚ùå Failed to parse cached call:', e);
        localStorage.removeItem(CACHED_CALL_KEY);
    }
}

function showCachedCallModal(callData) {
    console.log('üìû ========================================');
    console.log('üìû SHOWING CACHED INCOMING CALL');
    console.log('üìû ========================================');
    console.log(`   Caller: ${callData.callerUsername}`);
    console.log(`   Call ID: ${callData.callId}`);
    console.log(`   Type: ${callData.callType}`);
    
    // Set pending call data
    pendingCallData = {
        callId: callData.callId,
        callerUsername: callData.callerUsername,
        callerPfp: callData.callerPfp,
        callType: callData.callType,
        fromCache: true
    };
    
    // Update modal UI
    const callerName = document.getElementById('callerName');
    const callType = document.getElementById('callType');
    const callerAvatar = document.getElementById('callerAvatar');
    
    if (callerName) callerName.textContent = `${callData.callerUsername} is calling`;
    if (callType) callType.textContent = callData.callType === 'video' ? 'Video Call' : 'Audio Call';
    if (callerAvatar) {
        callerAvatar.innerHTML = '';
        const pfp = createProfilePictureElement(callData.callerPfp, callData.callerUsername, 'w-full h-full');
        callerAvatar.appendChild(pfp);
    }
    
    // Show modal immediately (no delay for cached calls)
    incomingCallModal?.classList.remove('hidden');
    
    console.log('‚úÖ Cached call modal displayed');
    console.log('üìû ========================================\n');
}

function startCachedCallMonitoring() {
    console.log('üîÑ Starting cached call monitoring...');
    
    // Check immediately on load
    checkForCachedCall();
    
    // Check every 2 seconds for cached calls
    cachedCallCheckInterval = setInterval(() => {
        checkForCachedCall();
    }, 2000);
    
    console.log('‚úÖ Cached call monitoring started (checks every 2s)');
}

function stopCachedCallMonitoring() {
    if (cachedCallCheckInterval) {
        clearInterval(cachedCallCheckInterval);
        cachedCallCheckInterval = null;
        console.log('üõë Cached call monitoring stopped');
    }
}
  
  
  // Function to cleanup parent call.html page
function cleanupParentCallPage() {
  console.log('üßπ ========================================');
  console.log('üßπ CLEANING UP PARENT CALL PAGE');
  console.log('üßπ ========================================');
  
  // Check if we're in an iframe (chat overlay on call.html)
  if (window.parent && window.parent !== window) {
    console.log('üì± We are in iframe - accessing parent window');
    try {
      // Hide the floating button
      const parentFloatingBtn = window.parent.document.getElementById('floatingReturnToCall');
      if (parentFloatingBtn) {
        parentFloatingBtn.classList.add('hidden');
        console.log('‚úÖ Parent floating button hidden');
      }
      
      // Navigate parent window to mood.html (this will trigger call.html cleanup)
      console.log('üîÑ Navigating parent window to mood.html');
      window.parent.location.href = '/mood.html';
      
      console.log('‚úÖ Parent window navigation initiated');
    } catch (e) {
      console.error('‚ùå Cannot access parent window:', e);
      // Fallback: just navigate ourselves
      window.location.href = '/mood.html';
    }
  } else {
    console.log('‚ÑπÔ∏è Not in iframe - navigating directly');
    window.location.href = '/mood.html';
  }
  
  console.log('üßπ ========================================\n');
}
  
  
  // Function to hide floating button in parent call.html
function hideCallPageFloatingButton() {
  console.log('üéà Attempting to hide call.html floating button');
  
  // Check if we're in an iframe (chat overlay)
  if (window.parent && window.parent !== window) {
    console.log('üì± We are in iframe - accessing parent window');
    try {
      const parentFloatingBtn = window.parent.document.getElementById('floatingReturnToCall');
      if (parentFloatingBtn) {
        parentFloatingBtn.classList.add('hidden');
        console.log('‚úÖ Parent floating button hidden');
      } else {
        console.warn('‚ö†Ô∏è Parent floating button not found');
      }
    } catch (e) {
      console.error('‚ùå Cannot access parent window (CORS?):', e);
    }
  } else {
    console.log('‚ÑπÔ∏è Not in iframe - checking local DOM');
    // If not in iframe, might be standalone chat page
    const localFloatingBtn = document.getElementById('floatingReturnToCall');
    if (localFloatingBtn) {
      localFloatingBtn.classList.add('hidden');
      console.log('‚úÖ Local floating button hidden');
    }
  }
}
  


function returnToActiveCall() {
  console.log('üîô ========================================');
  console.log('üîô RETURNING TO ACTIVE CALL FROM CHAT');
  console.log('üîô ========================================');
  
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  if (!activeCallStr) {
    console.error('‚ùå No active call data found');
    toast('No active call found', 'error');
    return;
  }
  
  try {
    const activeCallData = JSON.parse(activeCallStr);
    console.log(`   callId: ${activeCallData.callId}`);
    console.log(`   callType: ${activeCallData.callType}`);
    console.log(`   backgroundMode: ${activeCallData.backgroundMode}`);
    
    // Mark that we're returning to call (not starting new call)
    navigatingToCall = true;
    
    // CRITICAL: Remove background mode flag so call page knows we're coming back
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    
    // Mark that we're returning to existing call
    sessionStorage.setItem('returningToBackgroundCall', 'true');
    
    // Save current chat state
    saveChatState(roomData.roomId, messagesCache);
    
    // Disconnect floating socket before navigating
    if (floatingCallSocket) {
      console.log('üîå Disconnecting floating socket (will reconnect on call page)');
      floatingCallSocket.disconnect();
      floatingCallSocket = null;
    }
    
    console.log('‚úÖ Navigating back to call page');
    window.location.href = '/call.html';
    
  } catch (e) {
    console.error('‚ùå Failed to parse active call data:', e);
    toast('Failed to return to call', 'error');
  }
  
  console.log('üîô ========================================\n');
}

function checkForBackgroundCall() {
  const hasBackgroundCall = sessionStorage.getItem('hasBackgroundCall') === 'true';
  const activeCallStr = localStorage.getItem('activeCall');
  
  console.log('üîç Checking for background call...');
  console.log(`   hasBackgroundCall flag: ${hasBackgroundCall}`);
  console.log(`   activeCall in storage: ${!!activeCallStr}`);
  
  if (hasBackgroundCall && activeCallStr) {
    console.log('‚úÖ Background call detected - showing return button');
    
    const returnBtn = document.getElementById('floatingReturnToCall');
    if (returnBtn) {
      returnBtn.classList.remove('hidden');
      
      returnBtn.onclick = () => {
        console.log('üìû Return to call clicked');
        sessionStorage.removeItem('hasBackgroundCall');
        window.location.href = '/call.html';
      };
      
      console.log('‚úÖ Return to call button activated');
    }
  } else {
    console.log('‚ÑπÔ∏è No background call detected');
  }
}
  
  
  
  function saveChatState(roomId, messages) {
    try {
      const state = {
        roomId,
        messages: messages || [],
        timestamp: Date.now()
      };
      localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(state));
      localStorage.setItem(CHAT_TIMESTAMP_KEY, Date.now().toString());
      console.log('‚úÖ Chat state saved:', messages.length, 'messages');
    } catch (e) {
      console.warn('‚ö†Ô∏è Failed to save chat state:', e);
    }
  }
  
  function loadChatState() {
    try {
      const stateStr = localStorage.getItem(CHAT_STATE_KEY);
      if (!stateStr) return null;
      
      const state = JSON.parse(stateStr);
      console.log('‚úÖ Chat state loaded:', state.messages?.length || 0, 'messages');
      return state;
    } catch (e) {
      console.warn('‚ö†Ô∏è Failed to load chat state:', e);
      return null;
    }
  }
  
  function clearChatState() {
    localStorage.removeItem(CHAT_STATE_KEY);
    localStorage.removeItem(CHAT_MESSAGES_KEY);
    localStorage.removeItem(CHAT_TIMESTAMP_KEY);
    console.log('üóëÔ∏è Chat state cleared');
  }

  function clearAllChatData() {
    // CRITICAL: Clear ALL chat-related data on entry
    localStorage.removeItem(CHAT_STATE_KEY);
    localStorage.removeItem(CHAT_MESSAGES_KEY);
    localStorage.removeItem(CHAT_TIMESTAMP_KEY);
    // Don't clear currentRoom or activeCall - those are needed
    console.log('üßπ All chat state cleared on entry');
  }
  
  function escapeHtml(text) {
    if (_Utils && typeof _Utils.escapeHtml === 'function') {
      return _Utils.escapeHtml(text);
    }
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function formatTimestamp(timestamp) {
    if (_Utils && typeof _Utils.formatDate === 'function') {
      return _Utils.formatDate(timestamp);
    }
    return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

function setInitialCallButtonState() {
    console.log('üîç Checking for active call in localStorage...');
    
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    
    if (activeCallStr) {
        try {
            const activeCallData = JSON.parse(activeCallStr);
            
            if (activeCallData.roomId === roomData?.roomId) {
                console.log(`üìû Active call found: ${activeCallData.callId} in room ${activeCallData.roomId}`);
                console.log(`‚úÖ User is IN the call - will show "Back to Call" button`);
                
                // Hide audio/video buttons
                if (audioCallBtn) {
                    audioCallBtn.classList.add('hidden');
                }
                if (videoCallBtn) {
                    videoCallBtn.classList.add('hidden');
                }
                
                // Show join button as "Back to Call" button
                if (joinCallBtn) {
                    joinCallBtn.classList.remove('hidden');
                    joinCallBtn.classList.add('flex');
                    joinCallBtn.disabled = false;
                    
                    // Update button text and icon
                    const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
                    const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
                    const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
                    
                    if (btnIcon) btnIcon.textContent = 'call';
                    if (btnTextLong) btnTextLong.textContent = 'Back to Call';
                    if (btnTextShort) btnTextShort.textContent = 'Back';
                    
                    // Change color to green
                    joinCallBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    joinCallBtn.classList.add('bg-primary', 'hover:bg-primary/90');
                    
                    console.log('‚úÖ "Back to Call" button configured');
                }
                
                return true;
            } else {
                console.log(`‚ùå Room mismatch: ${activeCallData.roomId} !== ${roomData?.roomId}`);
            }
        } catch (e) {
            console.error('‚ùå Failed to parse activeCall:', e);
            localStorage.removeItem(ACTIVE_CALL_KEY);
        }
    }
    
    // No active call - show normal buttons
    console.log('‚ÑπÔ∏è No active call - showing audio/video buttons');
    if (audioCallBtn) {
        audioCallBtn.classList.remove('hidden');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('hidden');
        videoCallBtn.disabled = false;
    }
    if (joinCallBtn) {
        joinCallBtn.classList.add('hidden');
        joinCallBtn.classList.remove('flex');
    }
    
    return false;
}
  
function updateCallButtonState(isActive, callData = null) {
    console.log('üîÑ Updating call button state:', { isActive, participantCount: callData?.participantCount });
    
    // Remove loading states and re-enable buttons
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.disabled = false;
    }
    if (joinCallBtn) {
        joinCallBtn.classList.remove('join-btn-loading');
    }
    
    // Check if user is already in the call
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomData?.roomId;
    
    if (userInCall) {
        console.log('üìû User is IN call - showing "Back to Call" button');
        
        // Hide audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.add('hidden');
            audioCallBtn.disabled = true;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.add('hidden');
            videoCallBtn.disabled = true;
        }
        
        // Show "Back to Call" button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('hidden');
            joinCallBtn.classList.add('flex');
            joinCallBtn.disabled = false;
            
            // Update button text and icon
            const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
            const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
            const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
            
            if (btnIcon) btnIcon.textContent = 'call';
            if (btnTextLong) btnTextLong.textContent = 'Back to Call';
            if (btnTextShort) btnTextShort.textContent = 'Back';
            
            // Change to primary color (teal)
            joinCallBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            joinCallBtn.classList.add('bg-primary', 'hover:bg-primary/90');
            
            console.log('‚úÖ "Back to Call" button displayed');
        }
    } else if (isActive && callData) {
        console.log('üìû Active call in room but user NOT in it - showing "Join Call" button');
        
        // Hide audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.add('hidden');
            audioCallBtn.disabled = true;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.add('hidden');
            videoCallBtn.disabled = true;
        }
        
        // Show "Join Call" button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('hidden');
            joinCallBtn.classList.add('flex');
            joinCallBtn.disabled = false;
            
            // Update button text and icon for join
            const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
            const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
            const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
            
            if (btnIcon) btnIcon.textContent = 'login';
            if (btnTextLong) btnTextLong.textContent = 'Join Call';
            if (btnTextShort) btnTextShort.textContent = 'Join';
            
            // Green color for join
            joinCallBtn.classList.remove('bg-primary', 'hover:bg-primary/90');
            joinCallBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            
            console.log(`‚úÖ "Join Call" button displayed (${callData.participantCount} participants)`);
        }
    } else {
        console.log('üìû No active call - showing audio/video buttons');
        
        // Show audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.remove('hidden');
            audioCallBtn.disabled = false;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.remove('hidden');
            videoCallBtn.disabled = false;
        }
        
        // Hide join button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('flex');
            joinCallBtn.classList.add('hidden');
            joinCallBtn.disabled = true;
        }
        
        console.log('‚úÖ Audio/Video buttons displayed');
    }
}

  // ============================================
  // UI FUNCTIONS
  // ============================================
  
  function openSidebar() {
    if (!sidebar || !sidebarOverlay) return;
    sidebar.classList.add('show');
    sidebarOverlay.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  function closeSidebar() {
    if (!sidebar || !sidebarOverlay) return;
    sidebar.classList.remove('show');
    sidebarOverlay.classList.remove('active');
    document.body.style.overflow = '';
  }

  function toggleSidebar() {
    if (!sidebar) return;
    sidebar.classList.contains('show') ? closeSidebar() : openSidebar();
  }

  function setupUserCardClick() {
    if (window.innerWidth <= 768) {
      document.querySelectorAll('.user-card').forEach(card => {
        card.addEventListener('click', closeSidebar, { passive: true });
      });
    }
  }

  function createProfilePictureElement(pfpUrl, username, size = 'w-10 h-10') {
    const initial = username ? username.charAt(0).toUpperCase() : 'U';
    const container = document.createElement('div');
    container.className = `${size} rounded-full overflow-hidden bg-slate-100 border-2 border-white shadow-sm flex-shrink-0`;
    
    if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
      const img = document.createElement('img');
      img.src = pfpUrl;
      img.alt = username;
      img.className = 'h-full w-full object-cover';
      img.loading = 'lazy';
      img.onerror = function() {
        this.onerror = null;
        container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-sm">${initial}</div>`;
      };
      container.appendChild(img);
    } else {
      container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-sm">${initial}</div>`;
    }
    
    return container;
  }

  function showReplyPreview(messageData) {
    replyingTo = messageData;
    const replyPreview = document.getElementById('replyPreview');
    const replyToUsername = document.getElementById('replyToUsername');
    const replyToMessage = document.getElementById('replyToMessage');
    
    if (replyPreview && replyToUsername && replyToMessage) {
      replyToUsername.textContent = `Replying to ${messageData.username}`;
      replyToMessage.textContent = messageData.message;
      replyPreview.classList.remove('hidden');
      
      if (messageInput) messageInput.focus();
    }
  }

  function hideReplyPreview() {
    replyingTo = null;
    const replyPreview = document.getElementById('replyPreview');
    if (replyPreview) replyPreview.classList.add('hidden');
  }

  function createMessageElement(data, isCurrentUser) {
    const messageItem = document.createElement('div');
    messageItem.className = `message-item flex gap-2 items-start ${isCurrentUser ? 'flex-row-reverse' : ''} animate-fade-in-up`;
    messageItem.dataset.messageId = data.messageId || `msg-${Date.now()}-${Math.random()}`;
    
    const pfpContainer = createProfilePictureElement(data.pfpUrl, data.username, 'w-8 h-8 sm:w-10 sm:h-10');
    const messageContent = document.createElement('div');
    messageContent.className = `flex flex-col ${isCurrentUser ? 'items-end' : 'items-start'} flex-1 min-w-0`;

    const headerDiv = document.createElement('div');
    headerDiv.className = `flex items-center gap-1.5 sm:gap-2 mb-1 px-1 ${isCurrentUser ? 'flex-row-reverse' : ''}`;
    
    const usernameSpan = document.createElement('span');
    usernameSpan.className = 'text-xs sm:text-sm font-semibold text-gray-900 truncate';
    usernameSpan.textContent = data.username || 'User';
    
    const timestampSpan = document.createElement('span');
    timestampSpan.className = 'text-[10px] sm:text-xs text-gray-400 whitespace-nowrap';
    timestampSpan.textContent = data.timestamp ? formatTimestamp(data.timestamp) : 'Just now';
    
    headerDiv.appendChild(usernameSpan);
    headerDiv.appendChild(timestampSpan);
    messageContent.appendChild(headerDiv);

    const bubbleWrapper = document.createElement('div');
    bubbleWrapper.className = `flex items-center gap-1`;

    const messageBubble = document.createElement('div');
    messageBubble.className = `px-3 sm:px-4 py-2 rounded-2xl ${isCurrentUser ? 'bg-primary text-white' : 'bg-gray-100 text-gray-900'} break-words text-sm sm:text-base max-w-full`;

    if (data.replyTo) {
      const quotedDiv = document.createElement('div');
      quotedDiv.className = `quoted-message ${isCurrentUser ? '' : 'quoted-message-light'}`;
      
      const quotedUsername = document.createElement('div');
      quotedUsername.className = `text-xs font-semibold mb-1 ${isCurrentUser ? 'text-blue-200' : 'text-primary'}`;
      quotedUsername.textContent = data.replyTo.username;
      
      const quotedText = document.createElement('div');
      quotedText.className = `text-xs ${isCurrentUser ? 'text-white/80' : 'text-gray-600'} break-words`;
      quotedText.textContent = data.replyTo.message;
      
      quotedDiv.appendChild(quotedUsername);
      quotedDiv.appendChild(quotedText);
      messageBubble.appendChild(quotedDiv);
    }

    const messageText = document.createElement('div');
    messageText.className = 'text-sm sm:text-base break-words';
    messageText.innerHTML = escapeHtml(data.message || '');
    messageBubble.appendChild(messageText);

    const replyBtn = document.createElement('button');
    replyBtn.className = 'reply-btn p-1 sm:p-1.5 hover:bg-gray-100 rounded-full transition-colors flex-shrink-0';
    replyBtn.title = 'Reply';
    replyBtn.innerHTML = '<span class="material-symbols-outlined text-gray-400 text-base sm:text-lg">reply</span>';
    replyBtn.addEventListener('click', () => {
      showReplyPreview({
        messageId: messageItem.dataset.messageId,
        username: data.username,
        message: data.message,
        userId: data.userId
      });
    }, { passive: true });

    // Current user: reply button left, bubble right
    // Other users: bubble left, reply button right
    if (isCurrentUser) {
      bubbleWrapper.appendChild(replyBtn);
      bubbleWrapper.appendChild(messageBubble);
    } else {
      bubbleWrapper.appendChild(messageBubble);
      bubbleWrapper.appendChild(replyBtn);
    }

    messageContent.appendChild(bubbleWrapper);
    messageItem.appendChild(pfpContainer);
    messageItem.appendChild(messageContent);
    
    return messageItem;
  }

  // ============================================
  // CONFIRMATION DIALOG
  // ============================================
  
  function showConfirmationDialog() {
    return new Promise((resolve) => {
      const overlay = document.getElementById('confirmationOverlay');
      if (!overlay) return resolve(false);
      
      const dialogHTML = `
        <div class="confirmation-overlay">
          <div class="confirmation-dialog">
            <div style="text-align: center; margin-bottom: 1rem;">
              <div style="width: 64px; height: 64px; margin: 0 auto 1rem; background: #fef2f2; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                <span class="material-symbols-outlined" style="font-size: 32px; color: #dc2626;">warning</span>
              </div>
              <h3 style="font-size: 1.25rem; font-weight: 700; margin-bottom: 0.5rem; color: #1f2937;">Leave Chat Room?</h3>
              <p style="color: #6b7280; font-size: 0.95rem; line-height: 1.5;">
                You're currently in an active chat room. If you leave, you'll be disconnected from the conversation.
              </p>
            </div>
            <div class="confirmation-buttons">
              <button class="btn-stay" id="btnStay">Stay Here</button>
              <button class="btn-leave" id="btnLeave">Leave</button>
            </div>
          </div>
        </div>
      `;
      
      overlay.innerHTML = dialogHTML;
      overlay.style.display = 'flex';
      
      const btnStay = document.getElementById('btnStay');
      const btnLeave = document.getElementById('btnLeave');
      
      if (btnStay) {
        btnStay.addEventListener('click', () => {
          overlay.style.display = 'none';
          resolve(false);
        }, { once: true });
      }
      
     if (btnLeave) {
  btnLeave.addEventListener('click', async () => {
    console.log('‚úÖ User confirmed leaving via dialog - starting cleanup');
    overlay.style.display = 'none';
    
    // CRITICAL: Clean up background call FIRST
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    
    if (activeCallStr) {
      console.log('üìû Active call detected - cleaning up');
      
      try {
        const callData = JSON.parse(activeCallStr);
        
        // 1. Emit leave_call to server
        if (socketInstance && socketInstance.connected) {
          console.log('üì§ Emitting leave_call to server...');
          socketInstance.emit('leave_call', { callId: callData.callId });
          
          // Wait for server to process
          await new Promise(resolve => setTimeout(resolve, 500));
          console.log('‚úÖ Leave_call emitted and processed');
        }
        
        // 2. Clear all call-related storage
        localStorage.removeItem(ACTIVE_CALL_KEY);
        sessionStorage.removeItem('hasBackgroundCall');
        sessionStorage.removeItem('returningFromCall');
        sessionStorage.removeItem('backgroundCallMode');
        sessionStorage.removeItem('returningToBackgroundCall');
        
        console.log('‚úÖ Background call destroyed');
        
      } catch (e) {
        console.error('‚ùå Failed during call cleanup:', e);
      }
    }
    
    // 3. Leave chat room
    if (socketInstance && socketInstance.connected) {
      console.log('üì§ Emitting leave_room...');
      socketInstance.emit('leave_room');
      
      // Wait for server to process
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    // 4. Clear chat state
    clearChatState();
    
    resolve(true);
    
    // 5. Navigate - this will handle both iframe and standalone cases
    setTimeout(() => {
      console.log('‚úÖ Cleanup complete - initiating navigation');
      cleanupParentCallPage();
    }, 100);
    
  }, { once: true });
}
    });
  }

  // ============================================
  // BACK BUTTON HANDLER
  // ============================================
  
  function setupBackButtonHandler() {
    history.pushState({ page: 'chat' }, '', window.location.href);
    
    window.addEventListener('popstate', async (event) => {
      if (backButtonHandled) return;
      
      console.log('‚¨ÖÔ∏è Back button pressed');
      history.pushState({ page: 'chat' }, '', window.location.href);
      
      const shouldLeave = await showConfirmationDialog();
      
      if (shouldLeave) {
        console.log('‚úÖ User confirmed leaving');
        backButtonHandled = true;
        
        if (socketInstance?.connected) {
          socketInstance.emit('leave_room');
        }
        
        clearChatState();
        window.location.href = '/mood.html';
      } else {
        console.log('‚ùå User staying in chat');
      }
    });
  }

  const updateTimer = () => {
    if (!serverExpiresAt) {
      console.warn('‚ö†Ô∏è No server expiresAt available');
      if (timeRemaining) {
        timeRemaining.textContent = '-- remaining';
      }
      return;
    }
    
    // CRITICAL: Always use server-adjusted time
    const clientNow = Date.now();
    const serverNow = clientNow + serverClockOffset;
    const remaining = Math.max(0, serverExpiresAt - serverNow);
    
    const minutes = Math.floor(remaining / 60000);
    const seconds = Math.floor((remaining % 60000) / 1000);
    
    if (timeRemaining) {
      timeRemaining.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} remaining`;
    }
    
    // Debug log every 10 seconds
    if (Math.floor(serverNow / 10000) !== Math.floor((serverNow - 1000) / 10000)) {
      console.log(`‚è∞ Timer: ${minutes}:${seconds.toString().padStart(2, '0')} (offset: ${(serverClockOffset/1000).toFixed(1)}s)`);
    }
    
    if (remaining === 0) {
      console.error('‚ùå Room expired - redirecting');
      if (timerInterval) clearInterval(timerInterval);
      toast('Room has expired', 'warning');
      clearChatState();
      setTimeout(() => window.location.href = '/mood.html', 2000);
    }
  };

  // ============================================
  // SOCKET EVENT HANDLERS
  // ============================================
  
  function setupSocketHandlers() {
    if (!socketInstance) return;
    
    
    socketInstance.on('cached_call_valid', (data) => {
    console.log('‚úÖ Cached call validated by server:', data.callId);
    console.log(`   Showing modal for call from ${data.callerUsername}`);
    
    showCachedCallModal(data);
});

socketInstance.on('cached_call_invalid', (data) => {
    console.log('‚ùå Cached call invalid:', data.callId);
    localStorage.removeItem(CACHED_CALL_KEY);
    console.log('üóëÔ∏è Cleared invalid cached call');
});
    
    socketInstance.on('connect', () => {
      console.log('üîå Socket connected:', socketInstance.id);
      
      firebase.auth().currentUser?.getIdToken().then(idToken => {
        socketInstance.emit('authenticate', {
          token: idToken,
          userId: currentUser.userId
        });
      }).catch(err => {
        console.error('‚ùå Failed to get token:', err);
      });
    });

socketInstance.on('authenticated', async () => {
  console.log('‚úÖ Authenticated');
  
  // CRITICAL: Request room data from server to get clock sync
  const roomStr = localStorage.getItem('currentRoom');
  if (roomStr) {
    try {
      const localRoomData = JSON.parse(roomStr);
      console.log('üì¶ Requesting fresh room data for clock sync...');
      
      socketInstance.emit('request_room_sync', { roomId: localRoomData.roomId });
      
    } catch (e) {
      console.error('‚ùå Failed to parse room data:', e);
    }
  }
  
  startCachedCallMonitoring();
  socketInstance.emit('join_room', { roomId: roomData.roomId });
});


socketInstance.on('call_created', (data) => {
  console.log('üìû ========================================');
  console.log('üìû CALL_CREATED EVENT RECEIVED');
  console.log('üìû ========================================');
  console.log(`   callId: ${data.callId}`);
  console.log(`   callType: ${data.callType}`);
  console.log(`   isInitiator: ${data.isInitiator}`);
  
  // Only navigate if we're the initiator
  if (data.isInitiator) {
    console.log('‚úÖ We initiated this call - navigating to call page');
    
    // Mark that we're navigating to call
    navigatingToCall = true;
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading');
      audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading');
      videoCallBtn.disabled = false;
    }
    
    // Save chat state
    saveChatState(roomData.roomId, messagesCache);
    sessionStorage.setItem('returningFromCall', 'true');
    
    // Store call data
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
      callId: data.callId,
      roomId: roomData.roomId,
      callType: data.callType,
      users: data.participants || []
    }));
    
    console.log(`‚úÖ Stored call data, navigating to call.html`);
    console.log('üìû ========================================\n');
    
    // Navigate to call page
    window.location.href = '/call.html';
  } else {
    console.log('‚ÑπÔ∏è Call created by someone else - staying in chat, showing JOIN button');
    console.log('üìû ========================================\n');
  }
});


socketInstance.on('room_joined', (data) => {
  console.log('‚úÖ ========================================');
  console.log('‚úÖ ROOM_JOINED EVENT RECEIVED');
  console.log('‚úÖ ========================================');
  console.log(`   roomId: ${data.roomId}`);
  
  // CRITICAL: Sync server time and expiry
  const clientNow = Date.now();
  
  if (data.serverTime) {
    serverClockOffset = data.serverTime - clientNow;
    console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
    console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
    console.log(`   ‚è∞ CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);
    
    if (Math.abs(serverClockOffset) > 5000) {
      console.warn(`‚ö†Ô∏è WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
    }
  } else {
    console.warn('‚ö†Ô∏è No serverTime in room_joined, assuming no clock skew');
    serverClockOffset = 0;
  }
  
  if (data.expiresAt) {
    serverExpiresAt = data.expiresAt;
    
    const serverNow = clientNow + serverClockOffset;
    const timeRemaining = data.expiresAt - serverNow;
    
    console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
    console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
    console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);
    
    // Update localStorage with synced data
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const localRoomData = JSON.parse(roomStr);
        localRoomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(localRoomData));
        console.log('‚úÖ Updated localStorage with server expiry time');
      } catch (e) {
        console.error('‚ùå Failed to update localStorage:', e);
      }
    }
  } else {
    console.error('‚ùå No expiresAt in room_joined data!');
  }
  
  // Handle chat history
  if (data.chatHistory?.length > 0) {
    console.log(`üìú Loading ${data.chatHistory.length} messages`);
    
    const existingIds = new Set(messagesCache.map(m => m.messageId || `${m.userId}-${m.timestamp}`));
    
    data.chatHistory.forEach(msg => {
      const msgId = msg.messageId || `${msg.userId}-${msg.timestamp}`;
      if (existingIds.has(msgId)) return;
      
      const isCurrentUser = msg.userId === currentUser.userId;
      const msgEl = createMessageElement(msg, isCurrentUser);
      messagesList?.appendChild(msgEl);
      messagesCache.push(msg);
    });
    
    if (messagesList) {
      messagesList.scrollTop = messagesList.scrollHeight;
    }
    
    saveChatState(roomData.roomId, messagesCache);
  }
  
  // Handle active call state (for call buttons)
  if (data.activeCall) {
    console.log('üìû Active call in room detected');
    
    // CRITICAL FIX: Store activeCallInRoom so Join button has data
    activeCallInRoom = {
      callId: data.activeCall.callId,
      callType: data.activeCall.callType,
      participantCount: data.activeCall.participantCount
    };
    console.log('üíæ Stored activeCallInRoom:', activeCallInRoom);
    
    updateCallButtonState(true, data.activeCall);
  } else {
    console.log('üìû No active call in room');
    activeCallInRoom = null;
    updateCallButtonState(false);
  }
  
  // Start timer updates immediately with server-synced data
  console.log('‚è∞ Starting timer updates with server-synced time...');
  updateTimer();
  
  console.log('‚úÖ ========================================\n');
});


socketInstance.on('room_sync_data', (data) => {
  console.log('‚è∞ ========================================');
  console.log('‚è∞ ROOM SYNC DATA RECEIVED');
  console.log('‚è∞ ========================================');
  
  const clientNow = Date.now();
  
  if (!data.serverTime) {
    console.warn('‚ö†Ô∏è No serverTime in sync data, assuming no clock skew');
    data.serverTime = clientNow;
  }
  
  // Calculate clock offset
  serverClockOffset = data.serverTime - clientNow;
  
  console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
  console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
  console.log(`   ‚è∞ CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);
  
  if (Math.abs(serverClockOffset) > 5000) {
    console.warn(`‚ö†Ô∏è WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
    console.warn(`   Timer will be adjusted to compensate`);
  }
  
  if (data.expiresAt) {
    serverExpiresAt = data.expiresAt;
    
    // Calculate time remaining using server-adjusted time
    const serverNow = clientNow + serverClockOffset;
    const timeRemaining = data.expiresAt - serverNow;
    
    console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
    console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
    console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);
    
    // Update localStorage with synced data
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const localRoomData = JSON.parse(roomStr);
        localRoomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(localRoomData));
        console.log('‚úÖ Updated localStorage with server expiry time');
      } catch (e) {
        console.error('‚ùå Failed to update localStorage:', e);
      }
    }
  }
  
  console.log('‚è∞ ========================================\n');
  
  // Force timer update with new data
  updateTimer();
});

socketInstance.on('room_expired', (data) => {
  console.error('üí• ========================================');
  console.error('üí• ROOM_EXPIRED EVENT RECEIVED FROM SERVER');
  console.error('üí• ========================================');
  console.error(`   roomId: ${data.roomId}`);
  console.error(`   message: ${data.message}`);
  console.error(`   Server says room expired at: ${new Date().toISOString()}`);
  
  if (serverExpiresAt) {
    const serverExpiry = new Date(serverExpiresAt).toISOString();
    const clientNow = new Date().toISOString();
    const serverNow = new Date(Date.now() + serverClockOffset).toISOString();
    console.error(`   expiresAt was: ${serverExpiry}`);
    console.error(`   Client time now: ${clientNow}`);
    console.error(`   Server time now (adjusted): ${serverNow}`);
  }
  
  console.error('üí• ========================================\n');
  
  if (timerInterval) clearInterval(timerInterval);
  toast(data.message || 'Room has expired', 'warning');
  
  // Clear all storage
  clearChatState();
  localStorage.removeItem(ACTIVE_CALL_KEY);
  sessionStorage.removeItem('hasBackgroundCall');
  sessionStorage.removeItem('returningFromCall');
  
  // Navigate and cleanup parent if in iframe
  setTimeout(() => {
    cleanupParentCallPage();
  }, 2000);
});

socketInstance.on('room_expiring_soon', (data) => {
  console.warn('‚ö†Ô∏è ========================================');
  console.warn('‚ö†Ô∏è ROOM EXPIRING SOON');
  console.warn('‚ö†Ô∏è ========================================');
  console.warn(`   Expires in: ${data.expiresIn / 1000} seconds`);
  console.warn(`   expiresAt: ${new Date(data.expiresAt).toISOString()}`);
  
  const clientNow = Date.now();
  const serverNow = clientNow + serverClockOffset;
  const remaining = data.expiresAt - serverNow;
  
  console.warn(`   Client now: ${new Date(clientNow).toISOString()}`);
  console.warn(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
  console.warn(`   Remaining (adjusted): ${(remaining / 1000).toFixed(1)}s`);
  console.warn('‚ö†Ô∏è ========================================\n');
  
  toast('Room expiring soon!', 'warning');
});

socketInstance.on('room_expired', (data) => {
  console.error('üí• Room expired event from server');
  if (timerInterval) clearInterval(timerInterval);
  
  // CRITICAL: Clear active call to remove floating button
  localStorage.removeItem('activeCall');
  sessionStorage.removeItem('hasBackgroundCall');
  
  toast('Room has expired', 'warning');
  clearChatState();
  setTimeout(() => window.location.href = '/mood.html', 2000);
});

socketInstance.on('error', (data) => {
  console.error('‚ùå Socket error:', data);
  console.error('   Error code:', data.code);
  console.error('   Error message:', data.message);
  
  // CRITICAL FIX: Handle CALL_ALREADY_ACTIVE error - auto-join instead
  if (data.code === 'CALL_ALREADY_ACTIVE') {
    console.log('üîÑ ========================================');
    console.log('üîÑ CALL_ALREADY_ACTIVE ERROR HANDLING');
    console.log('üîÑ ========================================');
    console.log(`   Existing callId: ${data.callId}`);
    console.log(`   callType: ${data.callType}`);
    console.log(`   participantCount: ${data.participantCount}`);
    
    // Clear loading states from call initiation
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading');
      audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading');
      videoCallBtn.disabled = false;
    }
    isInitiatingCall = false;
    
    // Store the active call info
    activeCallInRoom = {
      callId: data.callId,
      callType: data.callType || 'audio',
      participantCount: data.participantCount || 1
    };
    console.log('üíæ Stored activeCallInRoom:', activeCallInRoom);
    
    // Update UI to show join button
    updateCallButtonState(true, activeCallInRoom);
    
    // Show friendly message
    toast('A call is already active. Click "Join Call" to join.', 'success');
    console.log('üîÑ ========================================\n');
    return;
  }
  
  if (data.code === 'ROOM_NOT_FOUND' || data.code === 'NOT_IN_ROOM') {
    toast('Room no longer available', 'error');
    
    // Clear all storage
    clearChatState();
    localStorage.removeItem(ACTIVE_CALL_KEY);
    sessionStorage.removeItem('hasBackgroundCall');
    sessionStorage.removeItem('returningFromCall');
    
    // Navigate and cleanup parent if in iframe
    setTimeout(() => {
      cleanupParentCallPage();
    }, 2000);
  } else {
    toast(data.message || 'An error occurred', 'error');
  }
});

    socketInstance.on('chat_message', (data) => {
      if (!data.messageId) {
        data.messageId = `msg-${data.userId}-${data.timestamp || Date.now()}`;
      }
      
      const isCurrentUser = data.userId === currentUser.userId;
      const msgEl = createMessageElement(data, isCurrentUser);
      
      if (messagesList) {
        messagesList.appendChild(msgEl);
        messagesList.scrollTop = messagesList.scrollHeight;
      }
      
      messagesCache.push(data);
      saveChatState(roomData.roomId, messagesCache);
    });

    socketInstance.on('user_left', (data) => {
      const msgEl = document.createElement('div');
      msgEl.className = 'text-center text-xs sm:text-sm text-gray-400 my-2';
      msgEl.textContent = `${data.username || 'A user'} left the room`;
      messagesList?.appendChild(msgEl);

      if (onlineCount && data.remainingUsers !== undefined) {
        onlineCount.textContent = `${data.remainingUsers} Online`;
      }

      if (data.remainingUsers <= 1) {
        toast('Room closing...', 'warning');
        clearChatState();
        setTimeout(() => window.location.href = '/mood.html', 2000);
      }
    });

socketInstance.on('left_room', (data) => {
  console.log('üëã Received left_room confirmation from server');
  toast('Left room', 'success');
  
  // CRITICAL: Don't clear storage here - already done in leave button handler
  // Just disconnect socket
  if (socketInstance) {
    socketInstance.disconnect();
  }
  
  console.log('‚úÖ Socket disconnected after leaving room');
});

socketInstance.on('incoming_call', (data) => {
  console.log('üìû ========================================');
  console.log('üìû INCOMING_CALL EVENT RECEIVED');
  console.log('üìû ========================================');
  console.log(`   Caller: ${data.callerUsername}`);
  console.log(`   Call ID: ${data.callId}`);
  console.log(`   Type: ${data.callType}`);
  
  // CRITICAL: Cache the call immediately
  const cachedCall = {
    callId: data.callId,
    callerUsername: data.callerUsername,
    callerPfp: data.callerPfp,
    callType: data.callType,
    roomId: data.roomId,
    timestamp: Date.now()
  };
  
  try {
    localStorage.setItem(CACHED_CALL_KEY, JSON.stringify(cachedCall));
    console.log('üíæ Call cached to localStorage');
  } catch (e) {
    console.error('‚ùå Failed to cache call:', e);
  }
  
  // Set pending call data
  pendingCallData = data;
  
  // Update modal UI
  const callerName = document.getElementById('callerName');
  const callType = document.getElementById('callType');
  const callerAvatar = document.getElementById('callerAvatar');
  
  if (callerName) callerName.textContent = `${data.callerUsername} is calling`;
  if (callType) callType.textContent = data.callType === 'video' ? 'Video Call' : 'Audio Call';
  if (callerAvatar) {
    callerAvatar.innerHTML = '';
    const pfp = createProfilePictureElement(data.callerPfp, data.callerUsername, 'w-full h-full');
    callerAvatar.appendChild(pfp);
  }
  
  // Show modal after 2 second delay
  setTimeout(() => {
    if (pendingCallData && pendingCallData.callId === data.callId) {
      incomingCallModal?.classList.remove('hidden');
      console.log(`‚úÖ Showing incoming call modal after 2s delay`);
    } else {
      console.log(`üìû Call already handled, skipping modal display`);
    }
  }, 2000);
  
  console.log('üìû ========================================\n');
});

    socketInstance.on('call_accepted', (data) => {
    console.log('‚úÖ Call accepted:', data);
    
    // Clear loading states
    isInitiatingCall = false;
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.classList.remove('calling');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.classList.remove('calling');
        videoCallBtn.disabled = false;
    }
    
    navigatingToCall = true;
    
    saveChatState(roomData.roomId, messagesCache);
    sessionStorage.setItem('returningFromCall', 'true');
    
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
        callId: data.callId,
        roomId: roomData.roomId,
        callType: data.callType,
        users: data.users
    }));
    
    console.log('üöÄ Navigating to call');
    window.location.href = '/call.html';
});

socketInstance.on('call_declined', (data) => {
    console.log('‚ùå Call was declined');
    
    // Clear loading states
    toast('Call was declined', 'warning');
    isInitiatingCall = false;
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.classList.remove('calling');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.classList.remove('calling');
        videoCallBtn.disabled = false;
    }
});

    socketInstance.on('call_declined', (data) => {
      toast('Call was declined', 'warning');
      isInitiatingCall = false;
      audioCallBtn?.classList.remove('calling');
      videoCallBtn?.classList.remove('calling');
    });
    
    socketInstance.on('call_state_update', (data) => {
  console.log('üìû Call state update:', data);
  
  if (data.isActive && data.participantCount > 0) {
    // CRITICAL FIX: Store call data so JOIN button can access it
    activeCallInRoom = {
      callId: data.callId,
      callType: data.callType,
      participantCount: data.participantCount
    };
    console.log(`üìû Stored active call: ${data.callId} with ${data.participantCount} participants`);
    
    updateCallButtonState(true, data);
  } else {
    // CRITICAL FIX: Clear call data when call ends
    activeCallInRoom = null;
    console.log('üìû Cleared active call - no participants');
    
    updateCallButtonState(false);
  }
});


    socketInstance.on('call_ended_notification', (data) => {
      console.log('üìû Call ended:', data.callId);
      updateCallButtonState(false);
    });

socketInstance.on('join_existing_call_success', (data) => {
  console.log('‚úÖ ========================================');
  console.log('‚úÖ JOIN_EXISTING_CALL_SUCCESS');
  console.log('‚úÖ ========================================');
  console.log(`   callId: ${data.callId}`);
  console.log(`   callType: ${data.callType}`);
  console.log(`   roomId: ${data.roomId}`);
  
  // Remove loading states
  if (joinCallBtn) {
    joinCallBtn.classList.remove('join-btn-loading');
    joinCallBtn.disabled = false;
  }
  if (acceptCallBtn) {
    acceptCallBtn.classList.remove('join-btn-loading');
    acceptCallBtn.disabled = false;
  }
  
  // Mark navigating
  navigatingToCall = true;
  
  // Save chat state (if not already saved)
  saveChatState(roomData.roomId, messagesCache);
  sessionStorage.setItem('returningFromCall', 'true');
  
  // Ensure call data is stored (should already be, but verify)
  const storedCall = localStorage.getItem(ACTIVE_CALL_KEY);
  console.log(`   Stored call data exists: ${!!storedCall}`);
  
  if (!storedCall) {
    console.warn('‚ö†Ô∏è No stored call data - storing now');
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
      callId: data.callId,
      roomId: data.roomId,
      callType: data.callType,
      users: []
    }));
  }
  
  console.log('üöÄ Navigating to call page in 500ms...');
  console.log('‚úÖ ========================================\n');
  
  // Navigate to call with small delay to ensure storage is written
  setTimeout(() => {
    window.location.href = '/call.html';
  }, 500);
});
  }

  // ============================================
  // EVENT LISTENERS
  // ============================================
  
  function setupEventListeners() {
    // Sidebar
    sidebarToggle?.addEventListener('click', toggleSidebar, { passive: true });
    sidebarClose?.addEventListener('click', closeSidebar, { passive: true });
    sidebarOverlay?.addEventListener('click', closeSidebar, { passive: true });
    
    // Reply
    cancelReplyBtn?.addEventListener('click', hideReplyPreview, { passive: true });
    
    if (audioCallBtn) {
    audioCallBtn.addEventListener('click', () => {
        if (isInitiatingCall) {
            console.log('‚ö†Ô∏è Call already being initiated, ignoring click');
            return;
        }
        
        console.log('üìû Initiating audio call...');
        isInitiatingCall = true;
        
        // Add loading state
        audioCallBtn.classList.add('call-btn-loading');
        audioCallBtn.disabled = true;
        if (videoCallBtn) {
            videoCallBtn.classList.add('calling');
            videoCallBtn.disabled = true;
        }
        
        socketInstance?.emit('initiate_call', {
            roomId: roomData.roomId,
            callType: 'audio'
        });
        
        console.log('üì§ Audio call initiation sent to server');
        toast('Calling...', 'success');
        
        // Timeout after 30 seconds
        setTimeout(() => {
            if (isInitiatingCall) {
                console.log('‚è∞ Call initiation timeout (30s)');
                isInitiatingCall = false;
                audioCallBtn.classList.remove('call-btn-loading');
                audioCallBtn.disabled = false;
                if (videoCallBtn) {
                    videoCallBtn.classList.remove('calling');
                    videoCallBtn.disabled = false;
                }
                toast('Call timeout - no response', 'warning');
            }
        }, 30000);
    }, { passive: true });
}

if (videoCallBtn) {
    videoCallBtn.addEventListener('click', () => {
        if (isInitiatingCall) {
            console.log('‚ö†Ô∏è Call already being initiated, ignoring click');
            return;
        }
        
        console.log('üìû Initiating video call...');
        isInitiatingCall = true;
        
        // Add loading state
        videoCallBtn.classList.add('call-btn-loading');
        videoCallBtn.disabled = true;
        if (audioCallBtn) {
            audioCallBtn.classList.add('calling');
            audioCallBtn.disabled = true;
        }
        
        socketInstance?.emit('initiate_call', {
            roomId: roomData.roomId,
            callType: 'video'
        });
        
        console.log('üì§ Video call initiation sent to server');
        toast('Calling...', 'success');
        
        // Timeout after 30 seconds
        setTimeout(() => {
            if (isInitiatingCall) {
                console.log('‚è∞ Call initiation timeout (30s)');
                isInitiatingCall = false;
                videoCallBtn.classList.remove('call-btn-loading');
                videoCallBtn.disabled = false;
                if (audioCallBtn) {
                    audioCallBtn.classList.remove('calling');
                    audioCallBtn.disabled = false;
                }
                toast('Call timeout - no response', 'warning');
            }
        }, 30000);
    }, { passive: true });
}

    if (videoCallBtn) {
      videoCallBtn.addEventListener('click', () => {
        if (isInitiatingCall) return;
        isInitiatingCall = true;
        audioCallBtn?.classList.add('calling');
        videoCallBtn.classList.add('calling');
        
        socketInstance?.emit('initiate_call', {
          roomId: roomData.roomId,
          callType: 'video'
        });
        toast('Calling...', 'success');
        
        setTimeout(() => {
          if (isInitiatingCall) {
            isInitiatingCall = false;
            audioCallBtn?.classList.remove('calling');
            videoCallBtn.classList.remove('calling');
          }
        }, 30000);
      }, { passive: true });
    }

if (joinCallBtn) {
    joinCallBtn.addEventListener('click', () => {
        console.log('üîò ========================================');
        console.log('üîò JOIN CALL BUTTON CLICKED');
        console.log('üîò ========================================');
        
        // Check if this is "Back to Call" or "Join Call"
        const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
        const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomData?.roomId;
        
        console.log(`   activeCallStr exists: ${!!activeCallStr}`);
        console.log(`   userInCall: ${userInCall}`);
        console.log(`   activeCallInRoom exists: ${!!activeCallInRoom}`);
        
        if (userInCall) {
            // User is already in call - show call UI in iframe/overlay
            console.log('üìû BACK TO CALL MODE');
            
            const activeCallData = JSON.parse(activeCallStr);
            console.log(`   callId: ${activeCallData.callId}`);
            console.log(`   Call is running in background - will hide chat overlay`);
            
            if (window.parent && window.parent !== window) {
                console.log('üì± We are in iframe - posting message to parent');
                window.parent.postMessage({ action: 'hideChat' }, '*');
            } else {
                console.log('‚ö†Ô∏è Not in iframe - navigating directly');
                window.location.href = '/call.html';
            }
            
            console.log('üîò ========================================\n');
        } else {
            // No active call - join existing call
            console.log('üìû JOIN EXISTING CALL MODE');
            
            if (!activeCallInRoom) {
                console.error('‚ùå activeCallInRoom is null/undefined!');
                console.log('   This should not happen - UI should not show Join button');
                toast('No active call to join', 'warning');
                console.log('üîò ========================================\n');
                return;
            }
            
            console.log(`   activeCallInRoom.callId: ${activeCallInRoom.callId}`);
            console.log(`   activeCallInRoom.callType: ${activeCallInRoom.callType}`);
            console.log(`   activeCallInRoom.participantCount: ${activeCallInRoom.participantCount}`);
            console.log(`   roomData.roomId: ${roomData.roomId}`);
            
            // Add loading state
            joinCallBtn.classList.add('join-btn-loading');
            joinCallBtn.disabled = true;
            console.log('‚è≥ Join button set to loading state');
            
            // CRITICAL FIX: Store call data BEFORE emitting join_existing_call
            const callDataToStore = {
                callId: activeCallInRoom.callId,
                roomId: roomData.roomId,
                callType: activeCallInRoom.callType,
                users: []
            };
            
            localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify(callDataToStore));
            console.log('üíæ Stored call data to localStorage (pre-join):');
            console.log('   ', JSON.stringify(callDataToStore, null, 2));
            
            const eventData = {
                callId: activeCallInRoom.callId,
                roomId: roomData.roomId
            };
            
            console.log('üì§ Emitting join_existing_call with data:');
            console.log('   ', JSON.stringify(eventData, null, 2));
            
            if (!socketInstance || !socketInstance.connected) {
                console.error('‚ùå Socket not connected!');
                toast('Connection lost. Please refresh the page.', 'error');
                joinCallBtn.classList.remove('join-btn-loading');
                joinCallBtn.disabled = false;
                console.log('üîò ========================================\n');
                return;
            }
            
            socketInstance.emit('join_existing_call', eventData);
            
            toast('Joining call...', 'success');
            console.log('‚úÖ Event emitted successfully');
            console.log('üîò ========================================\n');
        }
    }, { passive: true });
}

if (acceptCallBtn) {
  acceptCallBtn.addEventListener('click', () => {
    if (pendingCallData) {
      const callToAccept = pendingCallData;
      pendingCallData = null;
      
      console.log('‚úÖ ========================================');
      console.log('‚úÖ USER ACCEPTED INCOMING CALL');
      console.log('‚úÖ ========================================');
      console.log(`   callId: ${callToAccept.callId}`);
      
      // Clear cached call
      localStorage.removeItem(CACHED_CALL_KEY);
      
      // Hide modal
      incomingCallModal?.classList.add('hidden');
      
      // Mark navigating
      navigatingToCall = true;
      
      // Add loading state
      acceptCallBtn.classList.add('join-btn-loading');
      acceptCallBtn.disabled = true;
      
      // Save chat state
      saveChatState(roomData.roomId, messagesCache);
      sessionStorage.setItem('returningFromCall', 'true');
      
      // CRITICAL FIX: Store call data BEFORE emitting join_existing_call
      localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
        callId: callToAccept.callId,
        roomId: roomData.roomId,
        callType: callToAccept.callType,
        users: []
      }));
      console.log('üíæ Stored call data to localStorage (pre-join)');
      
      console.log('üì§ Emitting join_existing_call to server');
      
      // Use join_existing_call to ensure server adds us to participants list first
      socketInstance?.emit('join_existing_call', {
        callId: callToAccept.callId,
        roomId: roomData.roomId
      });
      
      console.log('‚úÖ Join request sent - will navigate on success');
      console.log('‚úÖ ========================================\n');
      
      // Don't navigate here - wait for join_existing_call_success event
    }
  }, { passive: true });
}

if (declineCallBtn) {
  declineCallBtn.addEventListener('click', () => {
    if (pendingCallData) {
      const callToDecline = pendingCallData;
      pendingCallData = null;
      
      console.log('‚ùå ========================================');
      console.log('‚ùå USER DECLINED INCOMING CALL');
      console.log('‚ùå ========================================');
      console.log(`   callId: ${callToDecline.callId}`);
      console.log(`   Call remains active - user can still join via JOIN button`);
      
      // Clear cached call
      localStorage.removeItem(CACHED_CALL_KEY);
      console.log('üóëÔ∏è Cleared cached call after decline');
      
      // Hide modal
      incomingCallModal?.classList.add('hidden');
      
      console.log('‚úÖ Modal dismissed - call still active in room');
      console.log('‚ùå ========================================\n');
    }
  }, { passive: true });
}

    // Message form
    if (messageForm) {
      messageForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const message = messageInput?.value.trim();
        if (!message) return;

        const messageData = {
          roomId: roomData.roomId,
          message: message
        };

        if (replyingTo) {
          messageData.replyTo = {
            messageId: replyingTo.messageId,
            username: replyingTo.username,
            message: replyingTo.message,
            userId: replyingTo.userId
          };
          hideReplyPreview();
        }

        socketInstance?.emit('chat_message', messageData);
        if (messageInput) messageInput.value = '';
      });
    }

leaveBtn?.addEventListener('click', async () => {
  console.log('üö™ Leave button clicked - starting cleanup sequence');
  stopCachedCallMonitoring();
  
  // CRITICAL: Check if there's a background call running
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  
  if (activeCallStr) {
    console.log('üìû Active call detected - cleaning up before leaving');
    
    try {
      const callData = JSON.parse(activeCallStr);
      
      // 1. Emit leave_call to server
      if (socketInstance && socketInstance.connected) {
        console.log('üì§ Emitting leave_call to server...');
        socketInstance.emit('leave_call', { callId: callData.callId });
        
        // Wait for server to process the leave_call
        await new Promise(resolve => setTimeout(resolve, 500));
        console.log('‚úÖ Leave_call processed');
      }
      
      // 2. Clear all call-related storage
      localStorage.removeItem(ACTIVE_CALL_KEY);
      sessionStorage.removeItem('hasBackgroundCall');
      sessionStorage.removeItem('returningFromCall');
      sessionStorage.removeItem('backgroundCallMode');
      sessionStorage.removeItem('returningToBackgroundCall');
      
      console.log('‚úÖ All call data cleared');
      
    } catch (e) {
      console.error('‚ùå Error during call cleanup:', e);
    }
  }
  
  // 3. Leave the chat room
  if (socketInstance && socketInstance.connected) {
    console.log('üì§ Emitting leave_room...');
    socketInstance.emit('leave_room');
    
    // Wait for server to process
    await new Promise(resolve => setTimeout(resolve, 300));
  }
  
  // 4. Clear chat state
  clearChatState();
  
  // 5. Navigate - this will handle both iframe and standalone cases
  console.log('‚úÖ Cleanup complete - initiating navigation');
  cleanupParentCallPage();
});

    // Visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        console.log('üì± Page hidden');
        saveChatState(roomData.roomId, messagesCache);
      } else {
        console.log('üì± Page visible');
      }
    });

window.addEventListener('beforeunload', (e) => {
  console.log('üö™ Chat page beforeunload event');
  stopCachedCallMonitoring();
  // CRITICAL: Check if in background call mode
  if (isInBackgroundCall) {
    console.log('üîí Background call active - preserving floating socket');
    saveChatState(roomData.roomId, messagesCache);
    
    // Don't disconnect floating socket - let it persist
    if (floatingCallSocket) {
      console.log('‚úÖ Keeping floating call socket alive');
    }
    
    // Only disconnect main chat socket
    if (socketInstance) {
      socketInstance.emit('leave_room');
      socketInstance.disconnect();
    }
    
    return;
  }
  
  if (navigatingToCall) {
    console.log('üîí Navigating to call - keeping socket');
    saveChatState(roomData.roomId, messagesCache);
    return;
  }
  
  console.log('üóëÔ∏è Normal chat exit - cleanup already done in leave handler');
  
  // Only disconnect sockets - cleanup was already done by leave button handlers
  if (socketInstance) {
    socketInstance.disconnect();
  }
  if (timerInterval) clearInterval(timerInterval);
});
  }

  // ============================================
  // INITIALIZATION
  // ============================================
  
  try {
  
  
    const isBackgroundCall = sessionStorage.getItem('backgroundCallMode') === 'true';
  
  if (!isBackgroundCall) {
    clearAllChatData();
  } else {
    console.log('üéà Background call mode detected - preserving call state');
    // Clear only the background call flag
    sessionStorage.removeItem('backgroundCallMode');
  }
  
    // CRITICAL: Clear all chat state on entry
    clearAllChatData();
    
    // Auth check
    await _Auth.requireAuth();
  } catch (err) {
    console.error('‚ùå Auth failed:', err);
    window.location.href = '/login.html';
    return;
  }
  
  
// CRITICAL: Initialize floating call popup elements early
console.log('üéà Pre-initializing floating call popup');

// Check if returning from call
const returningFromCall = sessionStorage.getItem('returningFromCall');
if (returningFromCall === 'true') {
  console.log('üîÑ Returning from call - popup will be shown after room_joined');
  console.log('üîç Active call check:', !!localStorage.getItem(ACTIVE_CALL_KEY));
}

  const roomDataStr = localStorage.getItem('currentRoom');
  if (!roomDataStr) {
    console.error('‚ùå No currentRoom in localStorage');
    toast('No active room found', 'error');
    setTimeout(() => window.location.href = '/mood.html', 1500);
    return;
  }

  try {
    roomData = JSON.parse(roomDataStr);
    console.log('üì¶ Loaded room data from localStorage:');
    console.log(`   roomId: ${roomData.roomId}`);
    
    // CRITICAL: Don't trust localStorage expiresAt - wait for server
    if (roomData.expiresAt) {
      console.log(`   LocalStorage expiresAt: ${new Date(roomData.expiresAt).toISOString()}`);
      console.log(`   ‚ö†Ô∏è Will be replaced with server time after connection`);
    } else {
      console.log(`   No expiresAt in localStorage - will get from server`);
    }
    
    if (!roomData.roomId) {
      throw new Error('Invalid room data: missing roomId');
    }
    checkForBackgroundCall();
  } catch (err) {
    console.error('‚ùå Invalid room data:', err);
    toast('Invalid room data', 'error');
    clearChatState();
    setTimeout(() => window.location.href = '/mood.html', 1500);
    return;
  }

  // Get Firebase user
  const firebaseUser = firebase.auth().currentUser;
  if (!firebaseUser) {
    window.location.href = '/login.html';
    return;
  }

  // Get current user data
  try {
    const userData = await _API.get('/api/users/me');
    currentUser = {
      userId: userData._id,
      username: userData.username,
      pfpUrl: userData.pfpUrl
    };
  } catch (err) {
    console.error('‚ùå Failed to get user data:', err);
    toast('Failed to load user data', 'error');
    setTimeout(() => window.location.href = '/login.html', 1500);
    return;
  }

  // Set initial call button state
  setInitialCallButtonState();

  // Render initial users
  if (usersList && Array.isArray(roomData.users)) {
    roomData.users.forEach(user => {
      const userCard = document.createElement('div');
      userCard.className = 'user-card flex items-center gap-2 sm:gap-3 p-2 sm:p-3 rounded-lg hover:bg-gray-50 transition-all cursor-pointer';
      
      const pfpElement = createProfilePictureElement(user.pfpUrl, user.username, 'w-10 h-10 sm:w-12 sm:h-12');
      
      const userInfo = document.createElement('div');
      userInfo.className = 'flex-1 min-w-0';
      
      const nameSpan = document.createElement('div');
      nameSpan.className = 'text-sm font-semibold truncate';
      nameSpan.textContent = user.username || 'User';
      
      const statusSpan = document.createElement('div');
      statusSpan.className = 'text-xs text-gray-500 flex items-center gap-1';
      statusSpan.innerHTML = '<span class="flex h-2 w-2 rounded-full bg-green-500 flex-shrink-0"></span> Online';
      
      userInfo.appendChild(nameSpan);
      userInfo.appendChild(statusSpan);
      
      userCard.appendChild(pfpElement);
      userCard.appendChild(userInfo);
      usersList.appendChild(userCard);
    });

    setupUserCardClick();

    if (onlineCount) {
      onlineCount.textContent = `${roomData.users.length} Online`;
    }
  }

  console.log('‚è∞ Starting timer interval (will update when server data arrives)');
  // Start timer interval (will show "--" until server data arrives)
  timerInterval = setInterval(updateTimer, 1000);
  updateTimer();

  // Initialize socket
  try {
    const idToken = await firebaseUser.getIdToken();
    const socketUrl = window.location.origin;
    
    socketInstance = io(socketUrl, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 500,
      reconnectionAttempts: 10,
      auth: { token: idToken },
      timeout: 10000
    });

    setupSocketHandlers();
  } catch (err) {
    console.error('‚ùå Socket initialization failed:', err);
    toast('Connection failed', 'error');
  }

  // Setup all event listeners
  setupEventListeners();

  // Setup back button handler
  setupBackButtonHandler();

  console.log('‚úÖ Chat initialization complete');

})();
</script>
</body>
</html>
