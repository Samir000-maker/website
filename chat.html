
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>MoodLog - Chat Room</title>
    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet"/>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#33bfcc",
                        "primary-dark": "#2aa5b0",
                        "accent": "#4facb8",
                        "surface-dark": "#0d1117",
                        "surface-mid": "#161b22",
                        "surface-card": "#1f2937",
                        "glass-border": "rgba(255, 255, 255, 0.08)",
                        "neon-glow": "rgba(51, 191, 204, 0.3)",
                    },
                    fontFamily: {
                        "display": ["Manrope", "sans-serif"]
                    },
                    boxShadow: {
                        "glow-cyan": "0 0 20px rgba(51, 191, 204, 0.15)",
                        "glow-neon": "0 0 25px rgba(51, 191, 204, 0.25), inset 0 0 15px rgba(51, 191, 204, 0.1)",
                        "glass": "0 8px 32px 0 rgba(0, 0, 0, 0.5)",
                        "inner-glow": "inset 0 1px 0 0 rgba(255, 255, 255, 0.05)",
                    },
                    backgroundImage: {
                        "main-bg": "radial-gradient(ellipse at top, #1a2332 0%, #0d1117 50%, #0a0e13 100%)",
                        "panel-gradient": "linear-gradient(180deg, rgba(255,255,255,0.04) 0%, rgba(255,255,255,0.01) 100%)",
                        "tech-grid": "linear-gradient(rgba(51, 191, 204, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(51, 191, 204, 0.03) 1px, transparent 1px)",
                    }
                },
            },
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .glass-panel {
                @apply bg-surface-mid/60 backdrop-blur-xl border border-glass-border shadow-glass relative;
            }
            .glass-panel::before {
                content: '';
                @apply absolute inset-0 rounded-[inherit] pointer-events-none;
                background: linear-gradient(160deg, rgba(255,255,255,0.06) 0%, transparent 50%, rgba(51,191,204,0.02) 100%);
            }
            .neon-border {
                @apply border border-primary/15 shadow-[0_0_15px_rgba(51,191,204,0.1)];
            }
            .glass-bubble-received {
                @apply bg-surface-card/80 backdrop-blur-md border border-white/5 shadow-lg;
            }
            .glass-bubble-sent {
                @apply bg-gradient-to-br from-primary/20 to-primary/10 backdrop-blur-md border border-primary/30 shadow-[0_4px_20px_rgba(51,191,204,0.12)];
            }
            .tech-pattern {
                background-image: var(--tech-grid);
                background-size: 40px 40px;
            }
            .custom-scrollbar::-webkit-scrollbar {
                width: 5px;
            }
            .custom-scrollbar::-webkit-scrollbar-track {
                background: rgba(255,255,255,0.02);
            }
            .custom-scrollbar::-webkit-scrollbar-thumb {
                @apply bg-primary/25 rounded-full hover:bg-primary/40 transition-colors;
            }
            .timer-glow {
                @apply bg-gradient-to-r from-red-500/20 to-red-600/20 border border-red-500/30 shadow-[0_0_15px_rgba(239,68,68,0.3)];
            }
        }
        
        body {
            font-family: 'Manrope', sans-serif;
            background: radial-gradient(ellipse at top, #1a2332 0%, #0d1117 50%, #0a0e13 100%);
        }
        
        /* Modal/Dialog Styles */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            animation: fadeIn 0.2s ease-out;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal-dialog {
            background: linear-gradient(160deg, rgba(31, 41, 55, 0.95) 0%, rgba(17, 24, 39, 0.98) 100%);
            border-radius: 1.5rem;
            padding: 2.5rem;
            max-width: 480px;
            width: 100%;
            border: 1px solid rgba(51, 191, 204, 0.15);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.8), 0 0 30px rgba(51, 191, 204, 0.1);
            transform: scale(0.95) translateY(20px);
            animation: slideUpModal 0.3s ease-out forwards;
            position: relative;
        }
        
        .modal-dialog::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: linear-gradient(160deg, rgba(255,255,255,0.05) 0%, transparent 50%);
            pointer-events: none;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUpModal {
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        .modal-icon-wrapper {
            width: 80px;
            height: 80px;
            margin: 0 auto 1.5rem;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(220, 38, 38, 0.1) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(239, 68, 68, 0.2);
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.15);
        }
        
        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }
        
        .modal-buttons button {
            flex: 1;
            padding: 1rem 1.5rem;
            border-radius: 1rem;
            font-weight: 700;
            font-size: 0.875rem;
            letter-spacing: 0.025em;
            transition: all 0.2s ease;
            border: 1px solid;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.1em;
        }
        
        .btn-stay {
            background: linear-gradient(135deg, #33bfcc 0%, #2aa5b0 100%);
            color: white;
            border-color: rgba(51, 191, 204, 0.3);
            box-shadow: 0 4px 15px rgba(51, 191, 204, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .btn-stay:hover {
            background: linear-gradient(135deg, #2aa5b0 0%, #258f9a 100%);
            box-shadow: 0 6px 20px rgba(51, 191, 204, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        .btn-stay:active {
            transform: translateY(0);
        }
        
        .btn-leave {
            background: rgba(31, 41, 55, 0.6);
            color: #d1d5db;
            border-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .btn-leave:hover {
            background: rgba(55, 65, 81, 0.7);
            color: #f3f4f6;
            border-color: rgba(255, 255, 255, 0.15);
        }
        
        .btn-leave:active {
            transform: scale(0.98);
        }
        
        /* Animations */
        @keyframes bounce-subtle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        
        .animate-bounce-subtle {
            animation: bounce-subtle 2s ease-in-out infinite;
        }
    </style>
</head>
<body class="text-gray-200 font-display overflow-x-hidden flex flex-col min-h-screen antialiased selection:bg-primary/30 selection:text-white">

<!-- Tech Grid Background -->
<div class="fixed inset-0 tech-pattern opacity-[0.15] pointer-events-none"></div>

<!-- Ambient Glow Effects -->
<div class="fixed top-0 left-1/4 w-96 h-96 bg-primary/5 rounded-full blur-3xl pointer-events-none"></div>
<div class="fixed bottom-0 right-1/4 w-96 h-96 bg-accent/5 rounded-full blur-3xl pointer-events-none"></div>

<!-- Header -->
<header class="w-full glass-panel sticky top-0 z-50 border-b border-white/5">
    <div class="max-w-[1400px] mx-auto flex items-center justify-between px-4 md:px-8 py-4">
        <div class="flex items-center gap-4 text-white">
            <div class="size-10 text-primary drop-shadow-[0_0_15px_rgba(51,191,204,0.6)]">
                <svg fill="currentColor" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
                    <path clip-rule="evenodd" d="M24 4H6V17.3333V30.6667H24V44H42V30.6667V17.3333H24V44Z" fill-rule="evenodd"></path>
                </svg>
            </div>
            <h2 class="text-2xl font-extrabold leading-tight tracking-tight text-transparent bg-clip-text bg-gradient-to-r from-white via-gray-200 to-gray-400">MoodLog</h2>
        </div>
        <div class="flex items-center gap-8">
            <nav class="hidden md:flex items-center gap-8">
                <a class="text-sm font-semibold text-gray-400 hover:text-white transition-all duration-300 hover:drop-shadow-[0_0_8px_rgba(255,255,255,0.3)]" href="#">Mood Journal</a>
                <a class="text-sm font-bold text-primary relative" href="#">
                    Chat Room
                    <span class="absolute -bottom-1.5 left-0 w-full h-0.5 bg-primary shadow-glow-cyan"></span>
                </a>
            </nav>
            <div class="relative group cursor-pointer">
                <div class="size-11 rounded-full bg-cover bg-center border border-white/20 ring-2 ring-transparent group-hover:ring-primary/40 transition-all duration-500 shadow-xl" style="background-image: url('https://lh3.googleusercontent.com/aida-public/AB6AXuB5MAvQBk2-MmJsxCR0C63gM8le2uKtYX_i7wV_aRTxxfLvEFgTiiZ7v36irbJ778KxT2g0txzKxPUQBUCmNCQ5E3A_HMjjzA-jj_V4hfnEhwJ3DWOBf_UwFoa3UeIrRomXxAE8E4CXEwiCMoUsHhOCXvyQ4nNIFv2xx7dQciqgdB0sF5tfqgXJCQo4VrDwafmkjj4rjIm1GEkttiDPLb17bhSZGkYmSIyXFw_x8J5r8ZmEgRdzukgJOtjMGsbc6hVqKwmKVfduH9mY');"></div>
                <div class="absolute inset-0 rounded-full bg-gradient-to-tr from-primary/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity"></div>
            </div>
        </div>
    </div>
</header>

<!-- Main Content -->
<main class="flex-grow flex flex-col max-w-[1400px] mx-auto w-full px-4 md:px-8 py-6 h-[calc(100vh-80px)] relative z-10">
    <!-- Breadcrumb -->
    <div class="flex items-center gap-2 pb-5">
        <a class="text-primary/70 hover:text-primary text-[10px] font-bold uppercase tracking-[0.2em] transition-colors" href="#">Community</a>
        <span class="text-gray-700 text-[10px]">‚Ä¢</span>
        <span class="text-gray-200 text-[10px] font-bold uppercase tracking-[0.2em]">Chat Room</span>
    </div>

    <!-- Chat Layout -->
    <div class="flex flex-col lg:flex-row gap-6 h-full min-h-0">
        <!-- Sidebar -->
        <aside class="hidden lg:flex flex-col w-80 glass-panel rounded-3xl overflow-hidden shrink-0 neon-border">
            <!-- Sidebar Header -->
            <div class="p-6 border-b border-white/5 bg-white/[0.02]">
                <h3 class="text-sm font-black text-white tracking-[0.1em] uppercase flex items-center gap-2">
                    Active Users
                    <span class="flex h-2 w-2 relative">
                        <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-emerald-400 opacity-75"></span>
                        <span class="relative inline-flex rounded-full h-2 w-2 bg-emerald-500 shadow-[0_0_10px_rgba(16,185,129,0.7)]"></span>
                    </span>
                </h3>
                <p class="text-[10px] text-gray-500 font-bold uppercase tracking-widest mt-1">12 Operational</p>
            </div>
            
            <!-- Users List -->
            <div class="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-3">
                <!-- User 1 -->
                <div class="flex items-center gap-3 p-3 rounded-xl hover:bg-white/[0.03] transition-all cursor-pointer group border border-transparent hover:border-white/5">
                    <div class="size-12 rounded-full bg-cover bg-center shrink-0 ring-2 ring-emerald-500/30 shadow-lg" style="background-image: url('https://lh3.googleusercontent.com/aida-public/AB6AXuC6RshlEAKTPScNiFAtmnIsu-OooA0vUTsbaWqn9F_C7ZnR54XHTwx6fM7-i1gLBbWcgwHrApR1InoURQ4ekwoQrxyry6QXtx9XZIDJGp4-0LblceL0SEGpdr40LOXyw9W-dyVOIiLMVkpzHVbER2s7T_oJoxoKiM1eGNy7yhMOpzNtpm3xDZ13h4tbI-uKshZidaN6za4mQ5oyAccCHBxF2CBvpnb2iMfeg8QCVQnwC4y4Ne14D2axIolIiFZSAzsQB-YR6_BJfU5n');"></div>
                    <div class="flex-1 min-w-0">
                        <div class="font-bold text-sm text-white truncate">Sarah M.</div>
                        <div class="text-xs text-gray-500 flex items-center gap-1">
                            <span>Feeling Happy</span>
                            <span>üòä</span>
                        </div>
                    </div>
                </div>
                
                <!-- User 2 -->
                <div class="flex items-center gap-3 p-3 rounded-xl hover:bg-white/[0.03] transition-all cursor-pointer group border border-transparent hover:border-white/5">
                    <div class="size-12 rounded-full bg-cover bg-center shrink-0 ring-2 ring-emerald-500/30 shadow-lg" style="background-image: url('https://lh3.googleusercontent.com/aida-public/AB6AXuBh5eYK1bI_Vd67GCmZBnQ5HUwlQrWX5UrNRSsObhne7yXsorXlxOgch63esTP6i24rcApVw-8ubuc4NIFz-8vwZf1WGim_3fglBjfT3XzYSC290n2vxPh31TPQYBVa9jjI8WfBSygQt4dExyOoRI8fv5PCpX8QY_m9YYa9zwYwVOBIsvXUW8P3ThjzrnKT-5_LkpGBZsjgCuK5iv1Az5-swyGuo8p4X4vZfxEbbtwfBpprK51Do94pwPdd6D6zJvTUZ5lCNX22hE3v');"></div>
                    <div class="flex-1 min-w-0">
                        <div class="font-bold text-sm text-white truncate">Michael T.</div>
                        <div class="text-xs text-gray-500 flex items-center gap-1">
                            <span>Focusing</span>
                            <span>üéØ</span>
                        </div>
                    </div>
                </div>
                
                <!-- User 3 -->
                <div class="flex items-center gap-3 p-3 rounded-xl hover:bg-white/[0.03] transition-all cursor-pointer group border border-transparent hover:border-white/5">
                    <div class="size-12 rounded-full bg-cover bg-center shrink-0 ring-2 ring-emerald-500/30 shadow-lg" style="background-image: url('https://lh3.googleusercontent.com/aida-public/AB6AXuD5WJKknRKBaXWwmU7WZuXxAn7Le7WOEBvDTICYX5-kwT-8jmgnAcU9RmGkmU2-klJY_UtgHYaWanh4PPiTzaCWv3CIg6Z1AhoAokv5rkESbob_IPxQwEqRseNijsiqODAvvchd4qsJ7dcBFLMaqExnz59w0FYRV_ExIeZBGQqVE6d_kgcGVq2x3AUBNFhX--p4dJpf9M7hr9o3Md8YwEymYEY_KDeg1lZ-8LmkoCG-ECZPMWM5DVVptUlScDiWLQ6uA0ubOj7iSfmI');"></div>
                    <div class="flex-1 min-w-0">
                        <div class="font-bold text-sm text-white truncate">David K.</div>
                        <div class="text-xs text-gray-500 flex items-center gap-1">
                            <span>Idle</span>
                            <span>üåô</span>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Chat Section -->
        <section class="flex-1 flex flex-col glass-panel rounded-3xl overflow-hidden neon-border min-h-0">
            <!-- Chat Header -->
            <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 p-4 sm:p-6 border-b border-white/5 bg-white/[0.02] shrink-0">
                <div class="flex items-center gap-4">
                    <div class="flex flex-col">
                        <h2 class="text-xl sm:text-2xl font-black text-white tracking-tight">Mindful Space</h2>
                        <div class="flex items-center gap-2 mt-1">
                            <span class="flex h-2 w-2 relative">
                                <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-emerald-400 opacity-75"></span>
                                <span class="relative inline-flex rounded-full h-2 w-2 bg-emerald-500 shadow-[0_0_8px_rgba(16,185,129,0.7)]"></span>
                            </span>
                            <span class="text-[10px] font-bold uppercase tracking-widest text-emerald-400">12 Syncing</span>
                        </div>
                    </div>
                </div>
                <div class="flex items-center justify-end gap-3 w-full sm:w-auto">
                    <!-- Timer -->
                    <div class="timer-glow px-4 py-2 rounded-xl flex items-center gap-2">
                        <span class="material-symbols-outlined text-red-400 text-base">schedule</span>
                        <span class="text-red-400 font-mono font-bold text-sm tabular-nums">10:00</span>
                    </div>
                    
                    <button id="disconnectBtn" class="hidden lg:flex px-4 py-2 rounded-xl text-[10px] font-black uppercase tracking-widest text-gray-400 hover:text-rose-400 hover:bg-rose-500/10 transition-all border border-transparent hover:border-rose-500/20">
                        Disconnect
                    </button>
                    <div class="h-6 w-px bg-white/10 mx-1"></div>
                    
                    <!-- Call Buttons -->
                    <button class="size-10 flex items-center justify-center rounded-xl bg-white/5 text-gray-400 hover:text-primary hover:shadow-glow-neon hover:bg-white/10 transition-all duration-300" title="Audio Call">
                        <span class="material-symbols-outlined text-[20px]">call</span>
                    </button>
                    <button class="size-10 flex items-center justify-center rounded-xl bg-white/5 text-gray-400 hover:text-primary hover:shadow-glow-neon hover:bg-white/10 transition-all duration-300" title="Video Call">
                        <span class="material-symbols-outlined text-[20px]">videocam</span>
                    </button>
                    <button class="size-10 flex items-center justify-center rounded-xl bg-white/5 text-gray-400 hover:text-white hover:bg-white/10 transition-all" title="More Options">
                        <span class="material-symbols-outlined text-[20px]">more_vert</span>
                    </button>
                </div>
            </div>

            <!-- Messages Area -->
            <div class="flex-1 overflow-y-auto custom-scrollbar p-4 sm:p-6 space-y-8 bg-black/10 relative min-h-0">
                <div class="absolute inset-0 tech-pattern opacity-[0.03] pointer-events-none"></div>
                
                <!-- Date Divider -->
                <div class="flex justify-center py-2 relative z-10">
                    <span class="px-5 py-1.5 rounded-full bg-white/[0.04] border border-white/10 text-[9px] font-black uppercase tracking-[0.3em] text-gray-500 backdrop-blur-md">
                        Data Stream: Today
                    </span>
                </div>

                <!-- Message 1 - Received -->
                <div class="flex gap-4 max-w-[80%] group items-start relative z-10">
                    <div class="size-10 rounded-full bg-cover bg-center shrink-0 self-end mb-1 ring-1 ring-white/20 shadow-xl" style="background-image: url('https://lh3.googleusercontent.com/aida-public/AB6AXuC6RshlEAKTPScNiFAtmnIsu-OooA0vUTsbaWqn9F_C7ZnR54XHTwx6fM7-i1gLBbWcgwHrApR1InoURQ4ekwoQrxyry6QXtx9XZIDJGp4-0LblceL0SEGpdr40LOXyw9W-dyVOIiLMVkpzHVbER2s7T_oJoxoKiM1eGNy7yhMOpzNtpm3xDZ13h4tbI-uKshZidaN6za4mQ5oyAccCHBxF2CBvpnb2iMfeg8QCVQnwC4y4Ne14D2axIolIiFZSAzsQB-YR6_BJfU5n');"></div>
                    <div class="flex flex-col gap-1.5">
                        <div class="flex items-baseline gap-2 pl-1">
                            <span class="text-[11px] font-black text-gray-300 uppercase tracking-wider">Sarah M.</span>
                            <span class="text-[9px] text-gray-600 font-mono">10:24</span>
                        </div>
                        <div class="glass-bubble-received p-4 rounded-2xl rounded-bl-none text-sm leading-relaxed text-gray-100">
                            Has anyone tried the new mood logging feature yet? I just found it this morning.
                        </div>
                    </div>
                    <button class="size-8 flex items-center justify-center text-gray-600 hover:text-primary rounded-full self-center opacity-0 group-hover:opacity-100 transition-all">
                        <span class="material-symbols-outlined text-[18px]">reply</span>
                    </button>
                </div>

                <!-- Message 2 - Received with Reply -->
                <div class="flex gap-4 max-w-[80%] group items-start relative z-10">
                    <div class="size-10 rounded-full bg-cover bg-center shrink-0 self-end mb-1 ring-1 ring-white/20 shadow-xl" style="background-image: url('https://lh3.googleusercontent.com/aida-public/AB6AXuBh5eYK1bI_Vd67GCmZBnQ5HUwlQrWX5UrNRSsObhne7yXsorXlxOgch63esTP6i24rcApVw-8ubuc4NIFz-8vwZf1WGim_3fglBjfT3XzYSC290n2vxPh31TPQYBVa9jjI8WfBSygQt4dExyOoRI8fv5PCpX8QY_m9YYa9zwYwVOBIsvXUW8P3ThjzrnKT-5_LkpGBZsjgCuK5iv1Az5-swyGuo8p4X4vZfxEbbtwfBpprK51Do94pwPdd6D6zJvTUZ5lCNX22hE3v');"></div>
                    <div class="flex flex-col gap-1.5">
                        <div class="flex items-baseline gap-2 pl-1">
                            <span class="text-[11px] font-black text-gray-300 uppercase tracking-wider">Michael T.</span>
                            <span class="text-[9px] text-gray-600 font-mono">10:28</span>
                        </div>
                        <div class="glass-bubble-received rounded-2xl rounded-bl-none overflow-hidden">
                            <!-- Quoted Message -->
                            <div class="mx-3 mt-3 p-2 bg-black/40 border-l-2 border-primary/50 rounded-lg flex flex-col gap-0.5 opacity-80">
                                <span class="text-[9px] font-black text-primary uppercase">Sarah M.</span>
                                <p class="text-[11px] text-gray-400 truncate italic">Has anyone tried the new mood logging feature yet...</p>
                            </div>
                            <!-- Message Content -->
                            <div class="p-4 pt-2 text-sm text-gray-100 leading-relaxed">
                                Yes! It's actually really helpful. I used the üòå emoji today because I managed to finish my morning run.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Message 3 - Sent with Reply -->
                <div class="flex gap-4 max-w-[80%] ml-auto flex-row-reverse group items-start relative z-10">
                    <div class="flex flex-col gap-1.5 items-end">
                        <div class="flex items-baseline gap-2 pr-1">
                            <span class="text-[9px] text-gray-600 font-mono">10:30</span>
                            <span class="text-[11px] font-black text-white uppercase tracking-wider">You</span>
                        </div>
                        <div class="glass-bubble-sent rounded-2xl rounded-br-none overflow-hidden">
                            <!-- Quoted Message -->
                            <div class="mx-1.5 mt-1.5 p-2 bg-black/30 border-l-2 border-white/40 rounded-lg flex flex-col gap-0.5">
                                <span class="text-[9px] font-black text-white/70 uppercase">Michael T.</span>
                                <p class="text-[11px] text-white/60 truncate italic">Yes! It's actually really helpful...</p>
                            </div>
                            <!-- Message Content -->
                            <div class="p-4 pt-2 text-sm font-semibold text-white leading-relaxed">
                                I really like the tracking graph üìä it generates at the end of the week. Helps me see patterns.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Typing Indicator -->
                <div class="flex gap-4 items-start relative z-10">
                    <div class="size-10 rounded-full bg-cover bg-center shrink-0 self-end mb-1 ring-1 ring-white/20" style="background-image: url('https://lh3.googleusercontent.com/aida-public/AB6AXuD5WJKknRKBaXWwmU7WZuXxAn7Le7WOEBvDTICYX5-kwT-8jmgnAcU9RmGkmU2-klJY_UtgHYaWanh4PPiTzaCWv3CIg6Z1AhoAokv5rkESbob_IPxQwEqRseNijsiqODAvvchd4qsJ7dcBFLMaqExnz59w0FYRV_ExIeZBGQqVE6d_kgcGVq2x3AUBNFhX--p4dJpf9M7hr9o3Md8YwEymYEY_KDeg1lZ-8LmkoCG-ECZPMWM5DVVptUlScDiWLQ6uA0ubOj7iSfmI');"></div>
                    <div class="glass-bubble-received px-5 py-4 rounded-2xl rounded-bl-none">
                        <div class="flex gap-1.5">
                            <span class="size-1.5 bg-primary/60 rounded-full animate-bounce shadow-[0_0_8px_rgba(51,191,204,0.7)]" style="animation-delay: 0ms;"></span>
                            <span class="size-1.5 bg-primary/60 rounded-full animate-bounce shadow-[0_0_8px_rgba(51,191,204,0.7)]" style="animation-delay: 150ms;"></span>
                            <span class="size-1.5 bg-primary/60 rounded-full animate-bounce shadow-[0_0_8px_rgba(51,191,204,0.7)]" style="animation-delay: 300ms;"></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Input Area -->
            <div class="p-4 bg-surface-mid/80 backdrop-blur-3xl border-t border-white/10 relative z-20 shrink-0">
                <!-- Reply Preview Bar -->
                <div class="flex items-center justify-between px-5 py-3 bg-black/40 border border-white/5 border-b-0 rounded-t-2xl mb-0 relative">
                    <div class="absolute top-0 inset-x-0 h-[1px] bg-gradient-to-r from-transparent via-primary/40 to-transparent"></div>
                    <div class="flex flex-col gap-0.5 border-l-2 border-primary pl-4">
                        <span class="text-[9px] font-black text-primary flex items-center gap-2 uppercase tracking-widest">
                            <span class="material-symbols-outlined text-[14px]">reply</span>
                            Encrypting reply to Sarah M.
                        </span>
                        <span class="text-[11px] text-gray-400 truncate max-w-xl italic">Has anyone tried the new mood logging feature yet? I just found it this morning.</span>
                    </div>
                    <button class="size-8 flex items-center justify-center rounded-full text-gray-500 hover:text-rose-400 hover:bg-rose-500/10 transition-all">
                        <span class="material-symbols-outlined text-[20px]">close</span>
                    </button>
                </div>
                
                <!-- Input Controls -->
                <div class="flex gap-3 sm:gap-4 items-end pt-4 bg-gradient-to-b from-transparent to-black/10 p-2 rounded-b-2xl">
                    <!-- Emoji Button -->
                    <button class="size-11 sm:size-12 flex items-center justify-center rounded-2xl bg-white/5 border border-white/10 text-gray-400 hover:text-primary hover:border-primary/30 transition-all shrink-0">
                        <span class="material-symbols-outlined text-[22px]">add_reaction</span>
                    </button>
                    
                    <!-- Attachment Button -->
                    <button class="size-11 sm:size-12 flex items-center justify-center rounded-2xl bg-white/5 border border-white/10 text-gray-400 hover:text-primary hover:border-primary/30 transition-all shrink-0">
                        <span class="material-symbols-outlined text-[22px]">attach_file</span>
                    </button>
                    
                    <!-- Input Field -->
                    <div class="flex-1 bg-black/40 rounded-2xl border border-white/10 focus-within:border-primary/50 focus-within:ring-2 focus-within:ring-primary/10 transition-all flex items-center px-4 sm:px-5 py-3 shadow-inner relative group">
                        <textarea class="flex-1 bg-transparent border-none focus:ring-0 text-sm text-white placeholder-gray-600 resize-none max-h-32 custom-scrollbar" placeholder="Transmit message..." rows="1"></textarea>
                        <div class="absolute bottom-0 left-0 h-[1px] w-0 bg-primary transition-all duration-700 group-focus-within:w-full"></div>
                    </div>
                    
                    <!-- Send Button -->
                    <button class="size-11 sm:size-12 flex items-center justify-center rounded-2xl bg-gradient-to-br from-primary to-accent text-white shadow-glow-neon hover:scale-105 active:scale-95 transition-all shrink-0 border border-white/20">
                        <span class="material-symbols-outlined text-[24px]">send</span>
                    </button>
                </div>
            </div>
        </section>
    </div>
</main>

<!-- Leave/Disconnect Confirmation Modal -->
<div id="leaveModal" class="modal-overlay">
    <div class="modal-dialog">
        <div class="modal-icon-wrapper">
            <span class="material-symbols-outlined text-red-500 text-5xl animate-bounce-subtle">warning</span>
        </div>
        
        <div class="text-center mb-1">
            <h3 class="text-2xl font-black text-white mb-3 tracking-tight">Leave Chat Room?</h3>
            <p class="text-gray-400 text-sm leading-relaxed max-w-sm mx-auto">
                You're currently in an active chat session. If you disconnect now, you'll be removed from the conversation and won't receive new messages.
            </p>
        </div>
        
        <div class="modal-buttons">
            <button id="btnStay" class="btn-stay">
                <span class="flex items-center justify-center gap-2">
                    <span class="material-symbols-outlined text-base">check_circle</span>
                    Stay Connected
                </span>
            </button>
            <button id="btnLeave" class="btn-leave">
                <span class="flex items-center justify-center gap-2">
                    <span class="material-symbols-outlined text-base">logout</span>
                    Disconnect
                </span>
            </button>
        </div>
    </div>
</div>


    <!-- Confirmation Dialog (hidden by default) -->
    <div id="confirmationOverlay" style="display: none;"></div>
    
    
  

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <script>
      
      
      
          const leaveModal = document.getElementById('leaveModal');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const btnStay = document.getElementById('btnStay');
    const btnLeave = document.getElementById('btnLeave');
    
    // Show modal when disconnect button is clicked
    disconnectBtn?.addEventListener('click', () => {
        leaveModal.classList.add('active');
    });
    
    // Close modal and stay
    btnStay?.addEventListener('click', () => {
        leaveModal.classList.remove('active');
    });
    
    // Leave chat room
    btnLeave?.addEventListener('click', () => {
        leaveModal.classList.remove('active');
        // Add your leave logic here
        console.log('User chose to leave the chat room');
        // Example: window.location.href = '/mood.html';
    });
    
    // Close modal when clicking outside
    leaveModal?.addEventListener('click', (e) => {
        if (e.target === leaveModal) {
            leaveModal.classList.remove('active');
        }
    });
    
    // Auto-resize textarea
    const textarea = document.querySelector('textarea');
    textarea?.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 128) + 'px';
    });
      
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };

      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>

    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="app.js"></script>

    <script>
(async () => {
  const MoodApp = window.MoodApp || {};
  const _Auth = MoodApp.Auth;
  const _API = MoodApp.API;
  const _Toast = MoodApp.Toast;
  const _Utils = MoodApp.Utils;

const toast = (m, t='success') => { 
  if (_Toast) {
    // Handle 'info' type by mapping to 'success' if no info function exists
    const toastType = (t === 'info' && typeof _Toast.info !== 'function') ? 'success' : t;
    if (typeof _Toast[toastType] === 'function') {
      return _Toast[toastType](m);
    }
  }
  console[t==='error'?'error':'log'](m); 
};

  // ============================================
  // STORAGE KEYS
  // ============================================
  const CHAT_STATE_KEY = 'chat_state';
  const CHAT_MESSAGES_KEY = 'chat_messages';
  const CHAT_TIMESTAMP_KEY = 'chat_timestamp';
  const ACTIVE_CALL_KEY = 'activeCall';
  
  
  const CACHED_CALL_KEY = 'cachedIncomingCall';
const CALL_CACHE_TIMEOUT = 60000; // 60 seconds max cache time
let cachedCallCheckInterval = null;
  // ============================================
  // STATE MANAGEMENT
  // ============================================
  let replyingTo = null;
  let isInitiatingCall = false;
  let pendingCallData = null;
  let navigatingToCall = false;
  let messagesCache = [];
  let activeCallInRoom = null;
  let backButtonHandled = false;
  let timerInterval = null;
  let socketInstance = null;
  let currentUser = null;
  let roomData = null;
  let serverClockOffset = 0; // Milliseconds to add to client time to get server time
  let serverExpiresAt = null; // Absolute server timestamp for expiry
  
  let floatingCallPopup = null;
let floatingCallSocket = null;
let currentSpeaker = null;
let isInBackgroundCall = false;
  
  // ============================================
  // DOM ELEMENTS (Initialized early)
  // ============================================
  const sidebar = document.getElementById('sidebar');
  const sidebarToggle = document.getElementById('sidebarToggle');
  const sidebarClose = document.getElementById('sidebarClose');
  const sidebarOverlay = document.getElementById('sidebarOverlay');
  const messagesList = document.getElementById('messagesList');
  const messageForm = document.getElementById('messageForm');
  const messageInput = document.getElementById('messageInput');
  const usersList = document.getElementById('usersList');
  const onlineCount = document.getElementById('onlineCount');
  const timeRemaining = document.getElementById('timeRemaining');
  const leaveBtn = document.getElementById('leaveBtn');
  const cancelReplyBtn = document.getElementById('cancelReply');
  const audioCallBtn = document.getElementById('audioCallBtn');
  const videoCallBtn = document.getElementById('videoCallBtn');
  const joinCallBtn = document.getElementById('joinCallBtn');
  const incomingCallModal = document.getElementById('incomingCallModal');
  const acceptCallBtn = document.getElementById('acceptCallBtn');
  const declineCallBtn = document.getElementById('declineCallBtn');
  
  // ============================================
  // UTILITY FUNCTIONS
  // ============================================
  
  
  // ============================================
// AUTHENTICATION STATE MANAGEMENT
// ============================================
let isSocketAuthenticated = false;
let authenticationPromise = null;

function setAuthenticationState(authenticated) {
  console.log(`üîê ========================================`);
  console.log(`üîê AUTHENTICATION STATE CHANGE`);
  console.log(`üîê ========================================`);
  console.log(`   Previous state: ${isSocketAuthenticated}`);
  console.log(`   New state: ${authenticated}`);
  
  isSocketAuthenticated = authenticated;
  
  if (authenticated) {
    console.log(`‚úÖ Socket fully authenticated - enabling call features`);
    enableCallButtons();
  } else {
    console.log(`üîí Socket not authenticated - disabling call features`);
    disableCallButtons(true); // true = show loading state
  }
  
  console.log(`üîê ========================================\n`);
}

function waitForAuthentication() {
  if (isSocketAuthenticated) {
    console.log(`‚úÖ Already authenticated, proceeding immediately`);
    return Promise.resolve();
  }
  
  if (!authenticationPromise) {
    console.log(`‚è≥ Creating authentication promise...`);
    authenticationPromise = new Promise((resolve) => {
      const checkAuth = () => {
        if (isSocketAuthenticated) {
          console.log(`‚úÖ Authentication promise resolved`);
          resolve();
        } else {
          setTimeout(checkAuth, 50);
        }
      };
      checkAuth();
    });
  }
  
  return authenticationPromise;
}

function enableCallButtons() {
  console.log(`üéöÔ∏è Enabling call buttons`);
  
  if (audioCallBtn) {
    audioCallBtn.disabled = false;
    audioCallBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'animate-pulse');
    audioCallBtn.title = 'Start Audio Call';
    console.log(`   ‚úÖ Audio button enabled`);
  }
  
  if (videoCallBtn) {
    videoCallBtn.disabled = false;
    videoCallBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'animate-pulse');
    videoCallBtn.title = 'Start Video Call';
    console.log(`   ‚úÖ Video button enabled`);
  }
}

function disableCallButtons(showLoading = false) {
  console.log(`üîí Disabling call buttons (loading: ${showLoading})`);
  
  if (audioCallBtn) {
    audioCallBtn.disabled = true;
    audioCallBtn.classList.add('opacity-50', 'cursor-not-allowed');
    if (showLoading) {
      audioCallBtn.classList.add('animate-pulse');
      audioCallBtn.title = 'Connecting...';
    } else {
      audioCallBtn.title = 'Authenticating...';
    }
    console.log(`   üîí Audio button disabled`);
  }
  
  if (videoCallBtn) {
    videoCallBtn.disabled = true;
    videoCallBtn.classList.add('opacity-50', 'cursor-not-allowed');
    if (showLoading) {
      videoCallBtn.classList.add('animate-pulse');
      videoCallBtn.title = 'Connecting...';
    } else {
      videoCallBtn.title = 'Authenticating...';
    }
    console.log(`   üîí Video button disabled`);
  }
}
  
  
  
  
  function checkForCachedCall() {
    console.log('üîç Checking for cached incoming call...');
    
    const cachedCallStr = localStorage.getItem(CACHED_CALL_KEY);
    
    if (!cachedCallStr) {
        console.log('‚ÑπÔ∏è No cached call found');
        return;
    }
    
    try {
        const cachedCall = JSON.parse(cachedCallStr);
        const cacheAge = Date.now() - cachedCall.timestamp;
        
        console.log(`üìû Found cached call from ${cachedCall.callerUsername}`);
        console.log(`   Age: ${(cacheAge / 1000).toFixed(1)}s`);
        console.log(`   Call ID: ${cachedCall.callId}`);
        
        // Check if cache is expired
        if (cacheAge > CALL_CACHE_TIMEOUT) {
            console.log(`‚è∞ Cached call expired (${(cacheAge / 1000).toFixed(1)}s > ${CALL_CACHE_TIMEOUT / 1000}s)`);
            localStorage.removeItem(CACHED_CALL_KEY);
            return;
        }
        
        // Check if call is still valid on server
        if (socketInstance && socketInstance.connected) {
            console.log(`üì° Validating cached call ${cachedCall.callId} with server...`);
            
            socketInstance.emit('validate_cached_call', {
                callId: cachedCall.callId,
                roomId: roomData.roomId
            });
        } else {
            console.warn('‚ö†Ô∏è Socket not connected, will retry validation');
        }
        
    } catch (e) {
        console.error('‚ùå Failed to parse cached call:', e);
        localStorage.removeItem(CACHED_CALL_KEY);
    }
}

function showCachedCallModal(callData) {
    console.log('üìû ========================================');
    console.log('üìû SHOWING CACHED INCOMING CALL');
    console.log('üìû ========================================');
    console.log(`   Caller: ${callData.callerUsername}`);
    console.log(`   Call ID: ${callData.callId}`);
    console.log(`   Type: ${callData.callType}`);
    
    // Set pending call data
    pendingCallData = {
        callId: callData.callId,
        callerUsername: callData.callerUsername,
        callerPfp: callData.callerPfp,
        callType: callData.callType,
        fromCache: true
    };
    
    // Update modal UI
    const callerName = document.getElementById('callerName');
    const callType = document.getElementById('callType');
    const callerAvatar = document.getElementById('callerAvatar');
    
    if (callerName) callerName.textContent = `${callData.callerUsername} is calling`;
    if (callType) callType.textContent = callData.callType === 'video' ? 'Video Call' : 'Audio Call';
    if (callerAvatar) {
        callerAvatar.innerHTML = '';
        const pfp = createProfilePictureElement(callData.callerPfp, callData.callerUsername, 'w-full h-full');
        callerAvatar.appendChild(pfp);
    }
    
    // Show modal immediately (no delay for cached calls)
    incomingCallModal?.classList.remove('hidden');
    
    console.log('‚úÖ Cached call modal displayed');
    console.log('üìû ========================================\n');
}

function startCachedCallMonitoring() {
    console.log('üîÑ Starting cached call monitoring...');
    
    // Check immediately on load
    checkForCachedCall();
    
    // Check every 2 seconds for cached calls
    cachedCallCheckInterval = setInterval(() => {
        checkForCachedCall();
    }, 2000);
    
    console.log('‚úÖ Cached call monitoring started (checks every 2s)');
}

function stopCachedCallMonitoring() {
    if (cachedCallCheckInterval) {
        clearInterval(cachedCallCheckInterval);
        cachedCallCheckInterval = null;
        console.log('üõë Cached call monitoring stopped');
    }
}
  
  
  // Function to cleanup parent call.html page
function cleanupParentCallPage() {
  console.log('üßπ ========================================');
  console.log('üßπ CLEANING UP PARENT CALL PAGE');
  console.log('üßπ ========================================');
  
  // Check if we're in an iframe (chat overlay on call.html)
  if (window.parent && window.parent !== window) {
    console.log('üì± We are in iframe - accessing parent window');
    try {
      // Hide the floating button
      const parentFloatingBtn = window.parent.document.getElementById('floatingReturnToCall');
      if (parentFloatingBtn) {
        parentFloatingBtn.classList.add('hidden');
        console.log('‚úÖ Parent floating button hidden');
      }
      
      // Navigate parent window to mood.html (this will trigger call.html cleanup)
      console.log('üîÑ Navigating parent window to mood.html');
      window.parent.location.href = '/mood.html';
      
      console.log('‚úÖ Parent window navigation initiated');
    } catch (e) {
      console.error('‚ùå Cannot access parent window:', e);
      // Fallback: just navigate ourselves
      window.location.href = '/mood.html';
    }
  } else {
    console.log('‚ÑπÔ∏è Not in iframe - navigating directly');
    window.location.href = '/mood.html';
  }
  
  console.log('üßπ ========================================\n');
}
  
  
  // Function to hide floating button in parent call.html
function hideCallPageFloatingButton() {
  console.log('üéà Attempting to hide call.html floating button');
  
  // Check if we're in an iframe (chat overlay)
  if (window.parent && window.parent !== window) {
    console.log('üì± We are in iframe - accessing parent window');
    try {
      const parentFloatingBtn = window.parent.document.getElementById('floatingReturnToCall');
      if (parentFloatingBtn) {
        parentFloatingBtn.classList.add('hidden');
        console.log('‚úÖ Parent floating button hidden');
      } else {
        console.warn('‚ö†Ô∏è Parent floating button not found');
      }
    } catch (e) {
      console.error('‚ùå Cannot access parent window (CORS?):', e);
    }
  } else {
    console.log('‚ÑπÔ∏è Not in iframe - checking local DOM');
    // If not in iframe, might be standalone chat page
    const localFloatingBtn = document.getElementById('floatingReturnToCall');
    if (localFloatingBtn) {
      localFloatingBtn.classList.add('hidden');
      console.log('‚úÖ Local floating button hidden');
    }
  }
}
  


function returnToActiveCall() {
  console.log('üîô ========================================');
  console.log('üîô RETURNING TO ACTIVE CALL FROM CHAT');
  console.log('üîô ========================================');
  
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  if (!activeCallStr) {
    console.error('‚ùå No active call data found');
    toast('No active call found', 'error');
    return;
  }
  
  try {
    const activeCallData = JSON.parse(activeCallStr);
    console.log(`   callId: ${activeCallData.callId}`);
    console.log(`   callType: ${activeCallData.callType}`);
    console.log(`   backgroundMode: ${activeCallData.backgroundMode}`);
    
    // Mark that we're returning to call (not starting new call)
    navigatingToCall = true;
    
    // CRITICAL: Remove background mode flag so call page knows we're coming back
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    
    // Mark that we're returning to existing call
    sessionStorage.setItem('returningToBackgroundCall', 'true');
    
    // Save current chat state
    saveChatState(roomData.roomId, messagesCache);
    
    // Disconnect floating socket before navigating
    if (floatingCallSocket) {
      console.log('üîå Disconnecting floating socket (will reconnect on call page)');
      floatingCallSocket.disconnect();
      floatingCallSocket = null;
    }
    
    console.log('‚úÖ Navigating back to call page');
    window.location.href = '/call.html';
    
  } catch (e) {
    console.error('‚ùå Failed to parse active call data:', e);
    toast('Failed to return to call', 'error');
  }
  
  console.log('üîô ========================================\n');
}

function checkForBackgroundCall() {
  const hasBackgroundCall = sessionStorage.getItem('hasBackgroundCall') === 'true';
  const activeCallStr = localStorage.getItem('activeCall');
  
  console.log('üîç Checking for background call...');
  console.log(`   hasBackgroundCall flag: ${hasBackgroundCall}`);
  console.log(`   activeCall in storage: ${!!activeCallStr}`);
  
  if (hasBackgroundCall && activeCallStr) {
    console.log('‚úÖ Background call detected - showing return button');
    
    const returnBtn = document.getElementById('floatingReturnToCall');
    if (returnBtn) {
      returnBtn.classList.remove('hidden');
      
      returnBtn.onclick = () => {
        console.log('üìû Return to call clicked');
        sessionStorage.removeItem('hasBackgroundCall');
        window.location.href = '/call.html';
      };
      
      console.log('‚úÖ Return to call button activated');
    }
  } else {
    console.log('‚ÑπÔ∏è No background call detected');
  }
}
  
  
  
function saveChatState(roomId, messages) {
    try {
        // Determine current call button state
        let callButtonState = 'none'; // 'none', 'join', 'back'
        
        const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
        const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomId;
        
        if (userInCall) {
            callButtonState = 'back';
        } else if (activeCallInRoom) {
            callButtonState = 'join';
        }
        
        // CRITICAL FIX: Always preserve activeCallInRoom if it exists
        const callInRoomToSave = activeCallInRoom || null;
        
        const state = {
            roomId,
            messages: messages || [],
            timestamp: Date.now(),
            callButtonState,
            activeCallInRoom: callInRoomToSave
        };
        
        localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(state));
        localStorage.setItem(CHAT_TIMESTAMP_KEY, Date.now().toString());
        
        console.log('‚úÖ Chat state saved:', {
            messages: messages?.length || 0,
            buttonState: callButtonState,
            hasActiveCallInRoom: !!callInRoomToSave,
            activeCallInRoom: callInRoomToSave
        });
    } catch (e) {
        console.warn('‚ö†Ô∏è Failed to save chat state:', e);
    }
}
  
  function loadChatState() {
    try {
      const stateStr = localStorage.getItem(CHAT_STATE_KEY);
      if (!stateStr) return null;
      
      const state = JSON.parse(stateStr);
      console.log('‚úÖ Chat state loaded:', state.messages?.length || 0, 'messages');
      return state;
    } catch (e) {
      console.warn('‚ö†Ô∏è Failed to load chat state:', e);
      return null;
    }
  }
  
function clearChatState(force = false) {
    // Only clear if room is actually expiring/ended, or if forced
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    
    if (!force && activeCallStr) {
        console.log('‚ö†Ô∏è Active call exists - preserving chat state');
        return;
    }
    
    localStorage.removeItem(CHAT_STATE_KEY);
    localStorage.removeItem(CHAT_MESSAGES_KEY);
    localStorage.removeItem(CHAT_TIMESTAMP_KEY);
    console.log('üóëÔ∏è Chat state cleared');
}

  function clearAllChatData() {
    // CRITICAL: Clear ALL chat-related data on entry
    localStorage.removeItem(CHAT_STATE_KEY);
    localStorage.removeItem(CHAT_MESSAGES_KEY);
    localStorage.removeItem(CHAT_TIMESTAMP_KEY);
    // Don't clear currentRoom or activeCall - those are needed
    console.log('üßπ All chat state cleared on entry');
  }
  
  function escapeHtml(text) {
    if (_Utils && typeof _Utils.escapeHtml === 'function') {
      return _Utils.escapeHtml(text);
    }
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function formatTimestamp(timestamp) {
    if (_Utils && typeof _Utils.formatDate === 'function') {
      return _Utils.formatDate(timestamp);
    }
    return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

function setInitialCallButtonState() {
    console.log('üîç Checking for active call in localStorage...');
    
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    
    if (activeCallStr) {
        try {
            const activeCallData = JSON.parse(activeCallStr);
            
            if (activeCallData.roomId === roomData?.roomId) {
                console.log(`üìû Active call found: ${activeCallData.callId} in room ${activeCallData.roomId}`);
                console.log(`‚úÖ User is IN the call - will show "Back to Call" button`);
                
                // Hide audio/video buttons
                if (audioCallBtn) {
                    audioCallBtn.classList.add('hidden');
                }
                if (videoCallBtn) {
                    videoCallBtn.classList.add('hidden');
                }
                
                // Show join button as "Back to Call" button
                if (joinCallBtn) {
                    joinCallBtn.classList.remove('hidden');
                    joinCallBtn.classList.add('flex');
                    joinCallBtn.disabled = false;
                    
                    // Update button text and icon
                    const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
                    const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
                    const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
                    
                    if (btnIcon) btnIcon.textContent = 'call';
                    if (btnTextLong) btnTextLong.textContent = 'Back to Call';
                    if (btnTextShort) btnTextShort.textContent = 'Back';
                    
                    // Change color to green
                    joinCallBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    joinCallBtn.classList.add('bg-primary', 'hover:bg-primary/90');
                    
                    console.log('‚úÖ "Back to Call" button configured');
                }
                
                return true;
            } else {
                console.log(`‚ùå Room mismatch: ${activeCallData.roomId} !== ${roomData?.roomId}`);
            }
        } catch (e) {
            console.error('‚ùå Failed to parse activeCall:', e);
            localStorage.removeItem(ACTIVE_CALL_KEY);
        }
    }
    
    // No active call - show normal buttons
    console.log('‚ÑπÔ∏è No active call - showing audio/video buttons');
    if (audioCallBtn) {
        audioCallBtn.classList.remove('hidden');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('hidden');
        videoCallBtn.disabled = false;
    }
    if (joinCallBtn) {
        joinCallBtn.classList.add('hidden');
        joinCallBtn.classList.remove('flex');
    }
    
    return false;
}
  
function updateCallButtonState(isActive, callData = null) {
    console.log('üîÑ Updating call button state:', { isActive, participantCount: callData?.participantCount });
    
    // Remove loading states and re-enable buttons
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.disabled = false;
    }
    if (joinCallBtn) {
        joinCallBtn.classList.remove('join-btn-loading');
    }
    
    // Check if user is already in the call
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomData?.roomId;
    
    if (userInCall) {
        console.log('üìû User is IN call - showing "Back to Call" button');
        
        // Hide audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.add('hidden');
            audioCallBtn.disabled = true;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.add('hidden');
            videoCallBtn.disabled = true;
        }
        
        // Show "Back to Call" button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('hidden');
            joinCallBtn.classList.add('flex');
            joinCallBtn.disabled = false;
            
            // Update button text and icon
            const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
            const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
            const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
            
            if (btnIcon) btnIcon.textContent = 'call';
            if (btnTextLong) btnTextLong.textContent = 'Back to Call';
            if (btnTextShort) btnTextShort.textContent = 'Back';
            
            // Change to primary color (teal)
            joinCallBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            joinCallBtn.classList.add('bg-primary', 'hover:bg-primary/90');
            
            console.log('‚úÖ "Back to Call" button displayed');
        }
    } else if (isActive && callData) {
        console.log('üìû Active call in room but user NOT in it - showing "Join Call" button');
        
        // Hide audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.add('hidden');
            audioCallBtn.disabled = true;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.add('hidden');
            videoCallBtn.disabled = true;
        }
        
        // Show "Join Call" button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('hidden');
            joinCallBtn.classList.add('flex');
            joinCallBtn.disabled = false;
            
            // Update button text and icon for join
            const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
            const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
            const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
            
            if (btnIcon) btnIcon.textContent = 'login';
            if (btnTextLong) btnTextLong.textContent = 'Join Call';
            if (btnTextShort) btnTextShort.textContent = 'Join';
            
            // Green color for join
            joinCallBtn.classList.remove('bg-primary', 'hover:bg-primary/90');
            joinCallBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            
            console.log(`‚úÖ "Join Call" button displayed (${callData.participantCount} participants)`);
        }
    } else {
        console.log('üìû No active call - showing audio/video buttons');
        
        // Show audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.remove('hidden');
            audioCallBtn.disabled = false;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.remove('hidden');
            videoCallBtn.disabled = false;
        }
        
        // Hide join button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('flex');
            joinCallBtn.classList.add('hidden');
            joinCallBtn.disabled = true;
        }
        
        console.log('‚úÖ Audio/Video buttons displayed');
    }
}

  // ============================================
  // UI FUNCTIONS
  // ============================================
  
  function openSidebar() {
    if (!sidebar || !sidebarOverlay) return;
    sidebar.classList.add('show');
    sidebarOverlay.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  function closeSidebar() {
    if (!sidebar || !sidebarOverlay) return;
    sidebar.classList.remove('show');
    sidebarOverlay.classList.remove('active');
    document.body.style.overflow = '';
  }

  function toggleSidebar() {
    if (!sidebar) return;
    sidebar.classList.contains('show') ? closeSidebar() : openSidebar();
  }

  function setupUserCardClick() {
    if (window.innerWidth <= 768) {
      document.querySelectorAll('.user-card').forEach(card => {
        card.addEventListener('click', closeSidebar, { passive: true });
      });
    }
  }

  function createProfilePictureElement(pfpUrl, username, size = 'w-10 h-10') {
    const initial = username ? username.charAt(0).toUpperCase() : 'U';
    const container = document.createElement('div');
    container.className = `${size} rounded-full overflow-hidden bg-slate-100 border-2 border-white shadow-sm flex-shrink-0`;
    
    if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
      const img = document.createElement('img');
      img.src = pfpUrl;
      img.alt = username;
      img.className = 'h-full w-full object-cover';
      img.loading = 'lazy';
      img.onerror = function() {
        this.onerror = null;
        container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-sm">${initial}</div>`;
      };
      container.appendChild(img);
    } else {
      container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-sm">${initial}</div>`;
    }
    
    return container;
  }

  function showReplyPreview(messageData) {
    replyingTo = messageData;
    const replyPreview = document.getElementById('replyPreview');
    const replyToUsername = document.getElementById('replyToUsername');
    const replyToMessage = document.getElementById('replyToMessage');
    
    if (replyPreview && replyToUsername && replyToMessage) {
      replyToUsername.textContent = `Replying to ${messageData.username}`;
      replyToMessage.textContent = messageData.message;
      replyPreview.classList.remove('hidden');
      
      if (messageInput) messageInput.focus();
    }
  }

  function hideReplyPreview() {
    replyingTo = null;
    const replyPreview = document.getElementById('replyPreview');
    if (replyPreview) replyPreview.classList.add('hidden');
  }

function createMessageElement(data, isCurrentUser) {
    const messageItem = document.createElement('div');
    messageItem.className = `message-item flex gap-2 items-start ${isCurrentUser ? 'flex-row-reverse' : ''} animate-fade-in-up`;
    messageItem.dataset.messageId = data.messageId || `msg-${Date.now()}-${Math.random()}`;
    
    const pfpContainer = createProfilePictureElement(data.pfpUrl, data.username, 'w-8 h-8 sm:w-10 sm:h-10');
    const messageContent = document.createElement('div');
    messageContent.className = `flex flex-col ${isCurrentUser ? 'items-end' : 'items-start'} flex-1 min-w-0`;

    const headerDiv = document.createElement('div');
    headerDiv.className = `flex items-center gap-1.5 sm:gap-2 mb-1 px-1 ${isCurrentUser ? 'flex-row-reverse' : ''}`;
    
    const usernameSpan = document.createElement('span');
    usernameSpan.className = 'text-xs sm:text-sm font-semibold text-gray-200 truncate';
    usernameSpan.textContent = data.username || 'User';
    
    const timestampSpan = document.createElement('span');
    timestampSpan.className = 'text-[10px] sm:text-xs text-gray-500 whitespace-nowrap';
    timestampSpan.textContent = data.timestamp ? formatTimestamp(data.timestamp) : 'Just now';
    
    headerDiv.appendChild(usernameSpan);
    headerDiv.appendChild(timestampSpan);
    messageContent.appendChild(headerDiv);

    const bubbleWrapper = document.createElement('div');
    bubbleWrapper.className = `flex items-center gap-1`;

    const messageBubble = document.createElement('div');
    messageBubble.className = `px-3 sm:px-4 py-2 rounded-2xl ${isCurrentUser ? 'bg-[#33bfcc] text-white' : 'bg-[#2a2d33] text-gray-200'} break-words text-sm sm:text-base max-w-full`;

    if (data.replyTo) {
        const quotedDiv = document.createElement('div');
        quotedDiv.className = `quoted-message ${isCurrentUser ? '' : 'quoted-message-light'}`;
        
        const quotedUsername = document.createElement('div');
        quotedUsername.className = `text-xs font-semibold mb-1 ${isCurrentUser ? 'text-white/80' : 'text-[#33bfcc]'}`;
        quotedUsername.textContent = data.replyTo.username;
        
        const quotedText = document.createElement('div');
        quotedText.className = `text-xs ${isCurrentUser ? 'text-white/70' : 'text-gray-400'} break-words`;
        quotedText.textContent = data.replyTo.message;
        
        quotedDiv.appendChild(quotedUsername);
        quotedDiv.appendChild(quotedText);
        messageBubble.appendChild(quotedDiv);
    }

    const messageText = document.createElement('div');
    messageText.className = 'text-sm sm:text-base break-words';
    messageText.innerHTML = escapeHtml(data.message || '');
    messageBubble.appendChild(messageText);

    const replyBtn = document.createElement('button');
    replyBtn.className = 'reply-btn p-1 sm:p-1.5 hover:bg-gray-800 rounded-full transition-colors flex-shrink-0';
    replyBtn.title = 'Reply';
    replyBtn.innerHTML = '<span class="material-symbols-outlined text-gray-500 text-base sm:text-lg">reply</span>';
    replyBtn.addEventListener('click', () => {
        showReplyPreview({
            messageId: messageItem.dataset.messageId,
            username: data.username,
            message: data.message,
            userId: data.userId
        });
    }, { passive: true });

    if (isCurrentUser) {
        bubbleWrapper.appendChild(replyBtn);
        bubbleWrapper.appendChild(messageBubble);
    } else {
        bubbleWrapper.appendChild(messageBubble);
        bubbleWrapper.appendChild(replyBtn);
    }

    messageContent.appendChild(bubbleWrapper);
    messageItem.appendChild(pfpContainer);
    messageItem.appendChild(messageContent);
    
    return messageItem;
}

  // ============================================
  // CONFIRMATION DIALOG
  // ============================================
  
  function showConfirmationDialog() {
    return new Promise((resolve) => {
      const overlay = document.getElementById('confirmationOverlay');
      if (!overlay) return resolve(false);
      
      const dialogHTML = `
        <div class="confirmation-overlay">
          <div class="confirmation-dialog">
            <div style="text-align: center; margin-bottom: 1rem;">
              <div style="width: 64px; height: 64px; margin: 0 auto 1rem; background: #fef2f2; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                <span class="material-symbols-outlined" style="font-size: 32px; color: #dc2626;">warning</span>
              </div>
              <h3 style="font-size: 1.25rem; font-weight: 700; margin-bottom: 0.5rem; color: #1f2937;">Leave Chat Room?</h3>
              <p style="color: #6b7280; font-size: 0.95rem; line-height: 1.5;">
                You're currently in an active chat room. If you leave, you'll be disconnected from the conversation.
              </p>
            </div>
            <div class="confirmation-buttons">
              <button class="btn-stay" id="btnStay">Stay Here</button>
              <button class="btn-leave" id="btnLeave">Leave</button>
            </div>
          </div>
        </div>
      `;
      
      overlay.innerHTML = dialogHTML;
      overlay.style.display = 'flex';
      
      const btnStay = document.getElementById('btnStay');
      const btnLeave = document.getElementById('btnLeave');
      
      if (btnStay) {
        btnStay.addEventListener('click', () => {
          overlay.style.display = 'none';
          resolve(false);
        }, { once: true });
      }
      
     if (btnLeave) {
  btnLeave.addEventListener('click', async () => {
    console.log('‚úÖ User confirmed leaving via dialog - starting cleanup');
    overlay.style.display = 'none';
    
    // CRITICAL: Clean up background call FIRST
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    
    if (activeCallStr) {
      console.log('üìû Active call detected - cleaning up');
      
      try {
        const callData = JSON.parse(activeCallStr);
        
        // 1. Emit leave_call to server
        if (socketInstance && socketInstance.connected) {
          console.log('üì§ Emitting leave_call to server...');
          socketInstance.emit('leave_call', { callId: callData.callId });
          
          // Wait for server to process
          await new Promise(resolve => setTimeout(resolve, 500));
          console.log('‚úÖ Leave_call emitted and processed');
        }
        
        // 2. Clear all call-related storage
        localStorage.removeItem(ACTIVE_CALL_KEY);
        sessionStorage.removeItem('hasBackgroundCall');
        sessionStorage.removeItem('returningFromCall');
        sessionStorage.removeItem('backgroundCallMode');
        sessionStorage.removeItem('returningToBackgroundCall');
        
        console.log('‚úÖ Background call destroyed');
        
      } catch (e) {
        console.error('‚ùå Failed during call cleanup:', e);
      }
    }
    
    // 3. Leave chat room
    if (socketInstance && socketInstance.connected) {
      console.log('üì§ Emitting leave_room...');
      socketInstance.emit('leave_room');
      
      // Wait for server to process
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    clearChatState(true);
    
    resolve(true);
    
    // 5. Navigate - this will handle both iframe and standalone cases
    setTimeout(() => {
      console.log('‚úÖ Cleanup complete - initiating navigation');
      cleanupParentCallPage();
    }, 100);
    
  }, { once: true });
}
    });
  }

  // ============================================
  // BACK BUTTON HANDLER
  // ============================================
  
  function setupBackButtonHandler() {
    history.pushState({ page: 'chat' }, '', window.location.href);
    
    window.addEventListener('popstate', async (event) => {
      if (backButtonHandled) return;
      
      console.log('‚¨ÖÔ∏è Back button pressed');
      history.pushState({ page: 'chat' }, '', window.location.href);
      
      const shouldLeave = await showConfirmationDialog();
      
      if (shouldLeave) {
        console.log('‚úÖ User confirmed leaving');
        backButtonHandled = true;
        
        if (socketInstance?.connected) {
          socketInstance.emit('leave_room');
        }
        
        clearChatState(true);
        window.location.href = '/mood.html';
      } else {
        console.log('‚ùå User staying in chat');
      }
    });
  }

  const updateTimer = () => {
    if (!serverExpiresAt) {
      console.warn('‚ö†Ô∏è No server expiresAt available');
      if (timeRemaining) {
        timeRemaining.textContent = '-- remaining';
      }
      return;
    }
    
    // CRITICAL: Always use server-adjusted time
    const clientNow = Date.now();
    const serverNow = clientNow + serverClockOffset;
    const remaining = Math.max(0, serverExpiresAt - serverNow);
    
    const minutes = Math.floor(remaining / 60000);
    const seconds = Math.floor((remaining % 60000) / 1000);
    
    if (timeRemaining) {
      timeRemaining.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} remaining`;
    }
    
    // Debug log every 10 seconds
    if (Math.floor(serverNow / 10000) !== Math.floor((serverNow - 1000) / 10000)) {
      console.log(`‚è∞ Timer: ${minutes}:${seconds.toString().padStart(2, '0')} (offset: ${(serverClockOffset/1000).toFixed(1)}s)`);
    }
    
    if (remaining === 0) {
      console.error('‚ùå Room expired - redirecting');
      if (timerInterval) clearInterval(timerInterval);
      toast('Room has expired', 'warning');
      clearChatState(true);
      setTimeout(() => window.location.href = '/mood.html', 2000);
    }
  };

  // ============================================
  // SOCKET EVENT HANDLERS
  // ============================================
  
  function setupSocketHandlers() {
    if (!socketInstance) return;
    
    
    socketInstance.on('cached_call_valid', (data) => {
    console.log('‚úÖ Cached call validated by server:', data.callId);
    console.log(`   Showing modal for call from ${data.callerUsername}`);
    
    showCachedCallModal(data);
});

socketInstance.on('cached_call_invalid', (data) => {
    console.log('‚ùå Cached call invalid:', data.callId);
    localStorage.removeItem(CACHED_CALL_KEY);
    console.log('üóëÔ∏è Cleared invalid cached call');
});
    
socketInstance.on('connect', () => {
  console.log('üîå ========================================');
  console.log('üîå SOCKET CONNECTED');
  console.log('üîå ========================================');
  console.log(`   Socket ID: ${socketInstance.id}`);
  console.log(`   User: ${currentUser?.username || 'unknown'}`);
  
  // CRITICAL: Reset auth state on new connection
  setAuthenticationState(false);
  
  firebase.auth().currentUser?.getIdToken().then(idToken => {
    console.log('üì§ Sending authentication to server...');
    socketInstance.emit('authenticate', {
      token: idToken,
      userId: currentUser.userId
    });
  }).catch(err => {
    console.error('‚ùå Failed to get token:', err);
    toast('Authentication failed. Please refresh.', 'error');
  });
  
  console.log('üîå ========================================\n');
});

socketInstance.on('connect_error', (error) => {
  console.error('‚ùå Socket connection error:', error.message);
  setAuthenticationState(false);
  toast('Connection error. Retrying...', 'warning');
});

socketInstance.on('disconnect', (reason) => {
  console.log('üîå Socket disconnected:', reason);
  setAuthenticationState(false);
  
  if (reason === 'io server disconnect') {
    // Server disconnected us, need to reconnect manually
    socketInstance.connect();
  }
});

socketInstance.on('authenticated', async () => {
  console.log('‚úÖ ========================================');
  console.log('‚úÖ SOCKET AUTHENTICATED');
  console.log('‚úÖ ========================================');
  console.log(`   Socket ID: ${socketInstance.id}`);
  console.log(`   User: ${currentUser?.username} (${currentUser?.userId})`);
  
  // CRITICAL: Set authentication state FIRST
  setAuthenticationState(true);
  
  // Request room data from server for clock sync
  const roomStr = localStorage.getItem('currentRoom');
  if (roomStr) {
    try {
      const localRoomData = JSON.parse(roomStr);
      console.log('üì¶ Requesting fresh room data for clock sync...');
      
      socketInstance.emit('request_room_sync', { roomId: localRoomData.roomId });
      
    } catch (e) {
      console.error('‚ùå Failed to parse room data:', e);
    }
  }
  
  startCachedCallMonitoring();
  socketInstance.emit('join_room', { roomId: roomData.roomId });
  
  console.log('‚úÖ ========================================\n');
});


socketInstance.on('call_created', (data) => {
  console.log('üìû ========================================');
  console.log('üìû CALL_CREATED EVENT RECEIVED');
  console.log('üìû ========================================');
  console.log(`   callId: ${data.callId}`);
  console.log(`   callType: ${data.callType}`);
  console.log(`   isInitiator: ${data.isInitiator}`);
  
  // Only navigate if we're the initiator
  if (data.isInitiator) {
    console.log('‚úÖ We initiated this call - navigating to call page');
    
    // Mark that we're navigating to call
    navigatingToCall = true;
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading');
      audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading');
      videoCallBtn.disabled = false;
    }
    
    // Save chat state
    saveChatState(roomData.roomId, messagesCache);
    sessionStorage.setItem('returningFromCall', 'true');
    
    // Store call data
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
      callId: data.callId,
      roomId: roomData.roomId,
      callType: data.callType,
      users: data.participants || []
    }));
    
    console.log(`‚úÖ Stored call data, navigating to call.html`);
    console.log('üìû ========================================\n');
    
    // Navigate to call page
    window.location.href = '/call.html';
  } else {
    console.log('‚ÑπÔ∏è Call created by someone else - staying in chat, showing JOIN button');
    console.log('üìû ========================================\n');
  }
});


socketInstance.on('room_joined', (data) => {
  console.log('‚úÖ ========================================');
  console.log('‚úÖ ROOM_JOINED EVENT RECEIVED');
  console.log('‚úÖ ========================================');
  console.log(`   roomId: ${data.roomId}`);
  
  // CRITICAL: Sync server time and expiry
  const clientNow = Date.now();
  
  if (data.serverTime) {
    serverClockOffset = data.serverTime - clientNow;
    console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
    console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
    console.log(`   ‚è∞ CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);
    
    if (Math.abs(serverClockOffset) > 5000) {
      console.warn(`‚ö†Ô∏è WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
    }
  } else {
    console.warn('‚ö†Ô∏è No serverTime in room_joined, assuming no clock skew');
    serverClockOffset = 0;
  }
  
  if (data.expiresAt) {
    serverExpiresAt = data.expiresAt;
    
    const serverNow = clientNow + serverClockOffset;
    const timeRemaining = data.expiresAt - serverNow;
    
    console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
    console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
    console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);
    
    // Update localStorage with synced data
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const localRoomData = JSON.parse(roomStr);
        localRoomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(localRoomData));
        console.log('‚úÖ Updated localStorage with server expiry time');
      } catch (e) {
        console.error('‚ùå Failed to update localStorage:', e);
      }
    }
  } else {
    console.error('‚ùå No expiresAt in room_joined data!');
  }
  
  // Try to restore cached state first
  const cachedState = loadChatState();
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  const isInIframe = window.parent && window.parent !== window;

  // Determine if we should restore from cache
  let shouldRestoreCache = false;

  if (activeCallStr && isInIframe) {
    try {
      const activeCall = JSON.parse(activeCallStr);
      if (activeCall.roomId === roomData.roomId && cachedState && cachedState.roomId === roomData.roomId) {
        shouldRestoreCache = true;
        console.log('üîÑ Active call in iframe detected - will restore cache');
      }
    } catch (e) {
      console.warn('Failed to check active call:', e);
    }
  }

  if (shouldRestoreCache) {
    console.log(`üì¶ Restoring cached chat state: ${cachedState.messages.length} messages`);
    
    // Restore messages from cache
    messagesCache = cachedState.messages || [];
    
    messagesCache.forEach(msg => {
      const isCurrentUser = msg.userId === currentUser.userId;
      const msgEl = createMessageElement(msg, isCurrentUser);
      messagesList?.appendChild(msgEl);
    });
    
    if (messagesList) {
      messagesList.scrollTop = messagesList.scrollHeight;
    }
    
    console.log('‚úÖ Chat state restored from cache');
    
    // DON'T clear the flag - we might navigate back again
    // Only clear when explicitly leaving the room or call ends
    
  } else if (data.chatHistory?.length > 0) {
    // No cache or fresh join - load from server
    console.log(`üìú Loading ${data.chatHistory.length} messages from server`);
    
    const existingIds = new Set(messagesCache.map(m => m.messageId || `${m.userId}-${m.timestamp}`));
    
    data.chatHistory.forEach(msg => {
      const msgId = msg.messageId || `${msg.userId}-${msg.timestamp}`;
      if (existingIds.has(msgId)) return;
      
      const isCurrentUser = msg.userId === currentUser.userId;
      const msgEl = createMessageElement(msg, isCurrentUser);
      messagesList?.appendChild(msgEl);
      messagesCache.push(msg);
    });
    
    if (messagesList) {
      messagesList.scrollTop = messagesList.scrollHeight;
    }
    
    saveChatState(roomData.roomId, messagesCache);
  }
  
// Restore call button state from cache
if (shouldRestoreCache && cachedState) {
    console.log('üîÑ Restoring call button state from cache:', cachedState.callButtonState);
    console.log('   Cached activeCallInRoom:', cachedState.activeCallInRoom);
    
    // CRITICAL FIX: Restore activeCallInRoom if it was cached OR if we can derive it
    if (cachedState.activeCallInRoom) {
        activeCallInRoom = cachedState.activeCallInRoom;
        console.log('üíæ Restored activeCallInRoom from cache:', activeCallInRoom);
    } else if (cachedState.callButtonState === 'back') {
        // User was in call - reconstruct activeCallInRoom from activeCall storage
        const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
        if (activeCallStr) {
            try {
                const activeCallData = JSON.parse(activeCallStr);
                activeCallInRoom = {
                    callId: activeCallData.callId,
                    callType: activeCallData.callType,
                    participantCount: 2 // Default assumption
                };
                console.log('üíæ Reconstructed activeCallInRoom from ACTIVE_CALL_KEY:', activeCallInRoom);
            } catch (e) {
                console.error('Failed to reconstruct activeCallInRoom:', e);
            }
        }
    } else if (cachedState.callButtonState === 'join' && !activeCallInRoom) {
        console.warn('‚ö†Ô∏è Cache says "join" but no activeCallInRoom - will wait for server update');
    }
    
    // Update button state immediately based on cache
    if (cachedState.callButtonState === 'back') {
        updateCallButtonState(true, activeCallInRoom || { participantCount: 1 }); // Will show "Back to Call"
    } else if (cachedState.callButtonState === 'join' && activeCallInRoom) {
        updateCallButtonState(true, activeCallInRoom); // Will show "Join Call"
    } else {
        updateCallButtonState(false); // Will show audio/video buttons
    }
    
    console.log('‚úÖ Call button state restored instantly');
}
  
  // Handle active call state (for call buttons) - this is the server update
  if (data.activeCall) {
    console.log('üìû Active call in room detected');
    
    // CRITICAL FIX: Store activeCallInRoom so Join button has data
    activeCallInRoom = {
      callId: data.activeCall.callId,
      callType: data.activeCall.callType,
      participantCount: data.activeCall.participantCount
    };
    console.log('üíæ Stored activeCallInRoom:', activeCallInRoom);
    
    // Only update button state if we didn't already restore from cache
    if (!shouldRestoreCache) {
      updateCallButtonState(true, data.activeCall);
    }
  } else if (!shouldRestoreCache) {
    // Only update if not restoring from cache
    console.log('üìû No active call in room');
    activeCallInRoom = null;
    updateCallButtonState(false);
  }
  
  // Start timer updates immediately with server-synced data
  console.log('‚è∞ Starting timer updates with server-synced time...');
  updateTimer();
  
  console.log('‚úÖ ========================================\n');
});


socketInstance.on('room_sync_data', (data) => {
  console.log('‚è∞ ========================================');
  console.log('‚è∞ ROOM SYNC DATA RECEIVED');
  console.log('‚è∞ ========================================');
  
  const clientNow = Date.now();
  
  if (!data.serverTime) {
    console.warn('‚ö†Ô∏è No serverTime in sync data, assuming no clock skew');
    data.serverTime = clientNow;
  }
  
  // Calculate clock offset
  serverClockOffset = data.serverTime - clientNow;
  
  console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
  console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
  console.log(`   ‚è∞ CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);
  
  if (Math.abs(serverClockOffset) > 5000) {
    console.warn(`‚ö†Ô∏è WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
    console.warn(`   Timer will be adjusted to compensate`);
  }
  
  if (data.expiresAt) {
    serverExpiresAt = data.expiresAt;
    
    // Calculate time remaining using server-adjusted time
    const serverNow = clientNow + serverClockOffset;
    const timeRemaining = data.expiresAt - serverNow;
    
    console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
    console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
    console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);
    
    // Update localStorage with synced data
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const localRoomData = JSON.parse(roomStr);
        localRoomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(localRoomData));
        console.log('‚úÖ Updated localStorage with server expiry time');
      } catch (e) {
        console.error('‚ùå Failed to update localStorage:', e);
      }
    }
  }
  
  console.log('‚è∞ ========================================\n');
  
  // Force timer update with new data
  updateTimer();
});

socketInstance.on('room_expired', (data) => {
  console.error('üí• ========================================');
  console.error('üí• ROOM_EXPIRED EVENT RECEIVED FROM SERVER');
  console.error('üí• ========================================');
  console.error(`   roomId: ${data.roomId}`);
  console.error(`   message: ${data.message}`);
  console.error(`   Server says room expired at: ${new Date().toISOString()}`);
  
  if (serverExpiresAt) {
    const serverExpiry = new Date(serverExpiresAt).toISOString();
    const clientNow = new Date().toISOString();
    const serverNow = new Date(Date.now() + serverClockOffset).toISOString();
    console.error(`   expiresAt was: ${serverExpiry}`);
    console.error(`   Client time now: ${clientNow}`);
    console.error(`   Server time now (adjusted): ${serverNow}`);
  }
  
  console.error('üí• ========================================\n');
  
  if (timerInterval) clearInterval(timerInterval);
  toast(data.message || 'Room has expired', 'warning');
  
  // Clear all storage
  clearChatState(true);
  localStorage.removeItem(ACTIVE_CALL_KEY);
  sessionStorage.removeItem('hasBackgroundCall');
  sessionStorage.removeItem('returningFromCall');
  
  // Navigate and cleanup parent if in iframe
  setTimeout(() => {
    cleanupParentCallPage();
  }, 2000);
});

socketInstance.on('room_expiring_soon', (data) => {
  console.warn('‚ö†Ô∏è ========================================');
  console.warn('‚ö†Ô∏è ROOM EXPIRING SOON');
  console.warn('‚ö†Ô∏è ========================================');
  console.warn(`   Expires in: ${data.expiresIn / 1000} seconds`);
  console.warn(`   expiresAt: ${new Date(data.expiresAt).toISOString()}`);
  
  const clientNow = Date.now();
  const serverNow = clientNow + serverClockOffset;
  const remaining = data.expiresAt - serverNow;
  
  console.warn(`   Client now: ${new Date(clientNow).toISOString()}`);
  console.warn(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
  console.warn(`   Remaining (adjusted): ${(remaining / 1000).toFixed(1)}s`);
  console.warn('‚ö†Ô∏è ========================================\n');
  
  toast('Room expiring soon!', 'warning');
});

socketInstance.on('room_expired', (data) => {
  console.error('üí• Room expired event from server');
  if (timerInterval) clearInterval(timerInterval);
  
  // CRITICAL: Clear active call to remove floating button
  localStorage.removeItem('activeCall');
  sessionStorage.removeItem('hasBackgroundCall');
  
  toast('Room has expired', 'warning');
  clearChatState(true);
  setTimeout(() => window.location.href = '/mood.html', 2000);
});

socketInstance.on('error', (data) => {
  console.error('‚ùå ========================================');
  console.error('‚ùå SOCKET ERROR EVENT');
  console.error('‚ùå ========================================');
  console.error('   Error code:', data.code);
  console.error('   Error message:', data.message);
  console.error('   Timestamp:', new Date().toISOString());
  console.error('   isInitiatingCall:', isInitiatingCall);
  console.error('   isSocketAuthenticated:', isSocketAuthenticated);
  
  // CRITICAL: Always clear initiating state on any error
  const wasInitiating = isInitiatingCall;
  isInitiatingCall = false;
  
  // CRITICAL: Handle authentication errors with auto-recovery
  if (data.message === 'Not authenticated') {
    console.error('‚ùå NOT AUTHENTICATED ERROR RECEIVED');
    console.error('   This indicates a race condition - call initiated before auth completed');
    console.error('   Current auth state:', isSocketAuthenticated);
    console.error('   Socket connected:', socketInstance?.connected);
    console.error('   User data exists:', !!currentUser);
    console.error('   Was initiating call:', wasInitiating);
    
    // Clear call loading states immediately
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
        console.error('   ‚è∞ Cleared audio button timeout:', timeoutId);
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
        console.error('   ‚è∞ Cleared video button timeout:', timeoutId);
      }
    }
    
    console.error('   üîí Call loading states cleared');
    
    // Force re-authentication
    setAuthenticationState(false);
    
    // Attempt to recover
    if (socketInstance && socketInstance.connected && currentUser) {
      console.log('üîÑ Attempting authentication recovery...');
      
      firebase.auth().currentUser?.getIdToken(true).then(idToken => {
        console.log('üì§ Re-sending authentication with fresh token...');
        socketInstance.emit('authenticate', {
          token: idToken,
          userId: currentUser.userId
        });
        
        toast('Reconnecting...', 'info');
        
        // Set recovery timeout
        const recoveryTimeout = setTimeout(() => {
          if (!isSocketAuthenticated) {
            console.error('‚ùå Recovery timeout - authentication failed after 10s');
            toast('Authentication failed. Please refresh the page.', 'error');
          } else {
            console.log('‚úÖ Authentication recovered successfully');
            
            // If user was trying to initiate a call, show helpful message
            if (wasInitiating) {
              toast('Connected! You can now start a call.', 'success');
            }
          }
        }, 10000);
        
        console.log('‚è∞ Recovery timeout set:', recoveryTimeout);
        
      }).catch(err => {
        console.error('‚ùå Recovery authentication failed:', err);
        toast('Authentication failed. Please refresh the page.', 'error');
      });
    } else {
      console.error('‚ùå Cannot recover - missing socket or user data');
      console.error('   Socket exists:', !!socketInstance);
      console.error('   Socket connected:', socketInstance?.connected);
      console.error('   Current user:', !!currentUser);
      toast('Connection lost. Please refresh the page.', 'error');
    }
    
    console.error('‚ùå ========================================\n');
    return;
  }
  
  // CRITICAL FIX: Handle CALL_ALREADY_ACTIVE error - auto-join instead
  if (data.code === 'CALL_ALREADY_ACTIVE') {
    console.log('üîÑ ========================================');
    console.log('üîÑ CALL_ALREADY_ACTIVE ERROR HANDLING');
    console.log('üîÑ ========================================');
    console.log(`   Existing callId: ${data.callId}`);
    console.log(`   callType: ${data.callType}`);
    console.log(`   participantCount: ${data.participantCount}`);
    console.log(`   Was initiating: ${wasInitiating}`);
    
    // Clear loading states from call initiation
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
        console.log('   ‚è∞ Cleared audio button timeout');
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
        console.log('   ‚è∞ Cleared video button timeout');
      }
    }
    
    // Re-enable buttons if authenticated
    if (isSocketAuthenticated) {
      console.log('   ‚úÖ Re-enabling call buttons (authenticated)');
      enableCallButtons();
    } else {
      console.log('   ‚è≥ Keeping buttons disabled (not authenticated)');
    }
    
    // Store the active call info
    activeCallInRoom = {
      callId: data.callId,
      callType: data.callType || 'audio',
      participantCount: data.participantCount || 1
    };
    console.log('üíæ Stored activeCallInRoom:', activeCallInRoom);
    
    // Update UI to show join button
    updateCallButtonState(true, activeCallInRoom);
    
    // Show friendly message
    toast('A call is already active. Click "Join Call" to join.', 'success');
    console.log('üîÑ ========================================\n');
    return;
  }
  
  // Handle room-related errors
  if (data.code === 'ROOM_NOT_FOUND' || data.code === 'NOT_IN_ROOM') {
    console.error('‚ùå ROOM ERROR:', data.code);
    console.error('   Message:', data.message);
    console.error('   Current room:', roomData?.roomId);
    console.error('   Was initiating:', wasInitiating);
    
    toast('Room no longer available', 'error');
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
      }
    }
    
    // Clear all storage
    clearChatState(true);
    localStorage.removeItem(ACTIVE_CALL_KEY);
    sessionStorage.removeItem('hasBackgroundCall');
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    sessionStorage.removeItem('returningToBackgroundCall');
    
    console.error('üóëÔ∏è Cleared all storage due to room error');
    
    // Navigate and cleanup parent if in iframe
    setTimeout(() => {
      console.error('üîÑ Navigating to mood.html after room error');
      cleanupParentCallPage();
    }, 2000);
    
    console.error('‚ùå ========================================\n');
    return;
  }
  
  // Handle room expiry errors
  if (data.code === 'ROOM_EXPIRED') {
    console.error('üí• ROOM EXPIRED ERROR');
    console.error('   Message:', data.message);
    console.error('   Room:', roomData?.roomId);
    console.error('   Was initiating:', wasInitiating);
    
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    
    toast('Room has expired', 'warning');
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
      }
    }
    
    // Clear all storage
    clearChatState(true);
    localStorage.removeItem(ACTIVE_CALL_KEY);
    sessionStorage.removeItem('hasBackgroundCall');
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    sessionStorage.removeItem('returningToBackgroundCall');
    
    console.error('üóëÔ∏è Cleared all storage due to room expiry');
    
    setTimeout(() => {
      console.error('üîÑ Navigating to mood.html after room expiry');
      cleanupParentCallPage();
    }, 2000);
    
    console.error('‚ùå ========================================\n');
    return;
  }
  
  // Handle call-related errors
  if (data.code === 'CALL_NOT_FOUND' || data.code === 'CALL_ENDED') {
    console.error('‚ùå CALL ERROR:', data.code);
    console.error('   Message:', data.message);
    console.error('   Was initiating:', wasInitiating);
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
      }
    }
    if (joinCallBtn) {
      joinCallBtn.classList.remove('join-btn-loading');
      joinCallBtn.disabled = false;
    }
    
    // Re-enable buttons if authenticated
    if (isSocketAuthenticated) {
      console.log('   ‚úÖ Re-enabling call buttons');
      enableCallButtons();
    }
    
    // Clear active call state
    activeCallInRoom = null;
    updateCallButtonState(false);
    
    toast(data.message || 'Call is no longer available', 'warning');
    console.error('‚ùå ========================================\n');
    return;
  }
  
  // Handle join call failures
  if (data.code === 'JOIN_FAILED' || data.code === 'PARTICIPANT_RESOLUTION_FAILED' || data.code === 'STATE_MISMATCH') {
    console.error('‚ùå JOIN CALL ERROR:', data.code);
    console.error('   Message:', data.message);
    
    // Clear join button loading state
    if (joinCallBtn) {
      joinCallBtn.classList.remove('join-btn-loading');
      joinCallBtn.disabled = false;
    }
    if (acceptCallBtn) {
      acceptCallBtn.classList.remove('join-btn-loading');
      acceptCallBtn.disabled = false;
    }
    
    toast(data.message || 'Failed to join call. Please try again.', 'error');
    console.error('‚ùå ========================================\n');
    return;
  }
  
  // Generic error handling
  console.error('‚ùå GENERIC ERROR');
  console.error('   Code:', data.code || 'UNKNOWN');
  console.error('   Message:', data.message || 'An error occurred');
  console.error('   Was initiating:', wasInitiating);
  
  // Clear any loading states on generic errors
  if (audioCallBtn) {
    audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
    const timeoutId = audioCallBtn.dataset.timeoutId;
    if (timeoutId) {
      clearTimeout(parseInt(timeoutId));
      delete audioCallBtn.dataset.timeoutId;
    }
  }
  if (videoCallBtn) {
    videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
    const timeoutId = videoCallBtn.dataset.timeoutId;
    if (timeoutId) {
      clearTimeout(parseInt(timeoutId));
      delete videoCallBtn.dataset.timeoutId;
    }
  }
  if (joinCallBtn) {
    joinCallBtn.classList.remove('join-btn-loading');
    joinCallBtn.disabled = false;
  }
  
  // Re-enable buttons if authenticated
  if (isSocketAuthenticated) {
    console.log('   ‚úÖ Re-enabling call buttons');
    enableCallButtons();
  } else {
    console.log('   ‚è≥ Not authenticated - buttons will enable after auth completes');
  }
  
  toast(data.message || 'An error occurred', 'error');
  console.error('‚ùå ========================================\n');
});

    socketInstance.on('chat_message', (data) => {
      if (!data.messageId) {
        data.messageId = `msg-${data.userId}-${data.timestamp || Date.now()}`;
      }
      
      const isCurrentUser = data.userId === currentUser.userId;
      const msgEl = createMessageElement(data, isCurrentUser);
      
      if (messagesList) {
        messagesList.appendChild(msgEl);
        messagesList.scrollTop = messagesList.scrollHeight;
      }
      
      messagesCache.push(data);
      saveChatState(roomData.roomId, messagesCache);
    });

    socketInstance.on('user_left', (data) => {
      const msgEl = document.createElement('div');
      msgEl.className = 'text-center text-xs sm:text-sm text-gray-400 my-2';
      msgEl.textContent = `${data.username || 'A user'} left the room`;
      messagesList?.appendChild(msgEl);

      if (onlineCount && data.remainingUsers !== undefined) {
        onlineCount.textContent = `${data.remainingUsers} Online`;
      }

      if (data.remainingUsers <= 1) {
        toast('Room closing...', 'warning');
        clearChatState(true);
        setTimeout(() => window.location.href = '/mood.html', 2000);
      }
    });

socketInstance.on('left_room', (data) => {
  console.log('üëã Received left_room confirmation from server');
  toast('Left room', 'success');
  
  // CRITICAL: Don't clear storage here - already done in leave button handler
  // Just disconnect socket
  if (socketInstance) {
    socketInstance.disconnect();
  }
  
  console.log('‚úÖ Socket disconnected after leaving room');
});

socketInstance.on('incoming_call', (data) => {
  console.log('üìû ========================================');
  console.log('üìû INCOMING_CALL EVENT RECEIVED');
  console.log('üìû ========================================');
  console.log(`   Caller: ${data.callerUsername}`);
  console.log(`   Call ID: ${data.callId}`);
  console.log(`   Type: ${data.callType}`);
  
  // CRITICAL: Cache the call immediately
  const cachedCall = {
    callId: data.callId,
    callerUsername: data.callerUsername,
    callerPfp: data.callerPfp,
    callType: data.callType,
    roomId: data.roomId,
    timestamp: Date.now()
  };
  
  try {
    localStorage.setItem(CACHED_CALL_KEY, JSON.stringify(cachedCall));
    console.log('üíæ Call cached to localStorage');
  } catch (e) {
    console.error('‚ùå Failed to cache call:', e);
  }
  
  // Set pending call data
  pendingCallData = data;
  
  // Update modal UI
  const callerName = document.getElementById('callerName');
  const callType = document.getElementById('callType');
  const callerAvatar = document.getElementById('callerAvatar');
  
  if (callerName) callerName.textContent = `${data.callerUsername} is calling`;
  if (callType) callType.textContent = data.callType === 'video' ? 'Video Call' : 'Audio Call';
  if (callerAvatar) {
    callerAvatar.innerHTML = '';
    const pfp = createProfilePictureElement(data.callerPfp, data.callerUsername, 'w-full h-full');
    callerAvatar.appendChild(pfp);
  }
  
  // Show modal after 2 second delay
  setTimeout(() => {
    if (pendingCallData && pendingCallData.callId === data.callId) {
      incomingCallModal?.classList.remove('hidden');
      console.log(`‚úÖ Showing incoming call modal after 2s delay`);
    } else {
      console.log(`üìû Call already handled, skipping modal display`);
    }
  }, 2000);
  
  console.log('üìû ========================================\n');
});

    socketInstance.on('call_accepted', (data) => {
    console.log('‚úÖ Call accepted:', data);
    
    // Clear loading states
    isInitiatingCall = false;
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.classList.remove('calling');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.classList.remove('calling');
        videoCallBtn.disabled = false;
    }
    
    navigatingToCall = true;
    
    saveChatState(roomData.roomId, messagesCache);
    sessionStorage.setItem('returningFromCall', 'true');
    
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
        callId: data.callId,
        roomId: roomData.roomId,
        callType: data.callType,
        users: data.users
    }));
    
    console.log('üöÄ Navigating to call');
    window.location.href = '/call.html';
});

socketInstance.on('call_declined', (data) => {
    console.log('‚ùå Call was declined');
    
    // Clear loading states
    toast('Call was declined', 'warning');
    isInitiatingCall = false;
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.classList.remove('calling');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.classList.remove('calling');
        videoCallBtn.disabled = false;
    }
});

    socketInstance.on('call_declined', (data) => {
      toast('Call was declined', 'warning');
      isInitiatingCall = false;
      audioCallBtn?.classList.remove('calling');
      videoCallBtn?.classList.remove('calling');
    });
    
    socketInstance.on('call_state_update', (data) => {
  console.log('üìû Call state update:', data);
  
  if (data.isActive && data.participantCount > 0) {
    // CRITICAL FIX: Store call data so JOIN button can access it
    activeCallInRoom = {
      callId: data.callId,
      callType: data.callType,
      participantCount: data.participantCount
    };
    console.log(`üìû Stored active call: ${data.callId} with ${data.participantCount} participants`);
    
    updateCallButtonState(true, data);
  } else {
    // CRITICAL FIX: Clear call data when call ends
    activeCallInRoom = null;
    console.log('üìû Cleared active call - no participants');
    
    updateCallButtonState(false);
  }
});


    socketInstance.on('call_ended_notification', (data) => {
      console.log('üìû Call ended:', data.callId);
      updateCallButtonState(false);
    });

socketInstance.on('join_existing_call_success', (data) => {
  console.log('‚úÖ ========================================');
  console.log('‚úÖ JOIN_EXISTING_CALL_SUCCESS');
  console.log('‚úÖ ========================================');
  console.log(`   callId: ${data.callId}`);
  console.log(`   callType: ${data.callType}`);
  console.log(`   roomId: ${data.roomId}`);
  
  // Remove loading states
  if (joinCallBtn) {
    joinCallBtn.classList.remove('join-btn-loading');
    joinCallBtn.disabled = false;
  }
  if (acceptCallBtn) {
    acceptCallBtn.classList.remove('join-btn-loading');
    acceptCallBtn.disabled = false;
  }
  
  // Mark navigating
  navigatingToCall = true;
  
  // Save chat state (if not already saved)
  saveChatState(roomData.roomId, messagesCache);
  sessionStorage.setItem('returningFromCall', 'true');
  
  // Ensure call data is stored (should already be, but verify)
  const storedCall = localStorage.getItem(ACTIVE_CALL_KEY);
  console.log(`   Stored call data exists: ${!!storedCall}`);
  
  if (!storedCall) {
    console.warn('‚ö†Ô∏è No stored call data - storing now');
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
      callId: data.callId,
      roomId: data.roomId,
      callType: data.callType,
      users: []
    }));
  }
  
  console.log('üöÄ Navigating to call page in 500ms...');
  console.log('‚úÖ ========================================\n');
  
  // Navigate to call with small delay to ensure storage is written
  setTimeout(() => {
    window.location.href = '/call.html';
  }, 500);
});
  }

  // ============================================
  // EVENT LISTENERS
  // ============================================
  
  function setupEventListeners() {
    // Sidebar
    sidebarToggle?.addEventListener('click', toggleSidebar, { passive: true });
    sidebarClose?.addEventListener('click', closeSidebar, { passive: true });
    sidebarOverlay?.addEventListener('click', closeSidebar, { passive: true });
    
    // Reply
    cancelReplyBtn?.addEventListener('click', hideReplyPreview, { passive: true });
    
if (audioCallBtn) {
  audioCallBtn.addEventListener('click', async () => {
    console.log('üìû ========================================');
    console.log('üìû AUDIO CALL BUTTON CLICKED');
    console.log('üìû ========================================');
    console.log(`   Authentication state: ${isSocketAuthenticated}`);
    console.log(`   Socket connected: ${socketInstance?.connected}`);
    console.log(`   Already initiating: ${isInitiatingCall}`);
    
    // CRITICAL: Block if already initiating
    if (isInitiatingCall) {
      console.log('‚ö†Ô∏è Call already being initiated, ignoring click');
      console.log('üìû ========================================\n');
      return;
    }
    
    // CRITICAL: Wait for authentication if not ready
    if (!isSocketAuthenticated) {
      console.log('‚è≥ Not authenticated yet - waiting...');
      audioCallBtn.disabled = true;
      audioCallBtn.classList.add('animate-pulse');
      
      try {
        await waitForAuthentication();
        console.log('‚úÖ Authentication complete, proceeding with call');
      } catch (e) {
        console.error('‚ùå Authentication wait failed:', e);
        toast('Connection failed. Please refresh.', 'error');
        audioCallBtn.disabled = false;
        audioCallBtn.classList.remove('animate-pulse');
        console.log('üìû ========================================\n');
        return;
      }
    }
    
    // CRITICAL: Verify socket still connected
    if (!socketInstance || !socketInstance.connected) {
      console.error('‚ùå Socket disconnected during call initiation');
      toast('Connection lost. Please refresh.', 'error');
      console.log('üìû ========================================\n');
      return;
    }
    
    console.log('‚úÖ All checks passed - initiating audio call');
    isInitiatingCall = true;
    
    // Add loading state
    audioCallBtn.classList.add('call-btn-loading');
    audioCallBtn.disabled = true;
    if (videoCallBtn) {
      videoCallBtn.classList.add('calling');
      videoCallBtn.disabled = true;
    }
    
    socketInstance.emit('initiate_call', {
      roomId: roomData.roomId,
      callType: 'audio'
    });
    
    console.log('üì§ Audio call initiation sent to server');
    toast('Calling...', 'success');
    
    // Timeout after 30 seconds with recovery
    const timeoutId = setTimeout(() => {
      if (isInitiatingCall) {
        console.log('‚è∞ Call initiation timeout (30s)');
        isInitiatingCall = false;
        audioCallBtn.classList.remove('call-btn-loading');
        if (videoCallBtn) {
          videoCallBtn.classList.remove('calling');
        }
        
        // CRITICAL: Re-enable buttons after timeout
        if (isSocketAuthenticated) {
          enableCallButtons();
        }
        
        toast('Call timeout - no response', 'warning');
      }
    }, 30000);
    
    // Store timeout for cleanup
    audioCallBtn.dataset.timeoutId = timeoutId;
    
    console.log('üìû ========================================\n');
    
  }, { passive: true });
}

if (videoCallBtn) {
  videoCallBtn.addEventListener('click', async () => {
    console.log('üìû ========================================');
    console.log('üìû VIDEO CALL BUTTON CLICKED');
    console.log('üìû ========================================');
    console.log(`   Authentication state: ${isSocketAuthenticated}`);
    console.log(`   Socket connected: ${socketInstance?.connected}`);
    console.log(`   Already initiating: ${isInitiatingCall}`);
    
    // CRITICAL: Block if already initiating
    if (isInitiatingCall) {
      console.log('‚ö†Ô∏è Call already being initiated, ignoring click');
      console.log('üìû ========================================\n');
      return;
    }
    
    // CRITICAL: Wait for authentication if not ready
    if (!isSocketAuthenticated) {
      console.log('‚è≥ Not authenticated yet - waiting...');
      videoCallBtn.disabled = true;
      videoCallBtn.classList.add('animate-pulse');
      
      try {
        await waitForAuthentication();
        console.log('‚úÖ Authentication complete, proceeding with call');
      } catch (e) {
        console.error('‚ùå Authentication wait failed:', e);
        toast('Connection failed. Please refresh.', 'error');
        videoCallBtn.disabled = false;
        videoCallBtn.classList.remove('animate-pulse');
        console.log('üìû ========================================\n');
        return;
      }
    }
    
    // CRITICAL: Verify socket still connected
    if (!socketInstance || !socketInstance.connected) {
      console.error('‚ùå Socket disconnected during call initiation');
      toast('Connection lost. Please refresh.', 'error');
      console.log('üìû ========================================\n');
      return;
    }
    
    console.log('‚úÖ All checks passed - initiating video call');
    isInitiatingCall = true;
    
    // Add loading state
    videoCallBtn.classList.add('call-btn-loading');
    videoCallBtn.disabled = true;
    if (audioCallBtn) {
      audioCallBtn.classList.add('calling');
      audioCallBtn.disabled = true;
    }
    
    socketInstance.emit('initiate_call', {
      roomId: roomData.roomId,
      callType: 'video'
    });
    
    console.log('üì§ Video call initiation sent to server');
    toast('Calling...', 'success');
    
    // Timeout after 30 seconds with recovery
    const timeoutId = setTimeout(() => {
      if (isInitiatingCall) {
        console.log('‚è∞ Call initiation timeout (30s)');
        isInitiatingCall = false;
        videoCallBtn.classList.remove('call-btn-loading');
        if (audioCallBtn) {
          audioCallBtn.classList.remove('calling');
        }
        
        // CRITICAL: Re-enable buttons after timeout
        if (isSocketAuthenticated) {
          enableCallButtons();
        }
        
        toast('Call timeout - no response', 'warning');
      }
    }, 30000);
    
    // Store timeout for cleanup
    videoCallBtn.dataset.timeoutId = timeoutId;
    
    console.log('üìû ========================================\n');
    
  }, { passive: true });
}



if (joinCallBtn) {
    joinCallBtn.addEventListener('click', () => {
        console.log('üîò ========================================');
        console.log('üîò JOIN CALL BUTTON CLICKED');
        console.log('üîò ========================================');
        
        // Check if this is "Back to Call" or "Join Call"
        const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
        const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomData?.roomId;
        
        console.log(`   activeCallStr exists: ${!!activeCallStr}`);
        console.log(`   userInCall: ${userInCall}`);
        console.log(`   activeCallInRoom exists: ${!!activeCallInRoom}`);
        
        if (userInCall) {
            // User is already in call - show call UI in iframe/overlay
            console.log('üìû BACK TO CALL MODE');
            
            const activeCallData = JSON.parse(activeCallStr);
            console.log(`   callId: ${activeCallData.callId}`);
            console.log(`   Call is running in background - will hide chat overlay`);
            
            if (window.parent && window.parent !== window) {
                console.log('üì± We are in iframe - posting message to parent');
                window.parent.postMessage({ action: 'hideChat' }, '*');
            } else {
                console.log('‚ö†Ô∏è Not in iframe - navigating directly');
                window.location.href = '/call.html';
            }
            
            console.log('üîò ========================================\n');
        } else {
            // No active call - join existing call
            console.log('üìû JOIN EXISTING CALL MODE');
            
            if (!activeCallInRoom) {
                console.error('‚ùå activeCallInRoom is null/undefined!');
                console.log('   This should not happen - UI should not show Join button');
                toast('No active call to join', 'warning');
                console.log('üîò ========================================\n');
                return;
            }
            
            console.log(`   activeCallInRoom.callId: ${activeCallInRoom.callId}`);
            console.log(`   activeCallInRoom.callType: ${activeCallInRoom.callType}`);
            console.log(`   activeCallInRoom.participantCount: ${activeCallInRoom.participantCount}`);
            console.log(`   roomData.roomId: ${roomData.roomId}`);
            
            // Add loading state
            joinCallBtn.classList.add('join-btn-loading');
            joinCallBtn.disabled = true;
            console.log('‚è≥ Join button set to loading state');
            
            // CRITICAL FIX: Store call data BEFORE emitting join_existing_call
            const callDataToStore = {
                callId: activeCallInRoom.callId,
                roomId: roomData.roomId,
                callType: activeCallInRoom.callType,
                users: []
            };
            
            localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify(callDataToStore));
            console.log('üíæ Stored call data to localStorage (pre-join):');
            console.log('   ', JSON.stringify(callDataToStore, null, 2));
            
            const eventData = {
                callId: activeCallInRoom.callId,
                roomId: roomData.roomId
            };
            
            console.log('üì§ Emitting join_existing_call with data:');
            console.log('   ', JSON.stringify(eventData, null, 2));
            
            if (!socketInstance || !socketInstance.connected) {
                console.error('‚ùå Socket not connected!');
                toast('Connection lost. Please refresh the page.', 'error');
                joinCallBtn.classList.remove('join-btn-loading');
                joinCallBtn.disabled = false;
                console.log('üîò ========================================\n');
                return;
            }
            
            socketInstance.emit('join_existing_call', eventData);
            
            toast('Joining call...', 'success');
            console.log('‚úÖ Event emitted successfully');
            console.log('üîò ========================================\n');
        }
    }, { passive: true });
}

if (acceptCallBtn) {
  acceptCallBtn.addEventListener('click', () => {
    if (pendingCallData) {
      const callToAccept = pendingCallData;
      pendingCallData = null;
      
      console.log('‚úÖ ========================================');
      console.log('‚úÖ USER ACCEPTED INCOMING CALL');
      console.log('‚úÖ ========================================');
      console.log(`   callId: ${callToAccept.callId}`);
      
      // Clear cached call
      localStorage.removeItem(CACHED_CALL_KEY);
      
      // Hide modal
      incomingCallModal?.classList.add('hidden');
      
      // Mark navigating
      navigatingToCall = true;
      
      // Add loading state
      acceptCallBtn.classList.add('join-btn-loading');
      acceptCallBtn.disabled = true;
      
      // Save chat state
      saveChatState(roomData.roomId, messagesCache);
      sessionStorage.setItem('returningFromCall', 'true');
      
      // CRITICAL FIX: Store call data BEFORE emitting join_existing_call
      localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
        callId: callToAccept.callId,
        roomId: roomData.roomId,
        callType: callToAccept.callType,
        users: []
      }));
      console.log('üíæ Stored call data to localStorage (pre-join)');
      
      console.log('üì§ Emitting join_existing_call to server');
      
      // Use join_existing_call to ensure server adds us to participants list first
      socketInstance?.emit('join_existing_call', {
        callId: callToAccept.callId,
        roomId: roomData.roomId
      });
      
      console.log('‚úÖ Join request sent - will navigate on success');
      console.log('‚úÖ ========================================\n');
      
      // Don't navigate here - wait for join_existing_call_success event
    }
  }, { passive: true });
}

if (declineCallBtn) {
  declineCallBtn.addEventListener('click', () => {
    if (pendingCallData) {
      const callToDecline = pendingCallData;
      pendingCallData = null;
      
      console.log('‚ùå ========================================');
      console.log('‚ùå USER DECLINED INCOMING CALL');
      console.log('‚ùå ========================================');
      console.log(`   callId: ${callToDecline.callId}`);
      console.log(`   Call remains active - user can still join via JOIN button`);
      
      // Clear cached call
      localStorage.removeItem(CACHED_CALL_KEY);
      console.log('üóëÔ∏è Cleared cached call after decline');
      
      // Hide modal
      incomingCallModal?.classList.add('hidden');
      
      console.log('‚úÖ Modal dismissed - call still active in room');
      console.log('‚ùå ========================================\n');
    }
  }, { passive: true });
}

    // Message form
    if (messageForm) {
      messageForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const message = messageInput?.value.trim();
        if (!message) return;

        const messageData = {
          roomId: roomData.roomId,
          message: message
        };

        if (replyingTo) {
          messageData.replyTo = {
            messageId: replyingTo.messageId,
            username: replyingTo.username,
            message: replyingTo.message,
            userId: replyingTo.userId
          };
          hideReplyPreview();
        }

        socketInstance?.emit('chat_message', messageData);
        if (messageInput) messageInput.value = '';
      });
    }

leaveBtn?.addEventListener('click', async () => {
  console.log('üö™ Leave button clicked - starting cleanup sequence');
  stopCachedCallMonitoring();
  
  // CRITICAL: Check if there's a background call running
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  
  if (activeCallStr) {
    console.log('üìû Active call detected - cleaning up before leaving');
    
    try {
      const callData = JSON.parse(activeCallStr);
      
      // 1. Emit leave_call to server
      if (socketInstance && socketInstance.connected) {
        console.log('üì§ Emitting leave_call to server...');
        socketInstance.emit('leave_call', { callId: callData.callId });
        
        // Wait for server to process the leave_call
        await new Promise(resolve => setTimeout(resolve, 500));
        console.log('‚úÖ Leave_call processed');
      }
      
      // 2. Clear all call-related storage
      localStorage.removeItem(ACTIVE_CALL_KEY);
      sessionStorage.removeItem('hasBackgroundCall');
      sessionStorage.removeItem('returningFromCall');
      sessionStorage.removeItem('backgroundCallMode');
      sessionStorage.removeItem('returningToBackgroundCall');
      
      console.log('‚úÖ All call data cleared');
      
    } catch (e) {
      console.error('‚ùå Error during call cleanup:', e);
    }
  }
  
  // 3. Leave the chat room
  if (socketInstance && socketInstance.connected) {
    console.log('üì§ Emitting leave_room...');
    socketInstance.emit('leave_room');
    
    // Wait for server to process
    await new Promise(resolve => setTimeout(resolve, 300));
  }
  
  // 4. Clear chat state
  clearChatState(true);
  
  // 5. Navigate - this will handle both iframe and standalone cases
  console.log('‚úÖ Cleanup complete - initiating navigation');
  cleanupParentCallPage();
});

    // Visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        console.log('üì± Page hidden');
        saveChatState(roomData.roomId, messagesCache);
      } else {
        console.log('üì± Page visible');
      }
    });

window.addEventListener('beforeunload', (e) => {
  console.log('üö™ Chat page beforeunload event');
  stopCachedCallMonitoring();
  // CRITICAL: Check if in background call mode
  if (isInBackgroundCall) {
    console.log('üîí Background call active - preserving floating socket');
    saveChatState(roomData.roomId, messagesCache);
    
    // Don't disconnect floating socket - let it persist
    if (floatingCallSocket) {
      console.log('‚úÖ Keeping floating call socket alive');
    }
    
    // Only disconnect main chat socket
    if (socketInstance) {
      socketInstance.emit('leave_room');
      socketInstance.disconnect();
    }
    
    return;
  }
  
  if (navigatingToCall) {
    console.log('üîí Navigating to call - keeping socket');
    saveChatState(roomData.roomId, messagesCache);
    return;
  }
  
  console.log('üóëÔ∏è Normal chat exit - cleanup already done in leave handler');
  
  // Only disconnect sockets - cleanup was already done by leave button handlers
  if (socketInstance) {
    socketInstance.disconnect();
  }
  if (timerInterval) clearInterval(timerInterval);
});
  }

  // ============================================
  // INITIALIZATION
  // ============================================
  
try {
    // Check if we're returning from a call OR if we're in an iframe (chat overlay)
    const returningFromCall = sessionStorage.getItem('returningFromCall') === 'true';
    const isBackgroundCall = sessionStorage.getItem('backgroundCallMode') === 'true';
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    const isInIframe = window.parent && window.parent !== window;
    
    // CRITICAL: If there's an active call in this room, we're likely returning from it
    let shouldPreserveState = returningFromCall || isBackgroundCall;
    
    if (!shouldPreserveState && activeCallStr && isInIframe) {
        try {
            const activeCall = JSON.parse(activeCallStr);
            const roomStr = localStorage.getItem('currentRoom');
            if (roomStr) {
                const room = JSON.parse(roomStr);
                if (activeCall.roomId === room.roomId) {
                    console.log('üîç Active call detected in iframe - treating as return from call');
                    shouldPreserveState = true;
                }
            }
        } catch (e) {
            console.warn('Failed to parse call/room data:', e);
        }
    }
    
    console.log('üîç Page load context:', { 
        returningFromCall, 
        isBackgroundCall, 
        isInIframe,
        shouldPreserveState,
        hasActiveCall: !!activeCallStr
    });
    
    if (!shouldPreserveState) {
        // Only clear if this is a fresh entry to chat (not returning from call)
        console.log('üßπ Fresh chat entry - clearing old state');
        clearAllChatData();
    } else {
        console.log('üîÑ Returning from call - preserving chat state');
        // Don't clear - we want to restore the previous state
    }
    
    // Auth check
    await _Auth.requireAuth();
  } catch (err) {
    console.error('‚ùå Auth failed:', err);
    window.location.href = '/login.html';
    return;
  }
  
  
// CRITICAL: Initialize floating call popup elements early
console.log('üéà Pre-initializing floating call popup');

// Check if returning from call
const returningFromCall = sessionStorage.getItem('returningFromCall');
if (returningFromCall === 'true') {
  console.log('üîÑ Returning from call - popup will be shown after room_joined');
  console.log('üîç Active call check:', !!localStorage.getItem(ACTIVE_CALL_KEY));
}

  const roomDataStr = localStorage.getItem('currentRoom');
  if (!roomDataStr) {
    console.error('‚ùå No currentRoom in localStorage');
    toast('No active room found', 'error');
    setTimeout(() => window.location.href = '/mood.html', 1500);
    return;
  }

  try {
    roomData = JSON.parse(roomDataStr);
    console.log('üì¶ Loaded room data from localStorage:');
    console.log(`   roomId: ${roomData.roomId}`);
    
    // CRITICAL: Don't trust localStorage expiresAt - wait for server
    if (roomData.expiresAt) {
      console.log(`   LocalStorage expiresAt: ${new Date(roomData.expiresAt).toISOString()}`);
      console.log(`   ‚ö†Ô∏è Will be replaced with server time after connection`);
    } else {
      console.log(`   No expiresAt in localStorage - will get from server`);
    }
    
    if (!roomData.roomId) {
      throw new Error('Invalid room data: missing roomId');
    }
    checkForBackgroundCall();
  } catch (err) {
    console.error('‚ùå Invalid room data:', err);
    toast('Invalid room data', 'error');
    clearChatState(true);
    setTimeout(() => window.location.href = '/mood.html', 1500);
    return;
  }

  // Get Firebase user
  const firebaseUser = firebase.auth().currentUser;
  if (!firebaseUser) {
    window.location.href = '/login.html';
    return;
  }

  // Get current user data
  try {
    const userData = await _API.get('/api/users/me');
    currentUser = {
      userId: userData._id,
      username: userData.username,
      pfpUrl: userData.pfpUrl
    };
  } catch (err) {
    console.error('‚ùå Failed to get user data:', err);
    toast('Failed to load user data', 'error');
    setTimeout(() => window.location.href = '/login.html', 1500);
    return;
  }

  
// CRITICAL: Start with buttons DISABLED until authenticated
console.log('üéöÔ∏è Initializing call buttons (disabled until authenticated)');
disableCallButtons(false); // false = don't show loading, just disabled

const cachedState = loadChatState();

if (cachedState && cachedState.roomId === roomData.roomId) {
  console.log('üé® Restoring UI from cache IMMEDIATELY on page load');
  console.log(`   Cached button state: ${cachedState.callButtonState}`);
  console.log(`   Cached activeCallInRoom:`, cachedState.activeCallInRoom);
  
  // Restore activeCallInRoom immediately
  if (cachedState.activeCallInRoom) {
    activeCallInRoom = cachedState.activeCallInRoom;
    console.log('üíæ Pre-loaded activeCallInRoom from cache');
  } else if (cachedState.callButtonState === 'back') {
    // Reconstruct from ACTIVE_CALL_KEY
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    if (activeCallStr) {
      try {
        const activeCallData = JSON.parse(activeCallStr);
        activeCallInRoom = {
          callId: activeCallData.callId,
          callType: activeCallData.callType,
          participantCount: 2
        };
        console.log('üíæ Pre-loaded activeCallInRoom from ACTIVE_CALL_KEY');
      } catch (e) {
        console.error('Failed to reconstruct activeCallInRoom:', e);
      }
    }
  }
  
  // Set button state immediately from cache (but keep disabled until auth)
  if (cachedState.callButtonState === 'back') {
    updateCallButtonState(true, activeCallInRoom || { participantCount: 1 });
    console.log('‚úÖ "Back to Call" button shown immediately from cache (disabled until auth)');
  } else if (cachedState.callButtonState === 'join' && activeCallInRoom) {
    updateCallButtonState(true, activeCallInRoom);
    console.log('‚úÖ "Join Call" button shown immediately from cache (disabled until auth)');
  } else {
    setInitialCallButtonState();
  }
} else {
  // No cache - use normal initial state (disabled)
  setInitialCallButtonState();
}
  // Render initial users
  if (usersList && Array.isArray(roomData.users)) {
    roomData.users.forEach(user => {
      const userCard = document.createElement('div');
      userCard.className = 'user-card flex items-center gap-2 sm:gap-3 p-2 sm:p-3 rounded-lg hover:bg-gray-50 transition-all cursor-pointer';
      
      const pfpElement = createProfilePictureElement(user.pfpUrl, user.username, 'w-10 h-10 sm:w-12 sm:h-12');
      
      const userInfo = document.createElement('div');
      userInfo.className = 'flex-1 min-w-0';
      
      const nameSpan = document.createElement('div');
      nameSpan.className = 'text-sm font-semibold truncate';
      nameSpan.textContent = user.username || 'User';
      
      const statusSpan = document.createElement('div');
      statusSpan.className = 'text-xs text-gray-500 flex items-center gap-1';
      statusSpan.innerHTML = '<span class="flex h-2 w-2 rounded-full bg-green-500 flex-shrink-0"></span> Online';
      
      userInfo.appendChild(nameSpan);
      userInfo.appendChild(statusSpan);
      
      userCard.appendChild(pfpElement);
      userCard.appendChild(userInfo);
      usersList.appendChild(userCard);
    });

    setupUserCardClick();

    if (onlineCount) {
      onlineCount.textContent = `${roomData.users.length} Online`;
    }
  }

  console.log('‚è∞ Starting timer interval (will update when server data arrives)');
  // Start timer interval (will show "--" until server data arrives)
  timerInterval = setInterval(updateTimer, 1000);
  updateTimer();

  // Initialize socket
  try {
    const idToken = await firebaseUser.getIdToken();
    const socketUrl = window.location.origin;
    
    socketInstance = io(socketUrl, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 500,
      reconnectionAttempts: 10,
      auth: { token: idToken },
      timeout: 10000
    });

    setupSocketHandlers();
  } catch (err) {
    console.error('‚ùå Socket initialization failed:', err);
    toast('Connection failed', 'error');
  }

  // Setup all event listeners
  setupEventListeners();

  // Setup back button handler
  setupBackButtonHandler();

  console.log('‚úÖ Chat initialization complete');

})();
</script>
</body>
</html>
