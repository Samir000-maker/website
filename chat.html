
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat Room - MoodLog</title>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="global.css" rel="stylesheet">
    <style>
    body {
        font-family: 'Manrope', sans-serif;
        background-color: #0a0e14;
    }
    
    .reply-btn {
        opacity: 0;
        transition: opacity 0.15s ease;
        cursor: pointer;
    }
    .message-item:hover .reply-btn {
        opacity: 1;
    }
    
    .reply-preview {
        animation: slideUp 0.15s ease-out;
    }
    
    @keyframes slideUp {
        from {
            transform: translateY(10px);
            opacity: 0;
        }
        to {
            transform: translateY(0);
            opacity: 1;
        }
    }
    
    .quoted-message {
        border-left: 3px solid #06b6d4;
        padding-left: 8px;
        margin-bottom: 6px;
        background-color: rgba(6, 182, 212, 0.1);
        padding: 6px 8px;
        border-radius: 6px;
        font-size: 0.813rem;
    }
    
    .quoted-message-light {
        background-color: rgba(6, 182, 212, 0.08);
        border-left-color: #06b6d4;
    }

    .sidebar {
        transition: transform 0.2s ease;
        background-color: #161b22;
    }
    
    .main-container {
        height: 100vh;
        height: 100dvh;
    }
    
    .call-buttons-container {
        position: relative;
        display: flex;
        flex-direction: row;
        gap: 8px;
        align-items: center;
    }

    @media (max-width: 640px) {
        .call-buttons-container {
            gap: 6px;
        }
    }

    .chat-main {
        max-height: calc(100vh - 64px);
        max-height: calc(100dvh - 64px);
        background-color: #0d1117;
    }

    @media (max-width: 768px) {
        .chat-main {
            max-height: calc(100vh - 56px);
            max-height: calc(100dvh - 56px);
        }
    }
    
    @media (max-width: 768px) {
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 280px;
            z-index: 40;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            transform: translateX(-100%);
        }
        
        .sidebar.show {
            transform: translateX(0);
        }
        
        .sidebar-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 30;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        .sidebar-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
    }
    
    @media (min-width: 769px) {
        .sidebar {
            position: relative;
            width: 280px;
            min-width: 280px;
            display: block !important;
        }
        
        .sidebar-toggle {
            display: none;
        }
        
        .sidebar-overlay {
            display: none;
        }
    }

    .user-card {
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        background-color: transparent;
    }

    .user-card:hover {
        transform: translateY(-2px);
        background-color: rgba(6, 182, 212, 0.05) !important;
    }

    /* Message input styling */
    #messageInput {
        background-color: #0d1117;
        border: 1px solid #30363d;
        color: #c9d1d9;
    }
    
    #messageInput::placeholder {
        color: #8b949e;
    }
    
    #messageInput:focus {
        border-color: #06b6d4;
        background-color: #0d1117;
        box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.1);
        outline: none;
    }
    
    /* Reply preview styling */
    #replyPreview {
        background-color: #161b22;
        border-bottom: 1px solid #30363d;
        border-left: 3px solid #06b6d4;
    }
    
    /* Confirmation dialog dark mode */
    .confirmation-dialog {
        background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
        border: 1px solid #30363d;
    }
    
    /* Add emoji picker button styling */
    .emoji-btn {
        background-color: #1c2128;
        border: 1px solid #30363d;
        color: #8b949e;
        width: 44px;
        height: 44px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.15s ease;
    }
    
    .emoji-btn:hover {
        background-color: #21262d;
        border-color: #444c56;
    }
    
    .attachment-btn {
        background-color: #1c2128;
        border: 1px solid #30363d;
        color: #8b949e;
        width: 44px;
        height: 44px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.15s ease;
    }
    
    .attachment-btn:hover {
        background-color: #21262d;
        border-color: #444c56;
    }

    /* Header styling */
    header {
        background-color: #161b22 !important;
        border-bottom: 1px solid #30363d !important;
    }

    /* Timer display */
    .hidden.sm\:flex.items-center.gap-2 {
        background-color: #1c2128 !important;
        border: 1px solid #30363d !important;
    }

    /* Call buttons - brighter cyan with glow */
    #audioCallBtn, #videoCallBtn {
        background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%);
        box-shadow: 0 0 15px rgba(6, 182, 212, 0.4);
        border: 1px solid #22d3ee;
    }

    #audioCallBtn:hover, #videoCallBtn:hover {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%);
        box-shadow: 0 0 20px rgba(6, 182, 212, 0.6);
    }

    #joinCallBtn {
        background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%);
        box-shadow: 0 0 15px rgba(6, 182, 212, 0.4);
        border: 1px solid #22d3ee;
    }

    #joinCallBtn:hover {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%);
        box-shadow: 0 0 20px rgba(6, 182, 212, 0.6);
    }

    /* Send button - bright cyan gradient */
    button[type="submit"] {
        background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%);
        box-shadow: 0 0 20px rgba(6, 182, 212, 0.4);
        border: 1px solid #22d3ee;
    }

    button[type="submit"]:hover {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%);
        box-shadow: 0 0 25px rgba(6, 182, 212, 0.6);
    }

    /* Message bubbles */
    .bg-\[\#2a2d33\] {
        background-color: #1c2128 !important;
        border: 1px solid #30363d;
    }

    /* User's own messages - teal/cyan with glow */
    .bg-\[\#33bfcc\] {
        background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%) !important;
        border: 1px solid #22d3ee;
        box-shadow: 0 0 20px rgba(6, 182, 212, 0.3);
    }

    /* System messages */
    .text-center.text-xs, .text-center.text-sm {
        color: #8b949e !important;
    }

    /* Message text colors */
    .text-gray-200 {
        color: #c9d1d9 !important;
    }

    .text-gray-400 {
        color: #8b949e !important;
    }

    .text-gray-500 {
        color: #6e7681 !important;
    }

    /* Input bottom bar */
    .border-t.border-gray-800.bg-\[\#1f2228\] {
        background-color: #0d1117 !important;
        border-top: 1px solid #30363d !important;
    }

    /* Messages list background */
    #messagesList {
        background-color: #0d1117;
    }

    /* Sidebar background */
    .bg-\[\#22252a\] {
        background-color: #161b22 !important;
    }

    /* Leave button */
    #leaveBtn {
        color: #8b949e;
    }

    #leaveBtn:hover {
        color: #c9d1d9;
    }

    /* Online count text */
    #onlineCount {
        color: #8b949e;
    }

    /* Header title */
    header h2 {
        color: #f0f6fc;
    }

    /* Decline call button in modal */
    #declineCallBtn:hover {
        background: linear-gradient(135deg, #ef4444 0%, #f87171 100%) !important;
        box-shadow: 0 0 25px rgba(239, 68, 68, 0.5) !important;
    }

    /* Accept call button in modal */
    #acceptCallBtn:hover {
        background: linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%) !important;
        box-shadow: 0 0 25px rgba(6, 182, 212, 0.6) !important;
    }

    /* Loading states */
    .call-btn-loading, .join-btn-loading {
        opacity: 0.7;
        cursor: not-allowed;
    }

    .animate-pulse {
        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }

    @keyframes pulse {
        0%, 100% {
            opacity: 1;
        }
        50% {
            opacity: .5;
        }
    }

    /* Reply preview close button */
    #cancelReply {
        color: #8b949e;
    }

    #cancelReply:hover {
        color: #c9d1d9;
    }

    /* Sidebar close button */
    #sidebarClose {
        color: #8b949e;
    }

    #sidebarClose:hover {
        background-color: rgba(6, 182, 212, 0.05);
    }

    /* Sidebar toggle button */
    #sidebarToggle {
        color: #8b949e;
    }

    #sidebarToggle:hover {
        background-color: rgba(6, 182, 212, 0.05);
    }

    /* Active users section */
    .text-gray-400.uppercase {
        color: #8b949e !important;
    }

    /* Green online indicator */
    .bg-green-500 {
        background-color: #22c55e !important;
    }

    /* Material icons color adjustments */
    .material-symbols-outlined {
        color: #8b949e;
    }

    button .material-symbols-outlined {
        color: inherit;
    }

    /* Scrollbar styling */
    #messagesList::-webkit-scrollbar,
    .sidebar::-webkit-scrollbar {
        width: 8px;
    }

    #messagesList::-webkit-scrollbar-track,
    .sidebar::-webkit-scrollbar-track {
        background: #0d1117;
    }

    #messagesList::-webkit-scrollbar-thumb,
    .sidebar::-webkit-scrollbar-thumb {
        background: #30363d;
        border-radius: 4px;
    }

    #messagesList::-webkit-scrollbar-thumb:hover,
    .sidebar::-webkit-scrollbar-thumb:hover {
        background: #444c56;
    }

    /* Fade in animation for messages */
    @keyframes fade-in-up {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .animate-fade-in-up {
        animation: fade-in-up 0.3s ease-out;
    }

    /* Modal fade in */
    @keyframes fade-in {
        from {
            opacity: 0;
            transform: scale(0.95);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }

    .animate-fade-in {
        animation: fade-in 0.2s ease-out;
    }

    /* Profile picture borders */
    .border-white {
        border-color: #30363d !important;
    }

    /* Time remaining text */
    #timeRemaining {
        color: #c9d1d9;
    }

    /* User status in sidebar */
    .user-card .text-gray-500 {
        color: #8b949e !important;
    }

    .user-card .text-sm {
        color: #c9d1d9 !important;
    }
    
    /* ============================================
   ATTACHMENT PREVIEW STYLES
   ============================================ */
.attachment-preview-container {
    background: linear-gradient(135deg, rgba(6, 182, 212, 0.08) 0%, rgba(14, 116, 144, 0.12) 100%);
    border: 1px solid rgba(6, 182, 212, 0.2);
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 12px;
    animation: slideUpFade 0.2s ease-out;
}

@keyframes slideUpFade {
    from {
        opacity: 0;
        transform: translateY(8px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.attachment-preview-content {
    display: flex;
    align-items: center;
    gap: 12px;
}

.attachment-icon-wrapper {
    width: 48px;
    height: 48px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    position: relative;
    overflow: hidden;
}

.attachment-icon-wrapper.image-preview {
    background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%);
    border: 1px solid rgba(6, 182, 212, 0.3);
}

.attachment-icon-wrapper.pdf-preview {
    background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%);
    border: 1px solid rgba(239, 68, 68, 0.3);
}

.attachment-icon-wrapper.video-preview {
    background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
    border: 1px solid rgba(168, 85, 247, 0.3);
}

.attachment-icon-wrapper img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.attachment-icon-wrapper .material-symbols-outlined {
    font-size: 24px;
    color: white;
}

.attachment-info {
    flex: 1;
    min-width: 0;
}

.attachment-name {
    font-size: 0.875rem;
    font-weight: 600;
    color: #c9d1d9;
    margin-bottom: 2px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.attachment-size {
    font-size: 0.75rem;
    color: #8b949e;
}

.attachment-remove-btn {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    background-color: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.15s ease;
    flex-shrink: 0;
}

.attachment-remove-btn:hover {
    background-color: rgba(239, 68, 68, 0.2);
    border-color: rgba(239, 68, 68, 0.4);
}

.attachment-remove-btn .material-symbols-outlined {
    font-size: 18px;
    color: #ef4444;
}

/* Message attachment display */
.message-attachment {
    margin-top: 8px;
    border-radius: 8px;
    overflow: hidden;
    max-width: 300px;
}

.message-attachment img {
    width: 100%;
    height: auto;
    display: block;
    cursor: pointer;
    transition: opacity 0.2s;
}

.message-attachment img:hover {
    opacity: 0.9;
}

.message-attachment-file {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    transition: all 0.15s ease;
}

.message-attachment-file:hover {
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(255, 255, 255, 0.2);
}

.message-attachment-file .material-symbols-outlined {
    font-size: 24px;
}

.message-attachment-file.pdf {
    color: #ef4444;
}

.message-attachment-file.video {
    color: #a855f7;
}

.message-attachment-info {
    flex: 1;
    min-width: 0;
}

.message-attachment-name {
    font-size: 0.813rem;
    font-weight: 600;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.message-attachment-size {
    font-size: 0.75rem;
    opacity: 0.7;
}


/* ============================================
   EMOJI PICKER BOTTOM SHEET - FUTURISTIC THEME
   ============================================ */

/* Overlay backdrop */
.emoji-picker-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(8px);
  z-index: 9999;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease;
}

.emoji-picker-overlay.active {
  opacity: 1;
  pointer-events: auto;
}

/* Bottom sheet container */
.emoji-picker-sheet {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  max-height: 70vh;
  background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
  border-top-left-radius: 24px;
  border-top-right-radius: 24px;
  border: 1px solid #30363d;
  box-shadow: 0 -20px 60px rgba(0, 0, 0, 0.6), 0 0 1px rgba(6, 182, 212, 0.3);
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 10000;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.emoji-picker-overlay.active .emoji-picker-sheet {
  transform: translateY(0);
}

/* Handle bar */
.emoji-picker-handle {
  width: 40px;
  height: 4px;
  background: #30363d;
  border-radius: 2px;
  margin: 12px auto 8px;
  flex-shrink: 0;
}

/* Header */
.emoji-picker-header {
  padding: 0 20px 16px;
  border-bottom: 1px solid #30363d;
  flex-shrink: 0;
}

.emoji-picker-title {
  font-size: 1.125rem;
  font-weight: 700;
  color: #f0f6fc;
  margin-bottom: 12px;
  text-align: center;
}

/* Search input */
.emoji-search-input {
  width: 100%;
  padding: 12px 16px;
  background: #1c2128;
  border: 1px solid #30363d;
  border-radius: 12px;
  color: #c9d1d9;
  font-size: 0.875rem;
  transition: all 0.15s ease;
}

.emoji-search-input::placeholder {
  color: #8b949e;
}

.emoji-search-input:focus {
  outline: none;
  border-color: #06b6d4;
  background: #0d1117;
  box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.1);
}

/* Category tabs */
.emoji-categories {
  display: flex;
  gap: 8px;
  padding: 12px 20px;
  overflow-x: auto;
  border-bottom: 1px solid #30363d;
  flex-shrink: 0;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.emoji-categories::-webkit-scrollbar {
  display: none;
}

.emoji-category-tab {
  padding: 8px 16px;
  background: #1c2128;
  border: 1px solid #30363d;
  border-radius: 8px;
  color: #8b949e;
  font-size: 0.813rem;
  font-weight: 600;
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.15s ease;
  text-transform: capitalize;
}

.emoji-category-tab:hover {
  background: #21262d;
  border-color: #444c56;
}

.emoji-category-tab.active {
  background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%);
  border-color: #22d3ee;
  color: white;
  box-shadow: 0 0 15px rgba(6, 182, 212, 0.3);
}

/* Emoji grid container */
.emoji-grid-container {
  flex: 1;
  overflow-y: auto;
  padding: 16px 20px 24px;
  min-height: 0;
}

.emoji-grid-container::-webkit-scrollbar {
  width: 8px;
}

.emoji-grid-container::-webkit-scrollbar-track {
  background: #0d1117;
}

.emoji-grid-container::-webkit-scrollbar-thumb {
  background: #30363d;
  border-radius: 4px;
}

.emoji-grid-container::-webkit-scrollbar-thumb:hover {
  background: #444c56;
}

/* Emoji grid */
.emoji-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
  gap: 8px;
  animation: fadeInUp 0.3s ease-out;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Emoji item */
.emoji-item {
  aspect-ratio: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #1c2128;
  border: 1px solid #30363d;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.15s ease;
  font-size: 1.75rem;
  user-select: none;
}

.emoji-item:hover {
  background: #21262d;
  border-color: #06b6d4;
  box-shadow: 0 0 15px rgba(6, 182, 212, 0.2);
  transform: scale(1.1);
}

.emoji-item:active {
  transform: scale(0.95);
}

/* Loading state */
.emoji-loading {
  text-align: center;
  padding: 40px 20px;
  color: #8b949e;
  font-size: 0.875rem;
}

.emoji-loading-spinner {
  display: inline-block;
  width: 24px;
  height: 24px;
  border: 3px solid #30363d;
  border-top-color: #06b6d4;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-bottom: 12px;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Error state */
.emoji-error {
  text-align: center;
  padding: 40px 20px;
  color: #ef4444;
  font-size: 0.875rem;
}

/* Empty state */
.emoji-empty {
  text-align: center;
  padding: 40px 20px;
  color: #8b949e;
  font-size: 0.875rem;
}

/* Mobile adjustments */
@media (max-width: 640px) {
  .emoji-picker-sheet {
    max-height: 75vh;
  }
  
  .emoji-grid {
    grid-template-columns: repeat(auto-fill, minmax(44px, 1fr));
    gap: 6px;
  }
  
  .emoji-item {
    font-size: 1.5rem;
  }
  
  .emoji-categories {
    padding: 12px 16px;
  }
  
  .emoji-grid-container {
    padding: 12px 16px 20px;
  }
}
    
    
</style>
</head>
<body class="bg-background-light main-container flex flex-col overflow-hidden">
    <header class="sticky top-0 z-50 w-full border-b border-gray-800 bg-[#1f2228]/95 backdrop-blur header-safe">
    <div class="mx-auto flex h-14 sm:h-16 max-w-full items-center justify-between px-3 sm:px-6">
        <div class="flex items-center gap-2 sm:gap-3 flex-1 min-w-0">
            <button id="sidebarToggle" class="sidebar-toggle p-2 hover:bg-gray-800 rounded-lg md:hidden flex-shrink-0">
                <span class="material-symbols-outlined text-gray-400">menu</span>
            </button>
            
            <div class="min-w-0 flex-1">
                <h2 class="text-base sm:text-lg font-bold truncate text-white">Mindful Space</h2>
                <div class="flex items-center gap-1.5 sm:gap-2 text-xs text-gray-400">
                    <span class="flex h-2 w-2 rounded-full bg-green-500 flex-shrink-0"></span>
                    <span id="onlineCount" class="truncate">Loading...</span>
                </div>
            </div>
        </div>
        
        <div class="flex items-center gap-3 flex-shrink-0">
            <!-- Timer Display -->
            <div class="hidden sm:flex items-center gap-2 px-3 py-1.5 bg-[#2a2d33] rounded-lg border border-gray-700">
                <span class="material-symbols-outlined text-gray-400 text-base">schedule</span>
                <span id="timeRemaining" class="text-xs text-gray-300 font-medium">--:--</span>
            </div>
            
            <!-- Call Buttons -->
            <div class="call-buttons-container flex-row">
                <button id="audioCallBtn" 
                    class="w-9 h-9 sm:w-10 sm:h-10 flex items-center justify-center rounded-full bg-[#33bfcc] text-white hover:bg-[#2aa5b0] transition-all"
                    title="Start Audio Call">
                    <span class="material-symbols-outlined text-lg sm:text-xl">call</span>
                </button>
                <button id="videoCallBtn" 
                    class="w-9 h-9 sm:w-10 sm:h-10 flex items-center justify-center rounded-full bg-[#33bfcc] text-white hover:bg-[#2aa5b0] transition-all"
                    title="Start Video Call">
                    <span class="material-symbols-outlined text-lg sm:text-xl">videocam</span>
                </button>
                <button id="joinCallBtn" 
                    class="hidden items-center gap-1.5 px-3 sm:px-4 h-9 sm:h-10 rounded-full bg-green-600 text-white hover:bg-green-700 transition-all text-xs sm:text-sm font-semibold"
                    title="Join Active Call">
                    <span class="material-symbols-outlined text-base sm:text-lg">login</span>
                    <span class="hidden sm:inline">Join Call</span>
                    <span class="sm:hidden">Join</span>
                </button>
            </div>
            
            <button id="leaveBtn" class="text-xs sm:text-sm font-medium text-gray-400 hover:text-gray-300 px-2 sm:px-3 py-1.5 sm:py-2 whitespace-nowrap">
                <span class="hidden sm:inline">Leave Room</span>
                <span class="sm:hidden material-symbols-outlined text-xl">logout</span>
            </button>
        </div>
    </div>
</header>

    <div class="flex flex-1 overflow-hidden relative chat-main">
        <div id="sidebarOverlay" class="sidebar-overlay"></div>
        
        <aside id="sidebar" class="sidebar border-r border-gray-800 bg-[#22252a] overflow-y-auto">
    <div class="p-3 sm:p-4">
        <div class="flex items-center justify-between mb-3 sm:mb-4">
            <h3 class="text-xs font-bold text-gray-400 uppercase">Active Users</h3>
            <button id="sidebarClose" class="md:hidden p-1 hover:bg-gray-800 rounded">
                <span class="material-symbols-outlined text-gray-400 text-xl">close</span>
            </button>
        </div>
        <div id="usersList" class="space-y-2 sm:space-y-3"></div>
    </div>
</aside>

        <main class="flex-1 flex flex-col min-h-0 bg-[#1a1d23]">
    <div id="messagesList" class="flex-1 overflow-y-auto px-2 sm:px-4 py-3 sm:py-6 space-y-2 sm:space-y-4 min-h-0">
        <div class="text-center text-xs sm:text-sm text-gray-500 mb-4">
            Welcome to the safe space. Be kind and supportive.
        </div>
    </div>

    <div class="border-t border-gray-800 bg-[#1f2228] flex-shrink-0 sticky bottom-0 left-0 right-0 z-10" style="padding-bottom: env(safe-area-inset-bottom, 0px);">
    <div id="replyPreview" class="reply-preview hidden border-b border-gray-800 px-3 py-2 bg-[#22252a]">
        <div class="flex items-start justify-between gap-2">
            <div class="flex-1 min-w-0">
                <div class="flex items-center gap-1.5 mb-1">
                    <span class="material-symbols-outlined text-[#33bfcc] text-sm">subdirectory_arrow_left</span>
                    <span class="text-xs font-medium text-[#33bfcc]" id="replyToUsername">Replying to User</span>
                </div>
                <p class="text-xs text-gray-400 truncate" id="replyToMessage">Original message text</p>
            </div>
            <button id="cancelReply" class="text-gray-500 hover:text-gray-400 p-1">
                <span class="material-symbols-outlined text-lg">close</span>
            </button>
        </div>
    </div>
    
    <!-- Attachment Preview -->
    <div id="attachmentPreview" class="hidden px-3 pt-3">
        <div class="attachment-preview-container">
            <div class="attachment-preview-content">
                <div id="attachmentIconWrapper" class="attachment-icon-wrapper">
                    <!-- Icon or image preview will be inserted here -->
                </div>
                <div class="attachment-info">
                    <div id="attachmentName" class="attachment-name">filename.png</div>
                    <div id="attachmentSize" class="attachment-size">0 KB</div>
                </div>
                <button id="removeAttachment" class="attachment-remove-btn" title="Remove attachment">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
        </div>
    </div>
    
    <div class="p-3 pb-4">
        <form id="messageForm" class="flex gap-2 items-end">
            <button type="button" class="emoji-btn flex-shrink-0" title="Add emoji">
                <span class="material-symbols-outlined text-xl">sentiment_satisfied</span>
            </button>
            <button type="button" class="attachment-btn flex-shrink-0" title="Attach file">
                <span class="material-symbols-outlined text-xl">attach_file</span>
            </button>
            <input type="text" id="messageInput" maxlength="500"
                class="flex-1 px-4 py-3 text-sm border border-gray-700 rounded-xl focus:border-[#33bfcc] focus:outline-none bg-[#2a2d33] text-gray-200"
                placeholder="Type a message..." style="min-width: 0; -webkit-appearance: none;">
            <button type="submit" class="w-11 h-11 flex-shrink-0 flex items-center justify-center bg-[#33bfcc] text-white rounded-xl hover:bg-[#2aa5b0] active:scale-95 transition-transform">
                <span class="material-symbols-outlined">send</span>
            </button>
        </form>
    </div>
</div>
</main>
    </div>

    <div id="incomingCallModal" class="hidden fixed inset-0 bg-black/85 backdrop-blur-sm z-[100] flex items-center justify-center p-4">
    <div style="background: linear-gradient(135deg, #0d1117 0%, #161b22 100%); border-radius: 20px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 0 1px rgba(6, 182, 212, 0.3); border: 1px solid #30363d; padding: 2rem; max-width: 400px; width: 100%;">
        <div class="text-center">
            <div class="mb-6">
                <div id="callerAvatar" class="w-24 h-24 mx-auto rounded-full overflow-hidden bg-gradient-to-br from-cyan-500/20 to-cyan-600/30 flex items-center justify-center border border-cyan-500/30">
                    <span class="text-4xl">üìû</span>
                </div>
            </div>
            <h3 class="text-xl font-bold mb-2 text-gray-100" id="callerName">Incoming Call</h3>
            <p class="text-base text-gray-400 mb-8" id="callType">Audio Call</p>
            
            <div class="flex gap-4 justify-center">
                <button id="declineCallBtn" 
                    style="display: flex; align-items: center; gap: 0.5rem; padding: 0.875rem 1.5rem; border-radius: 12px; background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%); color: white; border: 1px solid #f87171; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);">
                    <span class="material-symbols-outlined">call_end</span>
                    <span>Decline</span>
                </button>
                <button id="acceptCallBtn" 
                    style="display: flex; align-items: center; gap: 0.5rem; padding: 0.875rem 1.5rem; border-radius: 12px; background: linear-gradient(135deg, #0e7490 0%, #06b6d4 100%); color: white; border: 1px solid #22d3ee; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 0 20px rgba(6, 182, 212, 0.4);">
                    <span class="material-symbols-outlined">call</span>
                    <span>Accept</span>
                </button>
            </div>
        </div>
    </div>
</div>

    <!-- Confirmation Dialog (hidden by default) -->
    <div id="confirmationOverlay" style="display: none;"></div>
    
    
    
    <!-- Emoji Picker Bottom Sheet -->
<div id="emojiPickerOverlay" class="emoji-picker-overlay">
  <div class="emoji-picker-sheet">
    <!-- Handle bar -->
    <div class="emoji-picker-handle"></div>
    
    <!-- Header -->
    <div class="emoji-picker-header">
      <h3 class="emoji-picker-title">Emojis</h3>
      <input 
        type="text" 
        id="emojiSearchInput" 
        class="emoji-search-input" 
        placeholder="Search emojis..."
        autocomplete="off"
      >
    </div>
    
    <!-- Category tabs -->
    <div id="emojiCategories" class="emoji-categories"></div>
    
    <!-- Emoji grid -->
    <div class="emoji-grid-container">
      <div id="emojiGrid" class="emoji-grid"></div>
    </div>
  </div>
</div>
  

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };

      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>

    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="app.js"></script>

    <script>
(async () => {
  const MoodApp = window.MoodApp || {};
  const _Auth = MoodApp.Auth;
  const _API = MoodApp.API;
  const _Toast = MoodApp.Toast;
  const _Utils = MoodApp.Utils;

const toast = (m, t='success') => { 
  if (_Toast) {
    // Handle 'info' type by mapping to 'success' if no info function exists
    const toastType = (t === 'info' && typeof _Toast.info !== 'function') ? 'success' : t;
    if (typeof _Toast[toastType] === 'function') {
      return _Toast[toastType](m);
    }
  }
  console[t==='error'?'error':'log'](m); 
};

  // ============================================
  // STORAGE KEYS
  // ============================================
  const CHAT_STATE_KEY = 'chat_state';
  const CHAT_MESSAGES_KEY = 'chat_messages';
  const CHAT_TIMESTAMP_KEY = 'chat_timestamp';
  const ACTIVE_CALL_KEY = 'activeCall';
  
  
  const CACHED_CALL_KEY = 'cachedIncomingCall';
const CALL_CACHE_TIMEOUT = 60000; // 60 seconds max cache time
let cachedCallCheckInterval = null;

let pendingAttachment = null;
  // ============================================
  // STATE MANAGEMENT
  // ============================================
  let replyingTo = null;
  let isInitiatingCall = false;
  let pendingCallData = null;
  let navigatingToCall = false;
  let messagesCache = [];
  let activeCallInRoom = null;
  let backButtonHandled = false;
  let timerInterval = null;
  let socketInstance = null;
  let currentUser = null;
  let roomData = null;
  let serverClockOffset = 0; // Milliseconds to add to client time to get server time
  let serverExpiresAt = null; // Absolute server timestamp for expiry
  // ============================================
// EMOJI PICKER STATE
// ============================================
let emojiData = null; // Cached emoji data from API
let emojiCache = null; // Parsed and optimized emoji cache
let currentEmojiCategory = 'all'; // Currently selected category
let emojiSearchTerm = ''; // Current search query
let isEmojiPickerOpen = false; // Picker open state
  
  let floatingCallPopup = null;
let floatingCallSocket = null;
let currentSpeaker = null;
let isInBackgroundCall = false;
  
  // ============================================
  // DOM ELEMENTS (Initialized early)
  // ============================================
  const sidebar = document.getElementById('sidebar');
  const sidebarToggle = document.getElementById('sidebarToggle');
  const sidebarClose = document.getElementById('sidebarClose');
  const sidebarOverlay = document.getElementById('sidebarOverlay');
  const messagesList = document.getElementById('messagesList');
  const messageForm = document.getElementById('messageForm');
  const messageInput = document.getElementById('messageInput');
  const usersList = document.getElementById('usersList');
  const onlineCount = document.getElementById('onlineCount');
  const timeRemaining = document.getElementById('timeRemaining');
  const leaveBtn = document.getElementById('leaveBtn');
  const cancelReplyBtn = document.getElementById('cancelReply');
  const audioCallBtn = document.getElementById('audioCallBtn');
  const videoCallBtn = document.getElementById('videoCallBtn');
  const joinCallBtn = document.getElementById('joinCallBtn');
  const incomingCallModal = document.getElementById('incomingCallModal');
  const acceptCallBtn = document.getElementById('acceptCallBtn');
  const declineCallBtn = document.getElementById('declineCallBtn');
  
  // ============================================
  // UTILITY FUNCTIONS
  // ============================================
  
  
  // ============================================
// AUTHENTICATION STATE MANAGEMENT
// ============================================
let isSocketAuthenticated = false;
let authenticationPromise = null;


// ============================================
// EMOJI PICKER FUNCTIONS
// ============================================

/**
 * Fetch all emojis from EmojiHub API
 * Implements caching to avoid repeated API calls
 */

function findActiveSocketForUser(userId) {
  // CRITICAL FIX: O(1) lookup instead of O(n)
  const socketId = userToSocketId.get(userId);
  if (!socketId) {
    return null;
  }
  
  const socketInstance = io.sockets.sockets.get(socketId);
  if (socketInstance && socketInstance.connected) {
    return socketInstance;
  }
  
  // Socket disconnected but index not cleaned - remove stale entry
  userToSocketId.delete(userId);
  return null;
}

    
async function fetchEmojis() {
  console.log('üòÄ ========================================');
  console.log('üòÄ FETCHING EMOJIS FROM API');
  console.log('üòÄ ========================================');
  
  // Return cached data if available
  if (emojiData) {
    console.log('‚úÖ Using cached emoji data');
    console.log('üòÄ ========================================\n');
    return emojiData;
  }
  
  try {
    console.log('üì° Fetching from: https://emojihub.yurace.pro/api/all');
    const response = await fetch('https://emojihub.yurace.pro/api/all');
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    emojiData = await response.json();
    
    console.log(`‚úÖ Fetched ${emojiData.length} emojis`);
    console.log(`   Categories: ${[...new Set(emojiData.map(e => e.category))].length}`);
    console.log('üòÄ ========================================\n');
    
    return emojiData;
    
  } catch (error) {
    console.error('‚ùå ========================================');
    console.error('‚ùå EMOJI FETCH FAILED');
    console.error('‚ùå ========================================');
    console.error('   Error:', error.message);
    console.error('   Stack:', error.stack);
    console.error('‚ùå ========================================\n');
    throw error;
  }
}


  const emojiBtn = document.querySelector('.emoji-btn');
if (emojiBtn) {
  emojiBtn.addEventListener('click', openEmojiPicker, { passive: true });
  console.log('‚úÖ Emoji button listener attached');
}

// Emoji picker overlay click - close picker
const emojiPickerOverlay = document.getElementById('emojiPickerOverlay');
if (emojiPickerOverlay) {
  emojiPickerOverlay.addEventListener('click', (e) => {
    // Only close if clicking the overlay itself, not the sheet
    if (e.target === emojiPickerOverlay) {
      closeEmojiPicker();
    }
  }, { passive: true });
  console.log('‚úÖ Emoji overlay listener attached');
}

// Emoji search input - filter emojis
const emojiSearchInput = document.getElementById('emojiSearchInput');
if (emojiSearchInput) {
  const debouncedSearch = debounceEmojiSearch((value) => {
    emojiSearchTerm = value;
    renderEmojiGrid();
  }, 150);
  
  emojiSearchInput.addEventListener('input', (e) => {
    debouncedSearch(e.target.value);
  }, { passive: true });
  
  console.log('‚úÖ Emoji search listener attached');
}

// ESC key - close emoji picker
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && isEmojiPickerOpen) {
    closeEmojiPicker();
  }
});


    

/**
 * Process emoji data into optimized cache structure
 * Groups by category and creates search index
 */
function processEmojiData(rawData) {
  console.log('‚öôÔ∏è Processing emoji data for optimized access...');
  
  const categories = {};
  const searchIndex = [];
  
  rawData.forEach((emoji, index) => {
    // Parse HTML code to actual emoji character
    const emojiChar = emoji.htmlCode
      .map(code => String.fromCodePoint(parseInt(code.replace('&#', '').replace(';', ''))))
      .join('');
    
    const processed = {
      id: index,
      char: emojiChar,
      name: emoji.name,
      category: emoji.category,
      group: emoji.group,
      searchText: `${emoji.name} ${emoji.category} ${emoji.group}`.toLowerCase()
    };
    
    // Group by category
    if (!categories[emoji.category]) {
      categories[emoji.category] = [];
    }
    categories[emoji.category].push(processed);
    
    // Add to search index
    searchIndex.push(processed);
  });
  
  console.log(`‚úÖ Processed ${searchIndex.length} emojis into ${Object.keys(categories).length} categories`);
  
  return { categories, searchIndex, all: searchIndex };
}

/**
 * Filter emojis based on search term and category
 */
function filterEmojis(searchTerm, category) {
  if (!emojiCache) return [];
  
  let emojis = category === 'all' 
    ? emojiCache.all 
    : emojiCache.categories[category] || [];
  
  if (searchTerm) {
    const search = searchTerm.toLowerCase().trim();
    emojis = emojis.filter(emoji => emoji.searchText.includes(search));
  }
  
  return emojis;
}

/**
 * Render category tabs
 */
function renderEmojiCategories() {
  const container = document.getElementById('emojiCategories');
  if (!container || !emojiCache) return;
  
  const categories = ['all', ...Object.keys(emojiCache.categories).sort()];
  
  container.innerHTML = categories.map(cat => {
    const isActive = cat === currentEmojiCategory;
    const displayName = cat === 'all' ? 'All' : cat;
    return `
      <button 
        class="emoji-category-tab ${isActive ? 'active' : ''}" 
        data-category="${cat}"
      >
        ${displayName}
      </button>
    `;
  }).join('');
  
  // Add click handlers
  container.querySelectorAll('.emoji-category-tab').forEach(btn => {
    btn.addEventListener('click', () => {
      currentEmojiCategory = btn.dataset.category;
      renderEmojiCategories();
      renderEmojiGrid();
    }, { passive: true });
  });
}

/**
 * Render emoji grid with current filters
 * Uses virtual scrolling concept by limiting initial render
 */
function renderEmojiGrid() {
  const container = document.getElementById('emojiGrid');
  if (!container) return;
  
  const filteredEmojis = filterEmojis(emojiSearchTerm, currentEmojiCategory);
  
  console.log(`üé® Rendering ${filteredEmojis.length} emojis (category: ${currentEmojiCategory}, search: "${emojiSearchTerm}")`);
  
  if (filteredEmojis.length === 0) {
    container.innerHTML = '<div class="emoji-empty">No emojis found</div>';
    return;
  }
  
  // Render first 200 emojis immediately for performance
  // Load more on scroll if needed (simplified approach)
  const toRender = filteredEmojis.slice(0, 200);
  
  container.innerHTML = toRender.map(emoji => `
    <div 
      class="emoji-item" 
      data-emoji="${emoji.char}"
      title="${emoji.name}"
    >
      ${emoji.char}
    </div>
  `).join('');
  
  // Add click handlers
  container.querySelectorAll('.emoji-item').forEach(item => {
    item.addEventListener('click', () => {
      insertEmojiIntoInput(item.dataset.emoji);
    }, { passive: true });
  });
}

/**
 * Insert emoji into message input at cursor position
 * CRITICAL: Maintains cursor position and existing text
 */
function insertEmojiIntoInput(emoji) {
  if (!messageInput) {
    console.error('‚ùå Message input not found');
    return;
  }
  
  console.log(`üòÄ Inserting emoji: ${emoji}`);
  
  // Get current cursor position
  const start = messageInput.selectionStart;
  const end = messageInput.selectionEnd;
  const currentValue = messageInput.value;
  
  // Insert emoji at cursor position
  const newValue = currentValue.substring(0, start) + emoji + currentValue.substring(end);
  messageInput.value = newValue;
  
  // Restore cursor position (after the inserted emoji)
  const newCursorPos = start + emoji.length;
  messageInput.setSelectionRange(newCursorPos, newCursorPos);
  
  // Focus input
  messageInput.focus();
  
  console.log(`‚úÖ Emoji inserted at position ${start}, cursor now at ${newCursorPos}`);
  
  // Close picker after selection
  closeEmojiPicker();
}

/**
 * Open emoji picker bottom sheet
 */
async function openEmojiPicker() {
  console.log('üòÄ ========================================');
  console.log('üòÄ OPENING EMOJI PICKER');
  console.log('üòÄ ========================================');
  
  const overlay = document.getElementById('emojiPickerOverlay');
  if (!overlay) {
    console.error('‚ùå Emoji picker overlay not found');
    return;
  }
  
  if (isEmojiPickerOpen) {
    console.log('‚ö†Ô∏è Picker already open');
    console.log('üòÄ ========================================\n');
    return;
  }
  
  isEmojiPickerOpen = true;
  
  // Show loading state
  const grid = document.getElementById('emojiGrid');
  if (grid) {
    grid.innerHTML = `
      <div class="emoji-loading">
        <div class="emoji-loading-spinner"></div>
        <div>Loading emojis...</div>
      </div>
    `;
  }
  
  // Show overlay with animation
  overlay.classList.add('active');
  console.log('‚úÖ Overlay shown');
  
  try {
    // Fetch emojis if not cached
    if (!emojiCache) {
      console.log('üì° Fetching emoji data...');
      const rawData = await fetchEmojis();
      emojiCache = processEmojiData(rawData);
      console.log('‚úÖ Emoji cache ready');
    }
    
    // Render UI
    renderEmojiCategories();
    renderEmojiGrid();
    
    console.log('‚úÖ Emoji picker rendered successfully');
    
  } catch (error) {
    console.error('‚ùå Failed to load emojis:', error);
    
    if (grid) {
      grid.innerHTML = `
        <div class="emoji-error">
          <div style="font-size: 2rem; margin-bottom: 8px;">üòû</div>
          <div>Failed to load emojis</div>
          <div style="font-size: 0.75rem; margin-top: 4px; opacity: 0.7;">Please try again</div>
        </div>
      `;
    }
  }
  
  console.log('üòÄ ========================================\n');
}

/**
 * Close emoji picker bottom sheet
 */
function closeEmojiPicker() {
  console.log('üòÄ Closing emoji picker');
  
  const overlay = document.getElementById('emojiPickerOverlay');
  if (overlay) {
    overlay.classList.remove('active');
  }
  
  isEmojiPickerOpen = false;
  
  // Reset search
  emojiSearchTerm = '';
  const searchInput = document.getElementById('emojiSearchInput');
  if (searchInput) {
    searchInput.value = '';
  }
  
  // Reset to "all" category
  currentEmojiCategory = 'all';
  
  console.log('‚úÖ Emoji picker closed');
}

/**
 * Debounce function for search input
 */
function debounceEmojiSearch(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}


function setAuthenticationState(authenticated) {
  console.log(`üîê ========================================`);
  console.log(`üîê AUTHENTICATION STATE CHANGE`);
  console.log(`üîê ========================================`);
  console.log(`   Previous state: ${isSocketAuthenticated}`);
  console.log(`   New state: ${authenticated}`);
  
  isSocketAuthenticated = authenticated;
  
  if (authenticated) {
    console.log(`‚úÖ Socket fully authenticated - enabling call features`);
    enableCallButtons();
  } else {
    console.log(`üîí Socket not authenticated - disabling call features`);
    disableCallButtons(true); // true = show loading state
  }
  
  console.log(`üîê ========================================\n`);
}



// ============================================
// INDEXEDDB SETUP FOR FILE ATTACHMENTS
// ============================================
const DB_NAME = 'MoodLogChatFiles';
const DB_VERSION = 1;
const FILE_STORE_NAME = 'attachments';


let dbInstance = null;

/**
 * Initialize IndexedDB for file storage
 * Returns promise that resolves to DB instance
 */
function initFileDB() {
  return new Promise((resolve, reject) => {
    if (dbInstance) {
      resolve(dbInstance);
      return;
    }
    
    console.log('üìÇ Initializing IndexedDB for file attachments...');
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    
    request.onerror = () => {
      console.error('‚ùå IndexedDB open failed:', request.error);
      reject(request.error);
    };
    
    request.onsuccess = () => {
      dbInstance = request.result;
      console.log('‚úÖ IndexedDB initialized successfully');
      resolve(dbInstance);
    };
    
    request.onupgradeneeded = (event) => {
      console.log('üîß IndexedDB upgrade needed - creating object stores');
      const db = event.target.result;
      
      // Create object store for file attachments
      if (!db.objectStoreNames.contains(FILE_STORE_NAME)) {
        const store = db.createObjectStore(FILE_STORE_NAME, { keyPath: 'id' });
        store.createIndex('roomId', 'roomId', { unique: false });
        store.createIndex('messageId', 'messageId', { unique: false });
        store.createIndex('timestamp', 'timestamp', { unique: false });
        console.log('‚úÖ Object store created:', FILE_STORE_NAME);
      }
    };
  });
}

/**
 * Store file in IndexedDB without keeping in RAM
 * Uses chunked reading for large files
 */
async function storeFileToIndexedDB(file, roomId, messageId = null) {
  console.log('üíæ ========================================');
  console.log('üíæ STORING FILE TO INDEXEDDB');
  console.log('üíæ ========================================');
  console.log(`   File: ${file.name}`);
  console.log(`   Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
  console.log(`   Type: ${file.type}`);
  console.log(`   Room: ${roomId}`);
  
  try {
    const db = await initFileDB();
    
    // Generate unique ID
    const fileId = `file_${roomId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Read file in chunks to avoid memory issues
    const chunks = [];
    let offset = 0;
    
    while (offset < file.size) {
      const chunk = file.slice(offset, offset + CHUNK_SIZE);
      const arrayBuffer = await readChunkAsArrayBuffer(chunk);
      chunks.push(arrayBuffer);
      offset += CHUNK_SIZE;
      
      // Log progress for large files
      if (file.size > 5 * 1024 * 1024) {
        const progress = ((offset / file.size) * 100).toFixed(1);
        console.log(`   Progress: ${progress}%`);
      }
    }
    
    // Combine chunks into single Blob (IndexedDB can store Blobs efficiently)
    const blob = new Blob(chunks, { type: file.type });
    
    // Clear chunks array to free memory
    chunks.length = 0;
    
    // Store file metadata and blob
    const fileRecord = {
      id: fileId,
      roomId: roomId,
      messageId: messageId,
      name: file.name,
      type: file.type,
      size: file.size,
      blob: blob, // IndexedDB stores this on disk, not in RAM
      timestamp: Date.now()
    };
    
    await new Promise((resolve, reject) => {
      const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
      const store = transaction.objectStore(FILE_STORE_NAME);
      const request = store.add(fileRecord);
      
      request.onsuccess = () => {
        console.log(`‚úÖ File stored to IndexedDB: ${fileId}`);
        console.log(`   Disk-backed storage (not in RAM)`);
        resolve(fileId);
      };
      
      request.onerror = () => {
        console.error('‚ùå Failed to store file:', request.error);
        reject(request.error);
      };
    });
    
    console.log('üíæ ========================================\n');
    return fileId;
    
  } catch (error) {
    console.error('‚ùå Error storing file to IndexedDB:', error);
    console.log('üíæ ========================================\n');
    throw error;
  }
}

/**
 * Read file chunk as ArrayBuffer without blocking main thread
 */
function readChunkAsArrayBuffer(chunk) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
    reader.readAsArrayBuffer(chunk);
  });
}

/**
 * Retrieve file from IndexedDB
 */
async function getFileFromIndexedDB(fileId) {
  console.log(`üìÇ Retrieving file: ${fileId}`);
  
  try {
    const db = await initFileDB();
    
    return await new Promise((resolve, reject) => {
      const transaction = db.transaction([FILE_STORE_NAME], 'readonly');
      const store = transaction.objectStore(FILE_STORE_NAME);
      const request = store.get(fileId);
      
      request.onsuccess = () => {
        if (request.result) {
          console.log(`‚úÖ File retrieved: ${request.result.name}`);
          resolve(request.result);
        } else {
          console.warn(`‚ö†Ô∏è File not found: ${fileId}`);
          resolve(null);
        }
      };
      
      request.onerror = () => {
        console.error('‚ùå Failed to retrieve file:', request.error);
        reject(request.error);
      };
    });
    
  } catch (error) {
    console.error('‚ùå Error retrieving file:', error);
    throw error;
  }
}

/**
 * CRITICAL: Delete ALL files associated with a room
 * Called when room is destroyed, expired, or left
 */
async function deleteRoomFiles(roomId) {
  console.log('üóëÔ∏è ========================================');
  console.log('üóëÔ∏è DELETING ALL FILES FOR ROOM');
  console.log('üóëÔ∏è ========================================');
  console.log(`   Room ID: ${roomId}`);
  
  try {
    const db = await initFileDB();
    
    return await new Promise((resolve, reject) => {
      const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
      const store = transaction.objectStore(FILE_STORE_NAME);
      const index = store.index('roomId');
      const request = index.openCursor(IDBKeyRange.only(roomId));
      
      let deletedCount = 0;
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          console.log(`   üóëÔ∏è Deleting file: ${cursor.value.name} (${cursor.value.id})`);
          cursor.delete();
          deletedCount++;
          cursor.continue();
        } else {
          console.log(`‚úÖ Deleted ${deletedCount} file(s) for room ${roomId}`);
          console.log('üóëÔ∏è ========================================\n');
          resolve(deletedCount);
        }
      };
      
      request.onerror = () => {
        console.error('‚ùå Failed to delete room files:', request.error);
        console.log('üóëÔ∏è ========================================\n');
        reject(request.error);
      };
    });
    
  } catch (error) {
    console.error('‚ùå Error deleting room files:', error);
    console.log('üóëÔ∏è ========================================\n');
    throw error;
  }
}

/**
 * Delete specific file by ID
 */
async function deleteFileFromIndexedDB(fileId) {
  console.log(`üóëÔ∏è Deleting file: ${fileId}`);
  
  try {
    const db = await initFileDB();
    
    await new Promise((resolve, reject) => {
      const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
      const store = transaction.objectStore(FILE_STORE_NAME);
      const request = store.delete(fileId);
      
      request.onsuccess = () => {
        console.log(`‚úÖ File deleted: ${fileId}`);
        resolve();
      };
      
      request.onerror = () => {
        console.error('‚ùå Failed to delete file:', request.error);
        reject(request.error);
      };
    });
    
  } catch (error) {
    console.error('‚ùå Error deleting file:', error);
    throw error;
  }
}

/**
 * Get count of files for a room (for debugging/monitoring)
 */
async function getRoomFileCount(roomId) {
  try {
    const db = await initFileDB();
    
    return await new Promise((resolve, reject) => {
      const transaction = db.transaction([FILE_STORE_NAME], 'readonly');
      const store = transaction.objectStore(FILE_STORE_NAME);
      const index = store.index('roomId');
      const request = index.count(IDBKeyRange.only(roomId));
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
    
  } catch (error) {
    console.error('‚ùå Error counting room files:', error);
    return 0;
  }
}


// ============================================
// FILE VALIDATION
// ============================================
const SUPPORTED_FILE_TYPES = {
  // Images - 10MB max
  'image/jpeg': { ext: ['.jpg', '.jpeg'], maxSize: 10 * 1024 * 1024 },
  'image/png': { ext: ['.png'], maxSize: 10 * 1024 * 1024 },
  'image/gif': { ext: ['.gif'], maxSize: 10 * 1024 * 1024 },
  'image/webp': { ext: ['.webp'], maxSize: 10 * 1024 * 1024 },
  
  // Videos - 10MB max (production should use CDN for larger)
  'video/mp4': { ext: ['.mp4'], maxSize: 10 * 1024 * 1024 },
  'video/webm': { ext: ['.webm'], maxSize: 10 * 1024 * 1024 },
  'video/quicktime': { ext: ['.mov'], maxSize: 10 * 1024 * 1024 },
  
  // Documents - 10MB max
  'application/pdf': { ext: ['.pdf'], maxSize: 10 * 1024 * 1024 },
};

const ABSOLUTE_MAX_FILE_SIZE = 10 * 1024 * 1024;

/**
 * Validate file before processing
 * Returns { valid: boolean, error: string|null }
 */
function validateFile(file) {
  console.log('üîç ========================================');
  console.log('üîç FILE VALIDATION');
  console.log('üîç ========================================');
  console.log(`   File: ${file.name}`);
  console.log(`   Type: ${file.type}`);
  console.log(`   Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
  
  // CRITICAL: Absolute size check first
  if (file.size > ABSOLUTE_MAX_FILE_SIZE) {
    const sizeMB = (file.size / 1024 / 1024).toFixed(2);
    const maxMB = (ABSOLUTE_MAX_FILE_SIZE / 1024 / 1024).toFixed(0);
    console.error(`‚ùå File exceeds absolute limit: ${sizeMB}MB > ${maxMB}MB`);
    console.log('üîç ========================================\n');
    return {
      valid: false,
      error: `File too large (${sizeMB}MB). Maximum file size is ${maxMB}MB.`
    };
  }
  
  // Check file type
  const typeConfig = SUPPORTED_FILE_TYPES[file.type];
  if (!typeConfig) {
    console.error(`‚ùå Unsupported file type: ${file.type}`);
    console.log('üîç ========================================\n');
    return {
      valid: false,
      error: `Unsupported file type. Supported: images (JPG, PNG, GIF, WebP), videos (MP4, WebM, MOV), and PDFs.`
    };
  }
  
  // Check file extension matches MIME type
  const fileName = file.name.toLowerCase();
  const hasValidExtension = typeConfig.ext.some(ext => fileName.endsWith(ext));
  if (!hasValidExtension) {
    console.error(`‚ùå File extension doesn't match type: ${file.name}`);
    console.log('üîç ========================================\n');
    return {
      valid: false,
      error: `File extension doesn't match its type. Expected: ${typeConfig.ext.join(', ')}`
    };
  }
  
  // Check type-specific size limit
  if (file.size > typeConfig.maxSize) {
    const sizeMB = (file.size / 1024 / 1024).toFixed(2);
    const maxMB = (typeConfig.maxSize / 1024 / 1024).toFixed(0);
    console.error(`‚ùå File exceeds type limit: ${sizeMB}MB > ${maxMB}MB`);
    console.log('üîç ========================================\n');
    return {
      valid: false,
      error: `${file.type} files must be under ${maxMB}MB. Your file is ${sizeMB}MB.`
    };
  }
  
  console.log('‚úÖ File validation passed');
  console.log('üîç ========================================\n');
  return { valid: true, error: null };
}



// ============================================
// CHUNKED FILE TRANSMISSION CONFIGURATION
// ============================================
const CHUNK_SIZE = 256 * 1024; // 256KB chunks (safe for Socket.IO)
const CHUNK_TIMEOUT = 30000; // 30s timeout per chunk
const MAX_RETRIES = 3; // Retry failed chunks up to 3 times

/**
 * Chunk file into manageable pieces for transmission
 * Returns array of { index, data: base64, size }
 */
async function chunkFile(file) {
  console.log('‚úÇÔ∏è ========================================');
  console.log('‚úÇÔ∏è CHUNKING FILE FOR TRANSMISSION');
  console.log('‚úÇÔ∏è ========================================');
  console.log(`   File: ${file.name}`);
  console.log(`   Total size: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
  console.log(`   Chunk size: ${(CHUNK_SIZE / 1024).toFixed(0)} KB`);
  
  const chunks = [];
  const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
  console.log(`   Total chunks: ${totalChunks}`);
  
  for (let i = 0; i < totalChunks; i++) {
    const start = i * CHUNK_SIZE;
    const end = Math.min(start + CHUNK_SIZE, file.size);
    const blob = file.slice(start, end);
    
    // Convert chunk to base64
    const base64 = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64Data = reader.result.split(',')[1];
        resolve(base64Data);
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    
    chunks.push({
      index: i,
      data: base64,
      size: blob.size
    });
    
    // Log progress every 10 chunks
    if ((i + 1) % 10 === 0 || i === totalChunks - 1) {
      const progress = ((i + 1) / totalChunks * 100).toFixed(1);
      console.log(`   Chunking progress: ${progress}% (${i + 1}/${totalChunks})`);
    }
  }
  
  console.log(`‚úÖ File chunked: ${chunks.length} chunks ready`);
  console.log('‚úÇÔ∏è ========================================\n');
  
  return chunks;
}

/**
 * Send file using chunked transmission protocol
 * Returns Promise that resolves when all chunks are acknowledged
 */
async function sendFileInChunks(fileId, fileName, fileType, fileSize, chunks, roomId) {
  console.log('üì§ ========================================');
  console.log('üì§ CHUNKED FILE TRANSMISSION START');
  console.log('üì§ ========================================');
  console.log(`   FileID: ${fileId}`);
  console.log(`   File: ${fileName}`);
  console.log(`   Chunks: ${chunks.length}`);
  console.log(`   Room: ${roomId}`);
  
  return new Promise((resolve, reject) => {
    let currentChunk = 0;
    let ackReceived = false;
    let timeoutHandle = null;
    let retryCount = 0;
    
    // Listen for chunk acknowledgments
    const ackHandler = (data) => {
      if (data.fileId !== fileId) return;
      
      console.log(`‚úÖ Chunk ${data.chunkIndex}/${chunks.length - 1} acknowledged`);
      ackReceived = true;
      clearTimeout(timeoutHandle);
      
      currentChunk++;
      
      // Update progress UI
      const progress = Math.round((currentChunk / chunks.length) * 100);
      const progressText = document.getElementById('uploadProgressText');
      if (progressText) {
        progressText.textContent = `Uploading: ${progress}%`;
      }
      
      if (currentChunk < chunks.length) {
        retryCount = 0; // Reset retry counter on success
        sendNextChunk();
      } else {
        console.log('‚úÖ All chunks transmitted successfully');
        socketInstance.off('file_chunk_ack', ackHandler);
        resolve();
      }
    };
    
    socketInstance.on('file_chunk_ack', ackHandler);
    
    const sendNextChunk = () => {
      if (currentChunk >= chunks.length) return;
      
      ackReceived = false;
      const chunk = chunks[currentChunk];
      
      console.log(`üì§ Sending chunk ${currentChunk}/${chunks.length - 1} (${(chunk.size / 1024).toFixed(2)} KB)`);
      
      socketInstance.emit('file_chunk', {
        fileId,
        fileName,
        fileType,
        fileSize,
        roomId,
        chunkIndex: currentChunk,
        totalChunks: chunks.length,
        chunkData: chunk.data,
        chunkSize: chunk.size
      });
      
      // Set timeout for this chunk
      timeoutHandle = setTimeout(() => {
        if (!ackReceived) {
          console.error(`‚ùå Chunk ${currentChunk} timeout (no ACK received)`);
          
          if (retryCount < MAX_RETRIES) {
            retryCount++;
            console.log(`üîÑ Retrying chunk ${currentChunk} (attempt ${retryCount}/${MAX_RETRIES})`);
            sendNextChunk();
          } else {
            socketInstance.off('file_chunk_ack', ackHandler);
            reject(new Error(`Chunk ${currentChunk} failed after ${MAX_RETRIES} retries`));
          }
        }
      }, CHUNK_TIMEOUT);
    };
    
    // Start transmission
    sendNextChunk();
  });
}

class ChunkedFileReceiver {
  constructor() {
    this.activeTransfers = new Map();
  }
  
  async handleChunk(data) {
    const { fileId, fileName, fileType, fileSize, roomId, chunkIndex, totalChunks, chunkData, chunkSize } = data;
    
    console.log(`üì• Received chunk ${chunkIndex}/${totalChunks - 1} for ${fileName}`);
    
    if (!this.activeTransfers.has(fileId)) {
      console.log(`üÜï Starting new file transfer: ${fileId}`);
      this.activeTransfers.set(fileId, {
        chunks: new Array(totalChunks),
        metadata: { fileName, fileType, fileSize, roomId, totalChunks },
        receivedCount: 0
      });
    }
    
    const transfer = this.activeTransfers.get(fileId);
    
    transfer.chunks[chunkIndex] = chunkData;
    transfer.receivedCount++;
    
    socketInstance.emit('file_chunk_ack', { fileId, chunkIndex });
    
    const progress = Math.round((transfer.receivedCount / totalChunks) * 100);
    console.log(`üìä Transfer progress: ${progress}% (${transfer.receivedCount}/${totalChunks})`);
    
    if (transfer.receivedCount === totalChunks) {
      console.log('‚úÖ All chunks received, reconstructing file...');
      await this.reconstructFile(fileId, transfer);
    }
  }
  
  async reconstructFile(fileId, transfer) {
    const { chunks, metadata } = transfer;
    const { fileName, fileType, fileSize, roomId } = metadata;
    
    console.log('üîß ========================================');
    console.log('üîß RECONSTRUCTING FILE FROM CHUNKS');
    console.log('üîß ========================================');
    console.log(`   FileID: ${fileId}`);
    console.log(`   File: ${fileName}`);
    console.log(`   Chunks: ${chunks.length}`);
    
    try {
      const binaryChunks = [];
      let totalBytes = 0;
      
      for (let i = 0; i < chunks.length; i++) {
        const base64Chunk = chunks[i];
        
        const byteCharacters = atob(base64Chunk);
        const byteNumbers = new Array(byteCharacters.length);
        for (let j = 0; j < byteCharacters.length; j++) {
          byteNumbers[j] = byteCharacters.charCodeAt(j);
        }
        const byteArray = new Uint8Array(byteNumbers);
        
        binaryChunks.push(byteArray);
        totalBytes += byteArray.length;
      }
      
      console.log(`‚úÖ All chunks decoded: ${totalBytes} bytes`);
      
      const combinedArray = new Uint8Array(totalBytes);
      let offset = 0;
      for (const chunk of binaryChunks) {
        combinedArray.set(chunk, offset);
        offset += chunk.length;
      }
      
      const blob = new Blob([combinedArray], { type: fileType });
      console.log(`‚úÖ Blob created: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
      
      const db = await initFileDB();
      
      await new Promise((resolve, reject) => {
        const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(FILE_STORE_NAME);
        
        const fileRecord = {
          id: fileId,
          roomId: roomId,
          messageId: null,
          name: fileName,
          type: fileType,
          size: blob.size,
          blob: blob,
          timestamp: Date.now()
        };
        
        const request = store.put(fileRecord);
        
        request.onsuccess = () => {
          console.log(`‚úÖ File stored to IndexedDB: ${fileId}`);
          resolve();
        };
        
        request.onerror = () => {
          console.error('‚ùå Failed to store file:', request.error);
          reject(request.error);
        };
      });
      
      this.activeTransfers.delete(fileId);
      
      console.log('‚úÖ File reconstruction complete');
      console.log('üîß ========================================\n');
      
      const imgElements = document.querySelectorAll(`img[data-file-id="${fileId}"]`);
      if (imgElements.length > 0) {
        console.log(`üñºÔ∏è Updating ${imgElements.length} image element(s)`);
        imgElements.forEach(img => loadImageAttachment(fileId, img));
      }
      
      toast(`Received: ${fileName}`, 'success');
      
    } catch (error) {
      console.error('‚ùå File reconstruction failed:', error);
      console.log('üîß ========================================\n');
      this.activeTransfers.delete(fileId);
      toast(`Failed to receive: ${fileName}`, 'error');
      throw error;
    }
  }
  
  cleanup(fileId) {
    if (this.activeTransfers.has(fileId)) {
      console.log(`üßπ Cleaning up incomplete transfer: ${fileId}`);
      this.activeTransfers.delete(fileId);
    }
  }
}

// Initialize global receiver
const fileReceiver = new ChunkedFileReceiver();



function waitForAuthentication() {
  if (isSocketAuthenticated) {
    console.log(`‚úÖ Already authenticated, proceeding immediately`);
    return Promise.resolve();
  }
  
  if (!authenticationPromise) {
    console.log(`‚è≥ Creating authentication promise...`);
    authenticationPromise = new Promise((resolve) => {
      const checkAuth = () => {
        if (isSocketAuthenticated) {
          console.log(`‚úÖ Authentication promise resolved`);
          resolve();
        } else {
          setTimeout(checkAuth, 50);
        }
      };
      checkAuth();
    });
  }
  
  return authenticationPromise;
}

function enableCallButtons() {
  console.log(`üéöÔ∏è Enabling call buttons`);
  
  if (audioCallBtn) {
    audioCallBtn.disabled = false;
    audioCallBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'animate-pulse');
    audioCallBtn.title = 'Start Audio Call';
    console.log(`   ‚úÖ Audio button enabled`);
  }
  
  if (videoCallBtn) {
    videoCallBtn.disabled = false;
    videoCallBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'animate-pulse');
    videoCallBtn.title = 'Start Video Call';
    console.log(`   ‚úÖ Video button enabled`);
  }
}

function disableCallButtons(showLoading = false) {
  console.log(`üîí Disabling call buttons (loading: ${showLoading})`);
  
  if (audioCallBtn) {
    audioCallBtn.disabled = true;
    audioCallBtn.classList.add('opacity-50', 'cursor-not-allowed');
    if (showLoading) {
      audioCallBtn.classList.add('animate-pulse');
      audioCallBtn.title = 'Connecting...';
    } else {
      audioCallBtn.title = 'Authenticating...';
    }
    console.log(`   üîí Audio button disabled`);
  }
  
  if (videoCallBtn) {
    videoCallBtn.disabled = true;
    videoCallBtn.classList.add('opacity-50', 'cursor-not-allowed');
    if (showLoading) {
      videoCallBtn.classList.add('animate-pulse');
      videoCallBtn.title = 'Connecting...';
    } else {
      videoCallBtn.title = 'Authenticating...';
    }
    console.log(`   üîí Video button disabled`);
  }
}



/**
 * Format bytes to human readable size
 */
function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
}

/**
 * Get file type category for icon display
 */
function getFileTypeCategory(mimeType) {
  if (mimeType.startsWith('image/')) return 'image';
  if (mimeType.startsWith('video/')) return 'video';
  if (mimeType === 'application/pdf') return 'pdf';
  return 'document';
}

/**
 * Create Blob URL for image preview (must be revoked after use)
 */
function createImagePreviewUrl(blob) {
  if (blob.type.startsWith('image/')) {
    return URL.createObjectURL(blob);
  }
  return null;
}

/**
 * Show attachment preview in UI
 */
async function showAttachmentPreview(fileId, fileName, fileType, fileSize, blob) {
  console.log('üñºÔ∏è ========================================');
  console.log('üñºÔ∏è SHOWING ATTACHMENT PREVIEW');
  console.log('üñºÔ∏è ========================================');
  console.log(`   File: ${fileName}`);
  console.log(`   Type: ${fileType}`);
  console.log(`   Size: ${formatFileSize(fileSize)}`);
  
  const previewContainer = document.getElementById('attachmentPreview');
  const iconWrapper = document.getElementById('attachmentIconWrapper');
  const nameElement = document.getElementById('attachmentName');
  const sizeElement = document.getElementById('attachmentSize');
  
  if (!previewContainer || !iconWrapper || !nameElement || !sizeElement) {
    console.error('‚ùå Preview elements not found');
    return;
  }
  
  // Clear previous preview
  iconWrapper.innerHTML = '';
  iconWrapper.className = 'attachment-icon-wrapper';
  
  const fileCategory = getFileTypeCategory(fileType);
  let previewUrl = null;
  
  // Generate appropriate preview based on file type
  if (fileCategory === 'image') {
    // Show image thumbnail
    previewUrl = createImagePreviewUrl(blob);
    if (previewUrl) {
      iconWrapper.classList.add('image-preview');
      const img = document.createElement('img');
      img.src = previewUrl;
      img.alt = fileName;
      iconWrapper.appendChild(img);
      console.log('‚úÖ Image preview created');
    }
  } else if (fileCategory === 'pdf') {
    // Show PDF icon
    iconWrapper.classList.add('pdf-preview');
    iconWrapper.innerHTML = '<span class="material-symbols-outlined">picture_as_pdf</span>';
    console.log('‚úÖ PDF icon displayed');
  } else if (fileCategory === 'video') {
    // Show video icon
    iconWrapper.classList.add('video-preview');
    iconWrapper.innerHTML = '<span class="material-symbols-outlined">videocam</span>';
    console.log('‚úÖ Video icon displayed');
  } else {
    // Show generic document icon
    iconWrapper.classList.add('pdf-preview');
    iconWrapper.innerHTML = '<span class="material-symbols-outlined">description</span>';
    console.log('‚úÖ Document icon displayed');
  }
  
  // Update file info
  nameElement.textContent = fileName;
  sizeElement.textContent = formatFileSize(fileSize);
  
  // Store attachment data
  pendingAttachment = {
    fileId,
    name: fileName,
    type: fileType,
    size: fileSize,
    previewUrl // Store for cleanup
  };
  
  // Show preview
  previewContainer.classList.remove('hidden');
  
  console.log('‚úÖ Attachment preview displayed');
  console.log('üñºÔ∏è ========================================\n');
}

/**
 * Hide and cleanup attachment preview
 */
function hideAttachmentPreview() {
  console.log('üßπ Hiding attachment preview');
  
  const previewContainer = document.getElementById('attachmentPreview');
  if (previewContainer) {
    previewContainer.classList.add('hidden');
  }
  
  // Revoke blob URL to prevent memory leak
  if (pendingAttachment?.previewUrl) {
    URL.revokeObjectURL(pendingAttachment.previewUrl);
    console.log('‚úÖ Blob URL revoked');
  }
  
  pendingAttachment = null;
  console.log('‚úÖ Attachment preview cleaned up');
}
  
  
  
  
  function checkForCachedCall() {
    console.log('üîç Checking for cached incoming call...');
    
    const cachedCallStr = localStorage.getItem(CACHED_CALL_KEY);
    
    if (!cachedCallStr) {
        console.log('‚ÑπÔ∏è No cached call found');
        return;
    }
    
    try {
        const cachedCall = JSON.parse(cachedCallStr);
        const cacheAge = Date.now() - cachedCall.timestamp;
        
        console.log(`üìû Found cached call from ${cachedCall.callerUsername}`);
        console.log(`   Age: ${(cacheAge / 1000).toFixed(1)}s`);
        console.log(`   Call ID: ${cachedCall.callId}`);
        
        // Check if cache is expired
        if (cacheAge > CALL_CACHE_TIMEOUT) {
            console.log(`‚è∞ Cached call expired (${(cacheAge / 1000).toFixed(1)}s > ${CALL_CACHE_TIMEOUT / 1000}s)`);
            localStorage.removeItem(CACHED_CALL_KEY);
            return;
        }
        
        // Check if call is still valid on server
        if (socketInstance && socketInstance.connected) {
            console.log(`üì° Validating cached call ${cachedCall.callId} with server...`);
            
            socketInstance.emit('validate_cached_call', {
                callId: cachedCall.callId,
                roomId: roomData.roomId
            });
        } else {
            console.warn('‚ö†Ô∏è Socket not connected, will retry validation');
        }
        
    } catch (e) {
        console.error('‚ùå Failed to parse cached call:', e);
        localStorage.removeItem(CACHED_CALL_KEY);
    }
}

function showCachedCallModal(callData) {
    console.log('üìû ========================================');
    console.log('üìû SHOWING CACHED INCOMING CALL');
    console.log('üìû ========================================');
    console.log(`   Caller: ${callData.callerUsername}`);
    console.log(`   Call ID: ${callData.callId}`);
    console.log(`   Type: ${callData.callType}`);
    
    // Set pending call data
    pendingCallData = {
        callId: callData.callId,
        callerUsername: callData.callerUsername,
        callerPfp: callData.callerPfp,
        callType: callData.callType,
        fromCache: true
    };
    
    // Update modal UI
    const callerName = document.getElementById('callerName');
    const callType = document.getElementById('callType');
    const callerAvatar = document.getElementById('callerAvatar');
    
    if (callerName) callerName.textContent = `${callData.callerUsername} is calling`;
    if (callType) callType.textContent = callData.callType === 'video' ? 'Video Call' : 'Audio Call';
    if (callerAvatar) {
        callerAvatar.innerHTML = '';
        const pfp = createProfilePictureElement(callData.callerPfp, callData.callerUsername, 'w-full h-full');
        callerAvatar.appendChild(pfp);
    }
    
    // Show modal immediately (no delay for cached calls)
    incomingCallModal?.classList.remove('hidden');
    
    console.log('‚úÖ Cached call modal displayed');
    console.log('üìû ========================================\n');
}

function startCachedCallMonitoring() {
    console.log('üîÑ Starting cached call monitoring...');
    
    // Check immediately on load
    checkForCachedCall();
    
    // Check every 2 seconds for cached calls
    cachedCallCheckInterval = setInterval(() => {
        checkForCachedCall();
    }, 2000);
    
    console.log('‚úÖ Cached call monitoring started (checks every 2s)');
}

function stopCachedCallMonitoring() {
    if (cachedCallCheckInterval) {
        clearInterval(cachedCallCheckInterval);
        cachedCallCheckInterval = null;
        console.log('üõë Cached call monitoring stopped');
    }
}
  
  
  // Function to cleanup parent call.html page
function cleanupParentCallPage() {
  console.log('üßπ ========================================');
  console.log('üßπ CLEANING UP PARENT CALL PAGE');
  console.log('üßπ ========================================');
  
  // Check if we're in an iframe (chat overlay on call.html)
  if (window.parent && window.parent !== window) {
    console.log('üì± We are in iframe - accessing parent window');
    try {
      // Hide the floating button
      const parentFloatingBtn = window.parent.document.getElementById('floatingReturnToCall');
      if (parentFloatingBtn) {
        parentFloatingBtn.classList.add('hidden');
        console.log('‚úÖ Parent floating button hidden');
      }
      
      // Navigate parent window to mood.html (this will trigger call.html cleanup)
      console.log('üîÑ Navigating parent window to mood.html');
      window.parent.location.href = '/mood.html';
      
      console.log('‚úÖ Parent window navigation initiated');
    } catch (e) {
      console.error('‚ùå Cannot access parent window:', e);
      // Fallback: just navigate ourselves
      window.location.href = '/mood.html';
    }
  } else {
    console.log('‚ÑπÔ∏è Not in iframe - navigating directly');
    window.location.href = '/mood.html';
  }
  
  console.log('üßπ ========================================\n');
}
  
  
  // Function to hide floating button in parent call.html
function hideCallPageFloatingButton() {
  console.log('üéà Attempting to hide call.html floating button');
  
  // Check if we're in an iframe (chat overlay)
  if (window.parent && window.parent !== window) {
    console.log('üì± We are in iframe - accessing parent window');
    try {
      const parentFloatingBtn = window.parent.document.getElementById('floatingReturnToCall');
      if (parentFloatingBtn) {
        parentFloatingBtn.classList.add('hidden');
        console.log('‚úÖ Parent floating button hidden');
      } else {
        console.warn('‚ö†Ô∏è Parent floating button not found');
      }
    } catch (e) {
      console.error('‚ùå Cannot access parent window (CORS?):', e);
    }
  } else {
    console.log('‚ÑπÔ∏è Not in iframe - checking local DOM');
    // If not in iframe, might be standalone chat page
    const localFloatingBtn = document.getElementById('floatingReturnToCall');
    if (localFloatingBtn) {
      localFloatingBtn.classList.add('hidden');
      console.log('‚úÖ Local floating button hidden');
    }
  }
}
  


function returnToActiveCall() {
  console.log('üîô ========================================');
  console.log('üîô RETURNING TO ACTIVE CALL FROM CHAT');
  console.log('üîô ========================================');
  
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  if (!activeCallStr) {
    console.error('‚ùå No active call data found');
    toast('No active call found', 'error');
    return;
  }
  
  try {
    const activeCallData = JSON.parse(activeCallStr);
    console.log(`   callId: ${activeCallData.callId}`);
    console.log(`   callType: ${activeCallData.callType}`);
    console.log(`   backgroundMode: ${activeCallData.backgroundMode}`);
    
    // Mark that we're returning to call (not starting new call)
    navigatingToCall = true;
    
    // CRITICAL: Remove background mode flag so call page knows we're coming back
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    
    // Mark that we're returning to existing call
    sessionStorage.setItem('returningToBackgroundCall', 'true');
    
    // Save current chat state
    saveChatState(roomData.roomId, messagesCache);
    
    // Disconnect floating socket before navigating
    if (floatingCallSocket) {
      console.log('üîå Disconnecting floating socket (will reconnect on call page)');
      floatingCallSocket.disconnect();
      floatingCallSocket = null;
    }
    
    console.log('‚úÖ Navigating back to call page');
    window.location.href = '/call.html';
    
  } catch (e) {
    console.error('‚ùå Failed to parse active call data:', e);
    toast('Failed to return to call', 'error');
  }
  
  console.log('üîô ========================================\n');
}

function checkForBackgroundCall() {
  const hasBackgroundCall = sessionStorage.getItem('hasBackgroundCall') === 'true';
  const activeCallStr = localStorage.getItem('activeCall');
  
  console.log('üîç Checking for background call...');
  console.log(`   hasBackgroundCall flag: ${hasBackgroundCall}`);
  console.log(`   activeCall in storage: ${!!activeCallStr}`);
  
  if (hasBackgroundCall && activeCallStr) {
    console.log('‚úÖ Background call detected - showing return button');
    
    const returnBtn = document.getElementById('floatingReturnToCall');
    if (returnBtn) {
      returnBtn.classList.remove('hidden');
      
      returnBtn.onclick = () => {
        console.log('üìû Return to call clicked');
        sessionStorage.removeItem('hasBackgroundCall');
        window.location.href = '/call.html';
      };
      
      console.log('‚úÖ Return to call button activated');
    }
  } else {
    console.log('‚ÑπÔ∏è No background call detected');
  }
}
  
  
  
function saveChatState(roomId, messages) {
  try {
    console.log('üíæ ========================================');
    console.log('üíæ SAVING CHAT STATE');
    console.log('üíæ ========================================');
    console.log(`   Room: ${roomId}`);
    console.log(`   Messages: ${messages?.length || 0}`);
    
    // CRITICAL FIX: Validate input data
    if (!roomId) {
      console.error('‚ùå Cannot save state: roomId missing');
      return;
    }
    
    if (!Array.isArray(messages)) {
      console.error('‚ùå Cannot save state: messages not an array');
      return;
    }
    
    // Validate messages have required fields
    const validMessages = messages.filter(msg => {
      const isValid = msg.userId && msg.timestamp && (msg.message || msg.attachment);
      if (!isValid) {
        console.warn(`‚ö†Ô∏è Skipping invalid message in cache save:`, msg);
      }
      return isValid;
    });
    
    if (validMessages.length < messages.length) {
      console.warn(`‚ö†Ô∏è Filtered out ${messages.length - validMessages.length} invalid messages`);
    }
    
    // Determine call button state
    let callButtonState = 'none';
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomId;
    
    if (userInCall) {
      callButtonState = 'back';
    } else if (activeCallInRoom) {
      callButtonState = 'join';
    }
    
    const callInRoomToSave = activeCallInRoom || null;
    
    const state = {
      roomId,
      messages: validMessages, // Use validated messages
      timestamp: Date.now(),
      callButtonState,
      activeCallInRoom: callInRoomToSave,
      version: 2 // Add version for future migrations
    };
    
    // CRITICAL FIX: Use try-catch for localStorage quota errors
    try {
      localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(state));
      localStorage.setItem(CHAT_TIMESTAMP_KEY, Date.now().toString());
      
      console.log('‚úÖ Chat state saved successfully:');
      console.log(`   Valid messages: ${validMessages.length}`);
      console.log(`   Button state: ${callButtonState}`);
      console.log(`   Has active call: ${!!callInRoomToSave}`);
      console.log('üíæ ========================================\n');
      
    } catch (storageError) {
      if (storageError.name === 'QuotaExceededError') {
        console.error('‚ùå LocalStorage quota exceeded - attempting cleanup');
        
        // Emergency cleanup: keep only last 50 messages
        const trimmedMessages = validMessages.slice(-50);
        const trimmedState = { ...state, messages: trimmedMessages };
        
        try {
          localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(trimmedState));
          console.warn(`‚ö†Ô∏è Saved trimmed state (${trimmedMessages.length} messages)`);
        } catch (retryError) {
          console.error('‚ùå Failed to save even trimmed state:', retryError);
          // Clear old state to free space
          localStorage.removeItem(CHAT_STATE_KEY);
          localStorage.removeItem(CHAT_MESSAGES_KEY);
        }
      } else {
        throw storageError; // Re-throw non-quota errors
      }
    }
    
  } catch (e) {
    console.error('‚ùå ========================================');
    console.error('‚ùå FAILED TO SAVE CHAT STATE');
    console.error('‚ùå ========================================');
    console.error('   Error:', e.message);
    console.error('   Stack:', e.stack);
    console.error('‚ùå ========================================\n');
  }
}
  
  function loadChatState() {
    try {
      const stateStr = localStorage.getItem(CHAT_STATE_KEY);
      if (!stateStr) return null;
      
      const state = JSON.parse(stateStr);
      console.log('‚úÖ Chat state loaded:', state.messages?.length || 0, 'messages');
      return state;
    } catch (e) {
      console.warn('‚ö†Ô∏è Failed to load chat state:', e);
      return null;
    }
  }
  
// Replace the existing clearChatState function with this version:
async function clearChatState(force = false) {
    console.log('üßπ ========================================');
    console.log('üßπ CLEARING CHAT STATE');
    console.log('üßπ ========================================');
    console.log(`   Force: ${force}`);
    
    // Only clear if room is actually expiring/ended, or if forced
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    
    if (!force && activeCallStr) {
        console.log('‚ö†Ô∏è Active call exists - preserving chat state');
        console.log('üßπ ========================================\n');
        return;
    }
    
    // CRITICAL: Delete all files for this room from IndexedDB
    if (roomData?.roomId) {
        try {
            console.log(`üóëÔ∏è Deleting all files for room: ${roomData.roomId}`);
            const deletedCount = await deleteRoomFiles(roomData.roomId);
            console.log(`‚úÖ Deleted ${deletedCount} file(s) from IndexedDB`);
        } catch (error) {
            console.error('‚ùå Failed to delete room files:', error);
            // Continue with other cleanup even if file deletion fails
        }
    }
    
    // Clear localStorage
    localStorage.removeItem(CHAT_STATE_KEY);
    localStorage.removeItem(CHAT_MESSAGES_KEY);
    localStorage.removeItem(CHAT_TIMESTAMP_KEY);
    
    console.log('‚úÖ Chat state cleared');
    console.log('üßπ ========================================\n');
}

  function clearAllChatData() {
    // CRITICAL: Clear ALL chat-related data on entry
    localStorage.removeItem(CHAT_STATE_KEY);
    localStorage.removeItem(CHAT_MESSAGES_KEY);
    localStorage.removeItem(CHAT_TIMESTAMP_KEY);
    // Don't clear currentRoom or activeCall - those are needed
    console.log('üßπ All chat state cleared on entry');
  }
  
  function escapeHtml(text) {
    if (_Utils && typeof _Utils.escapeHtml === 'function') {
      return _Utils.escapeHtml(text);
    }
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function formatTimestamp(timestamp) {
    if (_Utils && typeof _Utils.formatDate === 'function') {
      return _Utils.formatDate(timestamp);
    }
    return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

function setInitialCallButtonState() {
    console.log('üîç Checking for active call in localStorage...');
    
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    
    if (activeCallStr) {
        try {
            const activeCallData = JSON.parse(activeCallStr);
            
            if (activeCallData.roomId === roomData?.roomId) {
                console.log(`üìû Active call found: ${activeCallData.callId} in room ${activeCallData.roomId}`);
                console.log(`‚úÖ User is IN the call - will show "Back to Call" button`);
                
                // Hide audio/video buttons
                if (audioCallBtn) {
                    audioCallBtn.classList.add('hidden');
                }
                if (videoCallBtn) {
                    videoCallBtn.classList.add('hidden');
                }
                
                // Show join button as "Back to Call" button
                if (joinCallBtn) {
                    joinCallBtn.classList.remove('hidden');
                    joinCallBtn.classList.add('flex');
                    joinCallBtn.disabled = false;
                    
                    // Update button text and icon
                    const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
                    const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
                    const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
                    
                    if (btnIcon) btnIcon.textContent = 'call';
                    if (btnTextLong) btnTextLong.textContent = 'Back to Call';
                    if (btnTextShort) btnTextShort.textContent = 'Back';
                    
                    // Change color to green
                    joinCallBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    joinCallBtn.classList.add('bg-primary', 'hover:bg-primary/90');
                    
                    console.log('‚úÖ "Back to Call" button configured');
                }
                
                return true;
            } else {
                console.log(`‚ùå Room mismatch: ${activeCallData.roomId} !== ${roomData?.roomId}`);
            }
        } catch (e) {
            console.error('‚ùå Failed to parse activeCall:', e);
            localStorage.removeItem(ACTIVE_CALL_KEY);
        }
    }
    
    // No active call - show normal buttons
    console.log('‚ÑπÔ∏è No active call - showing audio/video buttons');
    if (audioCallBtn) {
        audioCallBtn.classList.remove('hidden');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('hidden');
        videoCallBtn.disabled = false;
    }
    if (joinCallBtn) {
        joinCallBtn.classList.add('hidden');
        joinCallBtn.classList.remove('flex');
    }
    
    return false;
}
  
function updateCallButtonState(isActive, callData = null) {
    console.log('üîÑ Updating call button state:', { isActive, participantCount: callData?.participantCount });
    
    // Remove loading states and re-enable buttons
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.disabled = false;
    }
    if (joinCallBtn) {
        joinCallBtn.classList.remove('join-btn-loading');
    }
    
    // Check if user is already in the call
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomData?.roomId;
    
    if (userInCall) {
        console.log('üìû User is IN call - showing "Back to Call" button');
        
        // Hide audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.add('hidden');
            audioCallBtn.disabled = true;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.add('hidden');
            videoCallBtn.disabled = true;
        }
        
        // Show "Back to Call" button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('hidden');
            joinCallBtn.classList.add('flex');
            joinCallBtn.disabled = false;
            
            // Update button text and icon
            const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
            const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
            const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
            
            if (btnIcon) btnIcon.textContent = 'call';
            if (btnTextLong) btnTextLong.textContent = 'Back to Call';
            if (btnTextShort) btnTextShort.textContent = 'Back';
            
            // Change to primary color (teal)
            joinCallBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            joinCallBtn.classList.add('bg-primary', 'hover:bg-primary/90');
            
            console.log('‚úÖ "Back to Call" button displayed');
        }
    } else if (isActive && callData) {
        console.log('üìû Active call in room but user NOT in it - showing "Join Call" button');
        
        // Hide audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.add('hidden');
            audioCallBtn.disabled = true;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.add('hidden');
            videoCallBtn.disabled = true;
        }
        
        // Show "Join Call" button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('hidden');
            joinCallBtn.classList.add('flex');
            joinCallBtn.disabled = false;
            
            // Update button text and icon for join
            const btnIcon = joinCallBtn.querySelector('.material-symbols-outlined');
            const btnTextLong = joinCallBtn.querySelector('span:not(.material-symbols-outlined).hidden.sm\\:inline');
            const btnTextShort = joinCallBtn.querySelector('span:not(.material-symbols-outlined).sm\\:hidden');
            
            if (btnIcon) btnIcon.textContent = 'login';
            if (btnTextLong) btnTextLong.textContent = 'Join Call';
            if (btnTextShort) btnTextShort.textContent = 'Join';
            
            // Green color for join
            joinCallBtn.classList.remove('bg-primary', 'hover:bg-primary/90');
            joinCallBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            
            console.log(`‚úÖ "Join Call" button displayed (${callData.participantCount} participants)`);
        }
    } else {
        console.log('üìû No active call - showing audio/video buttons');
        
        // Show audio/video buttons
        if (audioCallBtn) {
            audioCallBtn.classList.remove('hidden');
            audioCallBtn.disabled = false;
        }
        if (videoCallBtn) {
            videoCallBtn.classList.remove('hidden');
            videoCallBtn.disabled = false;
        }
        
        // Hide join button
        if (joinCallBtn) {
            joinCallBtn.classList.remove('flex');
            joinCallBtn.classList.add('hidden');
            joinCallBtn.disabled = true;
        }
        
        console.log('‚úÖ Audio/Video buttons displayed');
    }
}

  // ============================================
  // UI FUNCTIONS
  // ============================================
  
  function openSidebar() {
    if (!sidebar || !sidebarOverlay) return;
    sidebar.classList.add('show');
    sidebarOverlay.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  function closeSidebar() {
    if (!sidebar || !sidebarOverlay) return;
    sidebar.classList.remove('show');
    sidebarOverlay.classList.remove('active');
    document.body.style.overflow = '';
  }

  function toggleSidebar() {
    if (!sidebar) return;
    sidebar.classList.contains('show') ? closeSidebar() : openSidebar();
  }

  function setupUserCardClick() {
    if (window.innerWidth <= 768) {
      document.querySelectorAll('.user-card').forEach(card => {
        card.addEventListener('click', closeSidebar, { passive: true });
      });
    }
  }
  

  function createProfilePictureElement(pfpUrl, username, size = 'w-10 h-10') {
    const initial = username ? username.charAt(0).toUpperCase() : 'U';
    const container = document.createElement('div');
    container.className = `${size} rounded-full overflow-hidden bg-slate-100 border-2 border-white shadow-sm flex-shrink-0`;
    
    if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
      const img = document.createElement('img');
      img.src = pfpUrl;
      img.alt = username;
      img.className = 'h-full w-full object-cover';
      img.loading = 'lazy';
      img.onerror = function() {
        this.onerror = null;
        container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-sm">${initial}</div>`;
      };
      container.appendChild(img);
    } else {
      container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-sm">${initial}</div>`;
    }
    
    return container;
  }

  function showReplyPreview(messageData) {
    replyingTo = messageData;
    const replyPreview = document.getElementById('replyPreview');
    const replyToUsername = document.getElementById('replyToUsername');
    const replyToMessage = document.getElementById('replyToMessage');
    
    if (replyPreview && replyToUsername && replyToMessage) {
      replyToUsername.textContent = `Replying to ${messageData.username}`;
      replyToMessage.textContent = messageData.message;
      replyPreview.classList.remove('hidden');
      
      if (messageInput) messageInput.focus();
    }
  }

  function hideReplyPreview() {
    replyingTo = null;
    const replyPreview = document.getElementById('replyPreview');
    if (replyPreview) replyPreview.classList.add('hidden');
  }

function createMessageElement(data, isCurrentUser) {
    const messageItem = document.createElement('div');
    messageItem.className = `message-item flex gap-2 items-start ${isCurrentUser ? 'flex-row-reverse' : ''} animate-fade-in-up`;
    messageItem.dataset.messageId = data.messageId || `msg-${Date.now()}-${Math.random()}`;
    
    const pfpContainer = createProfilePictureElement(data.pfpUrl, data.username, 'w-8 h-8 sm:w-10 sm:h-10');
    const messageContent = document.createElement('div');
    messageContent.className = `flex flex-col ${isCurrentUser ? 'items-end' : 'items-start'} flex-1 min-w-0`;

    const headerDiv = document.createElement('div');
    headerDiv.className = `flex items-center gap-1.5 sm:gap-2 mb-1 px-1 ${isCurrentUser ? 'flex-row-reverse' : ''}`;
    
    const usernameSpan = document.createElement('span');
    usernameSpan.className = 'text-xs sm:text-sm font-semibold text-gray-200 truncate';
    usernameSpan.textContent = data.username || 'User';
    
    const timestampSpan = document.createElement('span');
    timestampSpan.className = 'text-[10px] sm:text-xs text-gray-500 whitespace-nowrap';
    timestampSpan.textContent = data.timestamp ? formatTimestamp(data.timestamp) : 'Just now';
    
    headerDiv.appendChild(usernameSpan);
    headerDiv.appendChild(timestampSpan);
    messageContent.appendChild(headerDiv);

    const bubbleWrapper = document.createElement('div');
    bubbleWrapper.className = `flex items-center gap-1`;

    const messageBubble = document.createElement('div');
    messageBubble.className = `px-3 sm:px-4 py-2 rounded-2xl ${isCurrentUser ? 'bg-[#33bfcc] text-white' : 'bg-[#2a2d33] text-gray-200'} break-words text-sm sm:text-base max-w-full`;

    if (data.replyTo) {
        const quotedDiv = document.createElement('div');
        quotedDiv.className = `quoted-message ${isCurrentUser ? '' : 'quoted-message-light'}`;
        
        const quotedUsername = document.createElement('div');
        quotedUsername.className = `text-xs font-semibold mb-1 ${isCurrentUser ? 'text-white/80' : 'text-[#33bfcc]'}`;
        quotedUsername.textContent = data.replyTo.username;
        
        const quotedText = document.createElement('div');
        quotedText.className = `text-xs ${isCurrentUser ? 'text-white/70' : 'text-gray-400'} break-words`;
        quotedText.textContent = data.replyTo.message;
        
        quotedDiv.appendChild(quotedUsername);
        quotedDiv.appendChild(quotedText);
        messageBubble.appendChild(quotedDiv);
    }

    // Add message text if present
    if (data.message) {
        const messageText = document.createElement('div');
        messageText.className = 'text-sm sm:text-base break-words';
        messageText.innerHTML = escapeHtml(data.message);
        messageBubble.appendChild(messageText);
    }

// Add attachment if present
if (data.attachment) {
  console.log(`üìé Rendering attachment in message: ${data.attachment.name} (${data.attachment.type})`);
  
  const attachmentDiv = document.createElement('div');
  attachmentDiv.className = 'message-attachment';
  
  const fileCategory = getFileTypeCategory(data.attachment.type);
  console.log(`   Category: ${fileCategory}`);
  
  if (fileCategory === 'image') {
    // Show image preview (will be loaded from IndexedDB)
    console.log(`   Creating image preview element`);
    attachmentDiv.innerHTML = `
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='300' height='200'%3E%3Crect width='300' height='200' fill='%23161b22'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%238b949e' font-family='sans-serif' font-size='14'%3ELoading image...%3C/text%3E%3C/svg%3E" 
           alt="${escapeHtml(data.attachment.name)}" 
           data-file-id="${data.attachment.fileId}"
           loading="lazy"
           style="max-width: 100%; border-radius: 8px;">
    `;
    
    // Load actual image from IndexedDB
    const imgElement = attachmentDiv.querySelector('img');
    loadImageAttachment(data.attachment.fileId, imgElement);
    
  } else if (fileCategory === 'video') {
    // Show video preview with play button
    console.log(`   Creating video file element (download on click)`);
    attachmentDiv.innerHTML = `
      <div class="message-attachment-file video" 
           data-file-id="${data.attachment.fileId}"
           style="cursor: pointer;">
        <span class="material-symbols-outlined" style="font-size: 28px; color: #a855f7;">play_circle</span>
        <div class="message-attachment-info">
          <div class="message-attachment-name">${escapeHtml(data.attachment.name)}</div>
          <div class="message-attachment-size">${formatFileSize(data.attachment.size)}</div>
          <div style="font-size: 0.7rem; opacity: 0.6; margin-top: 2px;">Click to open in video player</div>
        </div>
        <span class="material-symbols-outlined" style="font-size: 18px; opacity: 0.5;">download</span>
      </div>
    `;
    
    // Add click handler for download
    const fileElement = attachmentDiv.querySelector('.message-attachment-file');
    if (fileElement) {
      fileElement.addEventListener('click', () => {
        console.log(`üé¨ Opening video: ${data.attachment.name}`);
        downloadAttachment(data.attachment.fileId, data.attachment.name);
      }, { passive: true });
    }
    
  } else if (fileCategory === 'pdf') {
    // Show PDF icon with viewer option
    console.log(`   Creating PDF file element`);
    attachmentDiv.innerHTML = `
      <div class="message-attachment-file pdf" 
           data-file-id="${data.attachment.fileId}"
           style="cursor: pointer;">
        <span class="material-symbols-outlined" style="font-size: 28px; color: #ef4444;">picture_as_pdf</span>
        <div class="message-attachment-info">
          <div class="message-attachment-name">${escapeHtml(data.attachment.name)}</div>
          <div class="message-attachment-size">${formatFileSize(data.attachment.size)}</div>
          <div style="font-size: 0.7rem; opacity: 0.6; margin-top: 2px;">Click to open in PDF reader</div>
        </div>
        <span class="material-symbols-outlined" style="font-size: 18px; opacity: 0.5;">download</span>
      </div>
    `;
    
    // Add click handler for download
    const fileElement = attachmentDiv.querySelector('.message-attachment-file');
    if (fileElement) {
      fileElement.addEventListener('click', () => {
        console.log(`üìÑ Opening PDF: ${data.attachment.name}`);
        downloadAttachment(data.attachment.fileId, data.attachment.name);
      }, { passive: true });
    }
    
    
  } else {
    // Generic document
    console.log(`   Creating generic document element`);
    attachmentDiv.innerHTML = `
      <div class="message-attachment-file document" 
           data-file-id="${data.attachment.fileId}"
           style="cursor: pointer;">
        <span class="material-symbols-outlined" style="font-size: 28px;">description</span>
        <div class="message-attachment-info">
          <div class="message-attachment-name">${escapeHtml(data.attachment.name)}</div>
          <div class="message-attachment-size">${formatFileSize(data.attachment.size)}</div>
          <div style="font-size: 0.7rem; opacity: 0.6; margin-top: 2px;">Click to download</div>
        </div>
        <span class="material-symbols-outlined" style="font-size: 18px; opacity: 0.5;">download</span>
      </div>
    `;
    
    // Add click handler for download
    const fileElement = attachmentDiv.querySelector('.message-attachment-file');
    if (fileElement) {
      fileElement.addEventListener('click', () => {
        console.log(`üìÅ Downloading document: ${data.attachment.name}`);
        downloadAttachment(data.attachment.fileId, data.attachment.name);
      }, { passive: true });
    }
  }
  
  
  messageBubble.appendChild(attachmentDiv);
  console.log(`‚úÖ Attachment element added to message bubble`);
}

    const replyBtn = document.createElement('button');
    replyBtn.className = 'reply-btn p-1 sm:p-1.5 hover:bg-gray-800 rounded-full transition-colors flex-shrink-0';
    replyBtn.title = 'Reply';
    replyBtn.innerHTML = '<span class="material-symbols-outlined text-gray-500 text-base sm:text-lg">reply</span>';
    replyBtn.addEventListener('click', () => {
        showReplyPreview({
            messageId: messageItem.dataset.messageId,
            username: data.username,
            message: data.message || `[${data.attachment?.name}]`,
            userId: data.userId
        });
    }, { passive: true });

    if (isCurrentUser) {
        bubbleWrapper.appendChild(replyBtn);
        bubbleWrapper.appendChild(messageBubble);
    } else {
        bubbleWrapper.appendChild(messageBubble);
        bubbleWrapper.appendChild(replyBtn);
    }

    messageContent.appendChild(bubbleWrapper);
    messageItem.appendChild(pfpContainer);
    messageItem.appendChild(messageContent);
    
    return messageItem;
}


/**
 * Load image attachment from IndexedDB and display
 * Now includes retry mechanism and peer request fallback
 */
async function loadImageAttachment(fileId, imgElement) {
  if (!imgElement) {
    console.error('‚ùå Image element not provided for fileId:', fileId);
    return;
  }
  
  console.log(`üñºÔ∏è Loading image attachment: ${fileId}`);
  
  try {
    let fileData = await getFileFromIndexedDB(fileId);
    
    // ============================================
    // CRITICAL FIX: If file not found locally, it may be loading
    // Wait briefly and retry before showing error
    // ============================================
    if (!fileData || !fileData.blob) {
      console.log(`‚è≥ File not found, waiting 2s for peer transfer...`);
      
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Retry once
      fileData = await getFileFromIndexedDB(fileId);
      
      if (!fileData || !fileData.blob) {
        console.error(`‚ùå File ${fileId} still not found after retry`);
        
        imgElement.alt = 'Loading...';
        imgElement.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="300" height="200"%3E%3Crect width="300" height="200" fill="%23161b22"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" fill="%238b949e" font-family="sans-serif" font-size="14"%3ERequesting file...%3C/text%3E%3C/svg%3E';
        
        return;
      }
    }
    
    console.log(`‚úÖ File data retrieved: ${fileData.name} (${(fileData.size / 1024).toFixed(2)} KB)`);
    
    const blobUrl = URL.createObjectURL(fileData.blob);
    console.log(`üîó Created blob URL for display`);
    
    imgElement.src = blobUrl;
    imgElement.alt = fileData.name;
    imgElement.dataset.blobUrl = blobUrl;
    
    imgElement.onload = () => {
      console.log(`‚úÖ Image loaded successfully: ${fileData.name}`);
    };
    
    imgElement.onerror = () => {
      console.error(`‚ùå Failed to load image: ${fileData.name}`);
      URL.revokeObjectURL(blobUrl);
      imgElement.alt = 'Failed to load image';
    };
    
    imgElement.style.cursor = 'pointer';
    
    const newImg = imgElement.cloneNode(true);
    imgElement.parentNode?.replaceChild(newImg, imgElement);
    
    newImg.addEventListener('click', async () => {
      console.log(`üîç Opening full-size image: ${fileData.name}`);
      
      try {
        const freshBlob = await getFileFromIndexedDB(fileId);
        if (!freshBlob || !freshBlob.blob) {
          toast('Failed to open image', 'error');
          return;
        }
        
        const freshBlobUrl = URL.createObjectURL(freshBlob.blob);
        const newWindow = window.open(freshBlobUrl, '_blank');
        
        console.log(`‚úÖ Opened image in new window`);
        
        if (newWindow) {
          newWindow.addEventListener('load', () => {
            setTimeout(() => {
              URL.revokeObjectURL(freshBlobUrl);
              console.log('üßπ Revoked blob URL from new window');
            }, 1000);
          });
        } else {
          URL.revokeObjectURL(freshBlobUrl);
          toast('Please allow popups to view full image', 'warning');
        }
        
      } catch (error) {
        console.error('‚ùå Failed to open full-size image:', error);
        toast('Failed to open image', 'error');
      }
    }, { passive: true });
    
  } catch (error) {
    console.error('‚ùå Error loading image attachment:', error);
    imgElement.alt = 'Failed to load image';
    imgElement.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="300" height="200"%3E%3Crect width="300" height="200" fill="%23161b22"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" fill="%23ef4444" font-family="sans-serif" font-size="14"%3EError loading image%3C/text%3E%3C/svg%3E';
  }
}

/**
 * Download attachment file
 */
async function downloadAttachment(fileId, fileName) {
  console.log('üì• ========================================');
  console.log('üì• DOWNLOAD ATTACHMENT REQUESTED');
  console.log('üì• ========================================');
  console.log(`   FileID: ${fileId}`);
  console.log(`   Filename: ${fileName}`);
  
  try {
    const fileData = await getFileFromIndexedDB(fileId);
    
    if (!fileData || !fileData.blob) {
      console.error('‚ùå File not found in IndexedDB');
      toast('File not found', 'error');
      console.log('üì• ========================================\n');
      return;
    }
    
    console.log(`‚úÖ File retrieved from IndexedDB`);
    console.log(`   Size: ${(fileData.size / 1024).toFixed(2)} KB`);
    console.log(`   Type: ${fileData.type}`);
    
    // Create download link
    const blobUrl = URL.createObjectURL(fileData.blob);
    const a = document.createElement('a');
    a.href = blobUrl;
    a.download = fileName;
    a.style.display = 'none';
    document.body.appendChild(a);
    
    console.log('üîΩ Triggering download...');
    a.click();
    
    // Cleanup
    document.body.removeChild(a);
    setTimeout(() => {
      URL.revokeObjectURL(blobUrl);
      console.log('üßπ Download blob URL revoked');
    }, 1000);
    
    toast(`Downloading ${fileName}`, 'success');
    console.log(`‚úÖ Download initiated successfully`);
    console.log('üì• ========================================\n');
    
  } catch (error) {
    console.error('‚ùå Download error:', error);
    console.error('   Stack:', error.stack);
    toast('Download failed', 'error');
    console.log('üì• ========================================\n');
  }
}

  // ============================================
  // CONFIRMATION DIALOG
  // ============================================
  
function showConfirmationDialog() {
    return new Promise((resolve) => {
      const overlay = document.getElementById('confirmationOverlay');
      if (!overlay) return resolve(false);
      
      const dialogHTML = `
        <div class="confirmation-overlay" style="position: fixed; inset: 0; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(8px); display: flex; align-items: center; justify-content: center; z-index: 9999;">
          <div class="confirmation-dialog" style="background: linear-gradient(135deg, #0d1117 0%, #161b22 100%); border: 1px solid #30363d; border-radius: 16px; padding: 2rem; max-width: 400px; width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 1px rgba(6, 182, 212, 0.3);">
            <div style="text-align: center; margin-bottom: 1.5rem;">
              <div style="width: 64px; height: 64px; margin: 0 auto 1rem; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(220, 38, 38, 0.15) 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(239, 68, 68, 0.3);">
                <span class="material-symbols-outlined" style="font-size: 32px; color: #ef4444;">warning</span>
              </div>
              <h3 style="font-size: 1.35rem; font-weight: 700; margin-bottom: 0.75rem; color: #f0f6fc;">Leave Chat Room?</h3>
              <p style="color: #8b949e; font-size: 0.95rem; line-height: 1.6;">
                You're currently in an active chat room. If you leave, you'll be disconnected from the conversation.
              </p>
            </div>
            <div style="display: flex; gap: 0.75rem; justify-content: center;">
              <button class="btn-stay" id="btnStay" style="flex: 1; padding: 0.875rem 1.5rem; border-radius: 10px; font-weight: 600; font-size: 0.95rem; cursor: pointer; transition: all 0.2s; background-color: #1c2128; color: #c9d1d9; border: 1px solid #30363d;">Stay Here</button>
              <button class="btn-leave" id="btnLeave" style="flex: 1; padding: 0.875rem 1.5rem; border-radius: 10px; font-weight: 600; font-size: 0.95rem; cursor: pointer; transition: all 0.2s; background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%); color: white; border: 1px solid #f87171; box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);">Leave</button>
            </div>
          </div>
        </div>
      `;
      
      overlay.innerHTML = dialogHTML;
      overlay.style.display = 'flex';
      
      const btnStay = document.getElementById('btnStay');
      const btnLeave = document.getElementById('btnLeave');
      
      // Add hover effects for Stay button
      if (btnStay) {
        btnStay.addEventListener('mouseenter', () => {
          btnStay.style.backgroundColor = '#21262d';
          btnStay.style.borderColor = '#444c56';
        });
        btnStay.addEventListener('mouseleave', () => {
          btnStay.style.backgroundColor = '#1c2128';
          btnStay.style.borderColor = '#30363d';
        });
        btnStay.addEventListener('click', () => {
          overlay.style.display = 'none';
          resolve(false);
        }, { once: true });
      }
      
      // Add hover effects and complete click handler for Leave button
      if (btnLeave) {
        btnLeave.addEventListener('mouseenter', () => {
          btnLeave.style.background = 'linear-gradient(135deg, #ef4444 0%, #f87171 100%)';
          btnLeave.style.boxShadow = '0 0 25px rgba(239, 68, 68, 0.5)';
        });
        btnLeave.addEventListener('mouseleave', () => {
          btnLeave.style.background = 'linear-gradient(135deg, #dc2626 0%, #ef4444 100%)';
          btnLeave.style.boxShadow = '0 0 20px rgba(239, 68, 68, 0.3)';
        });
        btnLeave.addEventListener('click', async () => {
          console.log('‚úÖ User confirmed leaving via dialog - starting cleanup');
          overlay.style.display = 'none';
          
          // CRITICAL: Clean up background call FIRST
          const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
          
          if (activeCallStr) {
            console.log('üìû Active call detected - cleaning up');
            
            try {
              const callData = JSON.parse(activeCallStr);
              
              // 1. Emit leave_call to server
              if (socketInstance && socketInstance.connected) {
                console.log('üì§ Emitting leave_call to server...');
                socketInstance.emit('leave_call', { callId: callData.callId });
                
                // Wait for server to process
                await new Promise(resolve => setTimeout(resolve, 500));
                console.log('‚úÖ Leave_call emitted and processed');
              }
              
              // 2. Clear all call-related storage
              localStorage.removeItem(ACTIVE_CALL_KEY);
              sessionStorage.removeItem('hasBackgroundCall');
              sessionStorage.removeItem('returningFromCall');
              sessionStorage.removeItem('backgroundCallMode');
              sessionStorage.removeItem('returningToBackgroundCall');
              
              console.log('‚úÖ Background call destroyed');
              
            } catch (e) {
              console.error('‚ùå Failed during call cleanup:', e);
            }
          }
          
          // 3. Leave chat room
          if (socketInstance && socketInstance.connected) {
            console.log('üì§ Emitting leave_room...');
            socketInstance.emit('leave_room');
            
            // Wait for server to process
            await new Promise(resolve => setTimeout(resolve, 300));
          }
          
          clearChatState(true);
          
          resolve(true);
          
          // 5. Navigate - this will handle both iframe and standalone cases
          setTimeout(() => {
            console.log('‚úÖ Cleanup complete - initiating navigation');
            cleanupParentCallPage();
          }, 100);
          
        }, { once: true });
      }
    });
  }

  // ============================================
  // BACK BUTTON HANDLER
  // ============================================
  
function setupBackButtonHandler() {
  history.pushState({ page: 'chat' }, '', window.location.href);
  
  let dialogOpen = false; // Track dialog state
  
  window.addEventListener('popstate', async (event) => {
    if (backButtonHandled) return;
    
    // CRITICAL: If dialog is already open, just push state and ignore
    if (dialogOpen) {
      console.log('‚ö†Ô∏è Dialog already open - ignoring back button');
      history.pushState({ page: 'chat' }, '', window.location.href);
      return;
    }
    
    console.log('‚¨ÖÔ∏è Back button pressed');
    history.pushState({ page: 'chat' }, '', window.location.href);
    
    dialogOpen = true; // Mark dialog as open
    const shouldLeave = await showConfirmationDialog();
    dialogOpen = false; // Mark dialog as closed
    
    if (shouldLeave) {
      console.log('‚úÖ User confirmed leaving');
      backButtonHandled = true;
      
      if (socketInstance?.connected) {
        socketInstance.emit('leave_room');
      }
      
      clearChatState(true);
      window.location.href = '/mood.html';
    } else {
      console.log('‚ùå User staying in chat');
    }
  });
}

  const updateTimer = () => {
    if (!serverExpiresAt) {
      console.warn('‚ö†Ô∏è No server expiresAt available');
      if (timeRemaining) {
        timeRemaining.textContent = '-- remaining';
      }
      return;
    }
    
    // CRITICAL: Always use server-adjusted time
    const clientNow = Date.now();
    const serverNow = clientNow + serverClockOffset;
    const remaining = Math.max(0, serverExpiresAt - serverNow);
    
    const minutes = Math.floor(remaining / 60000);
    const seconds = Math.floor((remaining % 60000) / 1000);
    
    if (timeRemaining) {
      timeRemaining.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} remaining`;
    }
    
    // Debug log every 10 seconds
    if (Math.floor(serverNow / 10000) !== Math.floor((serverNow - 1000) / 10000)) {
      console.log(`‚è∞ Timer: ${minutes}:${seconds.toString().padStart(2, '0')} (offset: ${(serverClockOffset/1000).toFixed(1)}s)`);
    }
    
    if (remaining === 0) {
      console.error('‚ùå Room expired - redirecting');
      if (timerInterval) clearInterval(timerInterval);
      toast('Room has expired', 'warning');
      clearChatState(true);
      setTimeout(() => window.location.href = '/mood.html', 2000);
    }
  };

  // ============================================
  // SOCKET EVENT HANDLERS
  // ============================================
  
  function setupSocketHandlers() {
    if (!socketInstance) return;
    
    
    // ============================================
// CHUNKED FILE TRANSMISSION HANDLERS
// ============================================

socketInstance.on('file_chunk', async (data) => {
  try {
    await fileReceiver.handleChunk(data);
  } catch (error) {
    console.error('‚ùå Error handling chunk:', error);
  }
});

socketInstance.on('file_transmission_complete', ({ fileId, fileName }) => {
  console.log(`‚úÖ File transmission complete: ${fileName} (${fileId})`);
  toast(`Received: ${fileName}`, 'success');
});

socketInstance.on('file_transmission_failed', ({ fileId, fileName, reason }) => {
  console.error(`‚ùå File transmission failed: ${fileName}`);
  console.error(`   Reason: ${reason}`);
  
  fileReceiver.cleanup(fileId);
  toast(`Failed to receive: ${fileName}`, 'error');
});
    
    
    socketInstance.on('cached_call_valid', (data) => {
    console.log('‚úÖ Cached call validated by server:', data.callId);
    console.log(`   Showing modal for call from ${data.callerUsername}`);
    
    showCachedCallModal(data);
});

socketInstance.on('cached_call_invalid', (data) => {
    console.log('‚ùå Cached call invalid:', data.callId);
    localStorage.removeItem(CACHED_CALL_KEY);
    console.log('üóëÔ∏è Cleared invalid cached call');
});
    
socketInstance.on('connect', () => {
  console.log('üîå ========================================');
  console.log('üîå SOCKET CONNECTED');
  console.log('üîå ========================================');
  console.log(`   Socket ID: ${socketInstance.id}`);
  console.log(`   User: ${currentUser?.username || 'unknown'}`);
  
  // CRITICAL: Reset auth state on new connection
  setAuthenticationState(false);
  
  firebase.auth().currentUser?.getIdToken().then(idToken => {
    console.log('üì§ Sending authentication to server...');
    socketInstance.emit('authenticate', {
      token: idToken,
      userId: currentUser.userId
    });
  }).catch(err => {
    console.error('‚ùå Failed to get token:', err);
    toast('Authentication failed. Please refresh.', 'error');
  });
  
  console.log('üîå ========================================\n');
});

socketInstance.on('connect_error', (error) => {
  console.error('‚ùå Socket connection error:', error.message);
  setAuthenticationState(false);
  toast('Connection error. Retrying...', 'warning');
});

socketInstance.on('disconnect', (reason) => {
  console.log('üîå Socket disconnected:', reason);
  setAuthenticationState(false);
  
  if (reason === 'io server disconnect') {
    // Server disconnected us, need to reconnect manually
    socketInstance.connect();
  }
});

socketInstance.on('authenticated', async () => {
  console.log('‚úÖ ========================================');
  console.log('‚úÖ SOCKET AUTHENTICATED');
  console.log('‚úÖ ========================================');
  console.log(`   Socket ID: ${socketInstance.id}`);
  console.log(`   User: ${currentUser?.username} (${currentUser?.userId})`);
  
  // CRITICAL: Set authentication state FIRST
  setAuthenticationState(true);
  
  // Request room data from server for clock sync
  const roomStr = localStorage.getItem('currentRoom');
  if (roomStr) {
    try {
      const localRoomData = JSON.parse(roomStr);
      console.log('üì¶ Requesting fresh room data for clock sync...');
      
      socketInstance.emit('request_room_sync', { roomId: localRoomData.roomId });
      
    } catch (e) {
      console.error('‚ùå Failed to parse room data:', e);
    }
  }
  
  startCachedCallMonitoring();
  socketInstance.emit('join_room', { roomId: roomData.roomId });
  
  console.log('‚úÖ ========================================\n');
});


socketInstance.on('call_created', (data) => {
  console.log('üìû ========================================');
  console.log('üìû CALL_CREATED EVENT RECEIVED');
  console.log('üìû ========================================');
  console.log(`   callId: ${data.callId}`);
  console.log(`   callType: ${data.callType}`);
  console.log(`   isInitiator: ${data.isInitiator}`);
  
  // Only navigate if we're the initiator
  if (data.isInitiator) {
    console.log('‚úÖ We initiated this call - navigating to call page');
    
    // Mark that we're navigating to call
    navigatingToCall = true;
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading');
      audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading');
      videoCallBtn.disabled = false;
    }
    
    // Save chat state
    saveChatState(roomData.roomId, messagesCache);
    sessionStorage.setItem('returningFromCall', 'true');
    
    // Store call data
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
      callId: data.callId,
      roomId: roomData.roomId,
      callType: data.callType,
      users: data.participants || []
    }));
    
    console.log(`‚úÖ Stored call data, navigating to call.html`);
    console.log('üìû ========================================\n');
    
    // Navigate to call page
    window.location.href = '/call.html';
  } else {
    console.log('‚ÑπÔ∏è Call created by someone else - staying in chat, showing JOIN button');
    console.log('üìû ========================================\n');
  }
});


socketInstance.on('room_joined', async (data) => {
  console.log('‚úÖ ========================================');
  console.log('‚úÖ ROOM_JOINED EVENT RECEIVED');
  console.log('‚úÖ ========================================');
  console.log(`   roomId: ${data.roomId}`);
  
  // [Keep existing clock sync code...]
  const clientNow = Date.now();
  
  if (data.serverTime) {
    serverClockOffset = data.serverTime - clientNow;
    console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
    console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
    console.log(`   ‚è∞ CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);
    
    if (Math.abs(serverClockOffset) > 5000) {
      console.warn(`‚ö†Ô∏è WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
    }
  } else {
    console.warn('‚ö†Ô∏è No serverTime in room_joined, assuming no clock skew');
    serverClockOffset = 0;
  }
  
  if (data.expiresAt) {
    serverExpiresAt = data.expiresAt;
    
    const serverNow = clientNow + serverClockOffset;
    const timeRemaining = data.expiresAt - serverNow;
    
    console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
    console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
    console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);
    
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const localRoomData = JSON.parse(roomStr);
        localRoomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(localRoomData));
        console.log('‚úÖ Updated localStorage with server expiry time');
      } catch (e) {
        console.error('‚ùå Failed to update localStorage:', e);
      }
    }
  } else {
    console.error('‚ùå No expiresAt in room_joined data!');
  }
  
  const cachedState = loadChatState();
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  const isInIframe = window.parent && window.parent !== window;

  let shouldUseCache = false;

  if (activeCallStr && isInIframe) {
    try {
      const activeCall = JSON.parse(activeCallStr);
      const roomStr = localStorage.getItem('currentRoom');
      if (roomStr) {
        const room = JSON.parse(roomStr);
        if (activeCall.roomId === room.roomId && cachedState && cachedState.roomId === roomData.roomId) {
          shouldUseCache = true;
          console.log('üîÑ Active call in iframe detected - will MERGE cache with server');
        }
      }
    } catch (e) {
      console.warn('Failed to check active call:', e);
    }
  }

  let mergedMessages = [];

  if (data.chatHistory?.length > 0) {
    console.log(`üìú Server provided ${data.chatHistory.length} messages`);
    
    mergedMessages = [...data.chatHistory];
    
    if (shouldUseCache && cachedState?.messages?.length > 0) {
      console.log(`üì¶ Merging ${cachedState.messages.length} cached messages with server data`);
      
      const serverMessageIds = new Set(
        data.chatHistory.map(msg => msg.messageId || `${msg.userId}-${msg.timestamp}`)
      );
      
      const uniqueCachedMessages = cachedState.messages.filter(msg => {
        const msgId = msg.messageId || `${msg.userId}-${msg.timestamp}`;
        return !serverMessageIds.has(msgId);
      });
      
      if (uniqueCachedMessages.length > 0) {
        console.log(`‚ûï Adding ${uniqueCachedMessages.length} unique cached messages`);
        mergedMessages = [...mergedMessages, ...uniqueCachedMessages];
        mergedMessages.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
      }
    }
    
    // ============================================
    // CRITICAL FIX: REQUEST MISSING FILE DATA
    // ============================================
    console.log('üîç Checking for attachments that need data...');
    
    for (const msg of mergedMessages) {
      if (msg.attachment && msg.attachment.fileId) {
        // Check if file exists in local IndexedDB
        try {
          const localFile = await getFileFromIndexedDB(msg.attachment.fileId);
          
          if (!localFile) {
            console.log(`üìÇ File ${msg.attachment.fileId} not in local storage`);
            
            // Only request if sent by someone else
            if (msg.userId !== currentUser.userId) {
              console.log(`üì° Requesting file data from peer for ${msg.attachment.name}`);
              
              // Request file from sender via socket
              socketInstance.emit('request_attachment_data', {
                fileId: msg.attachment.fileId,
                roomId: roomData.roomId
              });
            }
          } else {
            console.log(`‚úÖ File ${msg.attachment.name} already in local storage`);
          }
        } catch (e) {
          console.error(`‚ùå Error checking file ${msg.attachment.fileId}:`, e);
        }
      }
    }
    
  } else if (shouldUseCache && cachedState?.messages?.length > 0) {
    console.log(`üì¶ No server history, using ${cachedState.messages.length} cached messages`);
    mergedMessages = [...cachedState.messages];
  } else {
    console.log('‚ÑπÔ∏è No server history and no cache - starting fresh');
  }

  messagesCache = mergedMessages;

  console.log(`üé® Rendering ${messagesCache.length} total messages`);
  messagesCache.forEach(msg => {
    const isCurrentUser = msg.userId === currentUser.userId;
    const msgEl = createMessageElement(msg, isCurrentUser);
    messagesList?.appendChild(msgEl);
  });

  if (messagesList && messagesCache.length > 0) {
    messagesList.scrollTop = messagesList.scrollHeight;
    console.log('‚úÖ Scrolled to latest message');
  }

  saveChatState(roomData.roomId, messagesCache);
  console.log(`üíæ Saved ${messagesCache.length} messages to cache after merge`);
  
  // [Rest of room_joined handler...]
  if (shouldUseCache && cachedState) {
    console.log('üîÑ Restoring call button state from cache:', cachedState.callButtonState);
    console.log('   Cached activeCallInRoom:', cachedState.activeCallInRoom);
    
    if (cachedState.activeCallInRoom) {
      activeCallInRoom = cachedState.activeCallInRoom;
      console.log('üíæ Restored activeCallInRoom from cache:', activeCallInRoom);
    } else if (cachedState.callButtonState === 'back') {
      const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
      if (activeCallStr) {
        try {
          const activeCallData = JSON.parse(activeCallStr);
          activeCallInRoom = {
            callId: activeCallData.callId,
            callType: activeCallData.callType,
            participantCount: 2
          };
          console.log('üíæ Reconstructed activeCallInRoom from ACTIVE_CALL_KEY:', activeCallInRoom);
        } catch (e) {
          console.error('Failed to reconstruct activeCallInRoom:', e);
        }
      }
    } else if (cachedState.callButtonState === 'join' && !activeCallInRoom) {
      console.warn('‚ö†Ô∏è Cache says "join" but no activeCallInRoom - will wait for server update');
    }
    
    if (cachedState.callButtonState === 'back') {
      updateCallButtonState(true, activeCallInRoom || { participantCount: 1 });
    } else if (cachedState.callButtonState === 'join' && activeCallInRoom) {
      updateCallButtonState(true, activeCallInRoom);
    } else {
      updateCallButtonState(false);
    }
    
    console.log('‚úÖ Call button state restored instantly');
  }
  
  if (data.activeCall) {
    console.log('üìû Active call in room detected');
    
    activeCallInRoom = {
      callId: data.activeCall.callId,
      callType: data.activeCall.callType,
      participantCount: data.activeCall.participantCount
    };
    console.log('üíæ Stored activeCallInRoom:', activeCallInRoom);
  } 
  
  console.log('‚è∞ Starting timer updates with server-synced time...');
  updateTimer();
  
  console.log('‚úÖ ========================================\n');
});

// ============================================
// PEER-TO-PEER FILE TRANSFER HANDLERS
// ============================================

socketInstance.on('send_attachment_to_peer', async ({ fileId, requesterId, requesterSocketId }) => {
  console.log('üì§ ========================================');
  console.log('üì§ PEER REQUESTING OUR FILE');
  console.log('üì§ ========================================');
  console.log(`   FileID: ${fileId}`);
  console.log(`   Requester: ${requesterId}`);
  
  try {
    // Get file from our IndexedDB
    const fileData = await getFileFromIndexedDB(fileId);
    
    if (!fileData || !fileData.blob) {
      console.error(`‚ùå File ${fileId} not found in our IndexedDB`);
      socketInstance.emit('attachment_data_response', {
        fileId,
        requesterId,
        requesterSocketId,
        data: null,
        metadata: null
      });
      return;
    }
    
    console.log(`‚úÖ File found: ${fileData.name} (${(fileData.size / 1024).toFixed(2)} KB)`);
    
    // Convert blob to base64
    const base64Data = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result.split(',')[1];
        resolve(base64);
      };
      reader.onerror = reject;
      reader.readAsDataURL(fileData.blob);
    });
    
    console.log(`‚úÖ Converted to base64: ${(base64Data.length / 1024).toFixed(2)} KB`);
    
    // Send to requester via server relay
    socketInstance.emit('attachment_data_response', {
      fileId,
      requesterId,
      requesterSocketId,
      data: base64Data,
      metadata: {
        name: fileData.name,
        type: fileData.type,
        size: fileData.size
      }
    });
    
    console.log(`üì§ File data sent to requester`);
    console.log('üì§ ========================================\n');
    
  } catch (error) {
    console.error('‚ùå Error sending file to peer:', error);
    console.log('üì§ ========================================\n');
  }
});

socketInstance.on('attachment_data_received', async ({ fileId, data, metadata }) => {
  console.log('üì• ========================================');
  console.log('üì• ATTACHMENT DATA RECEIVED FROM PEER');
  console.log('üì• ========================================');
  console.log(`   FileID: ${fileId}`);
  console.log(`   File: ${metadata?.name}`);
  console.log(`   Size: ${metadata?.size ? (metadata.size / 1024).toFixed(2) : 0} KB`);
  
  if (!data || !metadata) {
    console.error('‚ùå Invalid data received');
    console.log('üì• ========================================\n');
    return;
  }
  
  try {
    // Convert base64 back to blob
    const byteCharacters = atob(data);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    const blob = new Blob([byteArray], { type: metadata.type });
    
    // Create File object
    const file = new File([blob], metadata.name, { type: metadata.type });
    
    // Store to our IndexedDB with SAME fileId
    await new Promise((resolve, reject) => {
      initFileDB().then(db => {
        const transaction = db.transaction([FILE_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(FILE_STORE_NAME);
        
        const fileRecord = {
          id: fileId, // Use same ID as sender
          roomId: roomData.roomId,
          messageId: null,
          name: metadata.name,
          type: metadata.type,
          size: metadata.size,
          blob: blob,
          timestamp: Date.now()
        };
        
        const request = store.add(fileRecord);
        
        request.onsuccess = () => {
          console.log(`‚úÖ File stored to local IndexedDB: ${fileId}`);
          resolve();
        };
        
        request.onerror = () => {
          console.error('‚ùå Failed to store received file:', request.error);
          reject(request.error);
        };
      }).catch(reject);
    });
    
    // Find and update the image element if it's already rendered
    const imgElements = document.querySelectorAll(`img[data-file-id="${fileId}"]`);
    
    if (imgElements.length > 0) {
      console.log(`üñºÔ∏è Found ${imgElements.length} image element(s) to update`);
      
      imgElements.forEach(imgElement => {
        loadImageAttachment(fileId, imgElement);
      });
    } else {
      console.log('‚ÑπÔ∏è No rendered elements found for this file (will load when message is rendered)');
    }
    
    console.log('‚úÖ File successfully received and stored');
    console.log('üì• ========================================\n');
    
  } catch (error) {
    console.error('‚ùå Error processing received file:', error);
    console.log('üì• ========================================\n');
  }
});

socketInstance.on('attachment_data_unavailable', ({ fileId, reason }) => {
  console.warn('‚ö†Ô∏è ========================================');
  console.warn('‚ö†Ô∏è ATTACHMENT DATA UNAVAILABLE');
  console.warn('‚ö†Ô∏è ========================================');
  console.warn(`   FileID: ${fileId}`);
  console.warn(`   Reason: ${reason}`);
  
  // Update UI to show file unavailable
  const imgElements = document.querySelectorAll(`img[data-file-id="${fileId}"]`);
  
  imgElements.forEach(img => {
    img.alt = `File unavailable: ${reason}`;
    img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="300" height="200"%3E%3Crect width="300" height="200" fill="%23161b22"/%3E%3Ctext x="50%25" y="45%25" dominant-baseline="middle" text-anchor="middle" fill="%23ef4444" font-family="sans-serif" font-size="14"%3EFile unavailable%3C/text%3E%3Ctext x="50%25" y="60%25" dominant-baseline="middle" text-anchor="middle" fill="%238b949e" font-family="sans-serif" font-size="11"%3E' + encodeURIComponent(reason) + '%3C/text%3E%3C/svg%3E';
  });
  
  console.warn('‚ö†Ô∏è ========================================\n');
});

socketInstance.on('room_sync_data', (data) => {
  console.log('‚è∞ ========================================');
  console.log('‚è∞ ROOM SYNC DATA RECEIVED');
  console.log('‚è∞ ========================================');
  
  const clientNow = Date.now();
  
  if (!data.serverTime) {
    console.warn('‚ö†Ô∏è No serverTime in sync data, assuming no clock skew');
    data.serverTime = clientNow;
  }
  
  // Calculate clock offset
  serverClockOffset = data.serverTime - clientNow;
  
  console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
  console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
  console.log(`   ‚è∞ CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);
  
  if (Math.abs(serverClockOffset) > 5000) {
    console.warn(`‚ö†Ô∏è WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
    console.warn(`   Timer will be adjusted to compensate`);
  }
  
  if (data.expiresAt) {
    serverExpiresAt = data.expiresAt;
    
    // Calculate time remaining using server-adjusted time
    const serverNow = clientNow + serverClockOffset;
    const timeRemaining = data.expiresAt - serverNow;
    
    console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
    console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
    console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);
    
    // Update localStorage with synced data
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const localRoomData = JSON.parse(roomStr);
        localRoomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(localRoomData));
        console.log('‚úÖ Updated localStorage with server expiry time');
      } catch (e) {
        console.error('‚ùå Failed to update localStorage:', e);
      }
    }
  }
  
  console.log('‚è∞ ========================================\n');
  
  // Force timer update with new data
  updateTimer();
});

socketInstance.on('room_expiring_soon', (data) => {
  console.warn('‚ö†Ô∏è ========================================');
  console.warn('‚ö†Ô∏è ROOM EXPIRING SOON');
  console.warn('‚ö†Ô∏è ========================================');
  console.warn(`   Expires in: ${data.expiresIn / 1000} seconds`);
  console.warn(`   expiresAt: ${new Date(data.expiresAt).toISOString()}`);
  
  const clientNow = Date.now();
  const serverNow = clientNow + serverClockOffset;
  const remaining = data.expiresAt - serverNow;
  
  console.warn(`   Client now: ${new Date(clientNow).toISOString()}`);
  console.warn(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
  console.warn(`   Remaining (adjusted): ${(remaining / 1000).toFixed(1)}s`);
  console.warn('‚ö†Ô∏è ========================================\n');
  
  toast('Room expiring soon!', 'warning');
});

socketInstance.on('error', (data) => {
  console.error('‚ùå ========================================');
  console.error('‚ùå SOCKET ERROR EVENT');
  console.error('‚ùå ========================================');
  console.error('   Error code:', data.code);
  console.error('   Error message:', data.message);
  console.error('   Timestamp:', new Date().toISOString());
  console.error('   isInitiatingCall:', isInitiatingCall);
  console.error('   isSocketAuthenticated:', isSocketAuthenticated);
  
  // CRITICAL: Always clear initiating state on any error
  const wasInitiating = isInitiatingCall;
  isInitiatingCall = false;
  
  // CRITICAL: Handle authentication errors with auto-recovery
  if (data.message === 'Not authenticated') {
    console.error('‚ùå NOT AUTHENTICATED ERROR RECEIVED');
    console.error('   This indicates a race condition - call initiated before auth completed');
    console.error('   Current auth state:', isSocketAuthenticated);
    console.error('   Socket connected:', socketInstance?.connected);
    console.error('   User data exists:', !!currentUser);
    console.error('   Was initiating call:', wasInitiating);
    
    // Clear call loading states immediately
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
        console.error('   ‚è∞ Cleared audio button timeout:', timeoutId);
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
        console.error('   ‚è∞ Cleared video button timeout:', timeoutId);
      }
    }
    
    console.error('   üîí Call loading states cleared');
    
    // Force re-authentication
    setAuthenticationState(false);
    
    // Attempt to recover
    if (socketInstance && socketInstance.connected && currentUser) {
      console.log('üîÑ Attempting authentication recovery...');
      
      firebase.auth().currentUser?.getIdToken(true).then(idToken => {
        console.log('üì§ Re-sending authentication with fresh token...');
        socketInstance.emit('authenticate', {
          token: idToken,
          userId: currentUser.userId
        });
        
        toast('Reconnecting...', 'info');
        
        // Set recovery timeout
        const recoveryTimeout = setTimeout(() => {
          if (!isSocketAuthenticated) {
            console.error('‚ùå Recovery timeout - authentication failed after 10s');
            toast('Authentication failed. Please refresh the page.', 'error');
          } else {
            console.log('‚úÖ Authentication recovered successfully');
            
            // If user was trying to initiate a call, show helpful message
            if (wasInitiating) {
              toast('Connected! You can now start a call.', 'success');
            }
          }
        }, 10000);
        
        console.log('‚è∞ Recovery timeout set:', recoveryTimeout);
        
      }).catch(err => {
        console.error('‚ùå Recovery authentication failed:', err);
        toast('Authentication failed. Please refresh the page.', 'error');
      });
    } else {
      console.error('‚ùå Cannot recover - missing socket or user data');
      console.error('   Socket exists:', !!socketInstance);
      console.error('   Socket connected:', socketInstance?.connected);
      console.error('   Current user:', !!currentUser);
      toast('Connection lost. Please refresh the page.', 'error');
    }
    
    console.error('‚ùå ========================================\n');
    return;
  }
  
  // CRITICAL FIX: Handle CALL_ALREADY_ACTIVE error - auto-join instead
  if (data.code === 'CALL_ALREADY_ACTIVE') {
    console.log('üîÑ ========================================');
    console.log('üîÑ CALL_ALREADY_ACTIVE ERROR HANDLING');
    console.log('üîÑ ========================================');
    console.log(`   Existing callId: ${data.callId}`);
    console.log(`   callType: ${data.callType}`);
    console.log(`   participantCount: ${data.participantCount}`);
    console.log(`   Was initiating: ${wasInitiating}`);
    
    // Clear loading states from call initiation
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
        console.log('   ‚è∞ Cleared audio button timeout');
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
        console.log('   ‚è∞ Cleared video button timeout');
      }
    }
    
    // Re-enable buttons if authenticated
    if (isSocketAuthenticated) {
      console.log('   ‚úÖ Re-enabling call buttons (authenticated)');
      enableCallButtons();
    } else {
      console.log('   ‚è≥ Keeping buttons disabled (not authenticated)');
    }
    
    // Store the active call info
    activeCallInRoom = {
      callId: data.callId,
      callType: data.callType || 'audio',
      participantCount: data.participantCount || 1
    };
    console.log('üíæ Stored activeCallInRoom:', activeCallInRoom);
    
    // Update UI to show join button
    updateCallButtonState(true, activeCallInRoom);
    
    // Show friendly message
    toast('A call is already active. Click "Join Call" to join.', 'success');
    console.log('üîÑ ========================================\n');
    return;
  }
  
  // Handle room-related errors
  if (data.code === 'ROOM_NOT_FOUND' || data.code === 'NOT_IN_ROOM') {
    console.error('‚ùå ROOM ERROR:', data.code);
    console.error('   Message:', data.message);
    console.error('   Current room:', roomData?.roomId);
    console.error('   Was initiating:', wasInitiating);
    
    toast('Room no longer available', 'error');
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
      }
    }
    
    // Clear all storage
    clearChatState(true);
    localStorage.removeItem(ACTIVE_CALL_KEY);
    sessionStorage.removeItem('hasBackgroundCall');
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    sessionStorage.removeItem('returningToBackgroundCall');
    
    console.error('üóëÔ∏è Cleared all storage due to room error');
    
    // Navigate and cleanup parent if in iframe
    setTimeout(() => {
      console.error('üîÑ Navigating to mood.html after room error');
      cleanupParentCallPage();
    }, 2000);
    
    console.error('‚ùå ========================================\n');
    return;
  }
  
  // Handle room expiry errors
  if (data.code === 'ROOM_EXPIRED') {
    console.error('üí• ROOM EXPIRED ERROR');
    console.error('   Message:', data.message);
    console.error('   Room:', roomData?.roomId);
    console.error('   Was initiating:', wasInitiating);
    
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    
    toast('Room has expired', 'warning');
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
      }
    }
    
    // Clear all storage
    clearChatState(true);
    localStorage.removeItem(ACTIVE_CALL_KEY);
    sessionStorage.removeItem('hasBackgroundCall');
    sessionStorage.removeItem('returningFromCall');
    sessionStorage.removeItem('backgroundCallMode');
    sessionStorage.removeItem('returningToBackgroundCall');
    
    console.error('üóëÔ∏è Cleared all storage due to room expiry');
    
    setTimeout(() => {
      console.error('üîÑ Navigating to mood.html after room expiry');
      cleanupParentCallPage();
    }, 2000);
    
    console.error('‚ùå ========================================\n');
    return;
  }
  
  // Handle call-related errors
  if (data.code === 'CALL_NOT_FOUND' || data.code === 'CALL_ENDED') {
    console.error('‚ùå CALL ERROR:', data.code);
    console.error('   Message:', data.message);
    console.error('   Was initiating:', wasInitiating);
    
    // Clear loading states
    if (audioCallBtn) {
      audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = audioCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete audioCallBtn.dataset.timeoutId;
      }
    }
    if (videoCallBtn) {
      videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
      const timeoutId = videoCallBtn.dataset.timeoutId;
      if (timeoutId) {
        clearTimeout(parseInt(timeoutId));
        delete videoCallBtn.dataset.timeoutId;
      }
    }
    if (joinCallBtn) {
      joinCallBtn.classList.remove('join-btn-loading');
      joinCallBtn.disabled = false;
    }
    
    // Re-enable buttons if authenticated
    if (isSocketAuthenticated) {
      console.log('   ‚úÖ Re-enabling call buttons');
      enableCallButtons();
    }
    
    // Clear active call state
    activeCallInRoom = null;
    updateCallButtonState(false);
    
    toast(data.message || 'Call is no longer available', 'warning');
    console.error('‚ùå ========================================\n');
    return;
  }
  
  // Handle join call failures
  if (data.code === 'JOIN_FAILED' || data.code === 'PARTICIPANT_RESOLUTION_FAILED' || data.code === 'STATE_MISMATCH') {
    console.error('‚ùå JOIN CALL ERROR:', data.code);
    console.error('   Message:', data.message);
    
    // Clear join button loading state
    if (joinCallBtn) {
      joinCallBtn.classList.remove('join-btn-loading');
      joinCallBtn.disabled = false;
    }
    if (acceptCallBtn) {
      acceptCallBtn.classList.remove('join-btn-loading');
      acceptCallBtn.disabled = false;
    }
    
    toast(data.message || 'Failed to join call. Please try again.', 'error');
    console.error('‚ùå ========================================\n');
    return;
  }
  
  // Generic error handling
  console.error('‚ùå GENERIC ERROR');
  console.error('   Code:', data.code || 'UNKNOWN');
  console.error('   Message:', data.message || 'An error occurred');
  console.error('   Was initiating:', wasInitiating);
  
  // Clear any loading states on generic errors
  if (audioCallBtn) {
    audioCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
    const timeoutId = audioCallBtn.dataset.timeoutId;
    if (timeoutId) {
      clearTimeout(parseInt(timeoutId));
      delete audioCallBtn.dataset.timeoutId;
    }
  }
  if (videoCallBtn) {
    videoCallBtn.classList.remove('call-btn-loading', 'calling', 'animate-pulse');
    const timeoutId = videoCallBtn.dataset.timeoutId;
    if (timeoutId) {
      clearTimeout(parseInt(timeoutId));
      delete videoCallBtn.dataset.timeoutId;
    }
  }
  if (joinCallBtn) {
    joinCallBtn.classList.remove('join-btn-loading');
    joinCallBtn.disabled = false;
  }
  
  // Re-enable buttons if authenticated
  if (isSocketAuthenticated) {
    console.log('   ‚úÖ Re-enabling call buttons');
    enableCallButtons();
  } else {
    console.log('   ‚è≥ Not authenticated - buttons will enable after auth completes');
  }
  
  toast(data.message || 'An error occurred', 'error');
  console.error('‚ùå ========================================\n');
});

   socketInstance.on('chat_message', async (data) => {
  console.log('üí¨ ========================================');
  console.log('üí¨ INCOMING CHAT MESSAGE FROM SERVER');
  console.log('üí¨ ========================================');
  console.log(`   From: ${data.username} (${data.userId})`);
  console.log(`   MessageID: ${data.messageId}`);
  console.log(`   Has attachment: ${!!data.attachment}`);
  console.log(`   Attachment chunked: ${data.attachment?.chunked || false}`);
  
  const isOwnMessage = data.userId === currentUser.userId;
  console.log(`   Is own message: ${isOwnMessage}`);
  
  // ============================================
  // DEDUPLICATION - Check server messages only
  // ============================================
  if (isOwnMessage) {
    const optimisticIndex = messagesCache.findIndex(m => 
      m._localOnly && 
      m.userId === data.userId && 
      Math.abs((m.timestamp || 0) - (data.timestamp || 0)) < 2000
    );
    
    if (optimisticIndex !== -1) {
      console.log('üîÑ Replacing optimistic message with server version');
      
      const optimisticMsg = messagesCache[optimisticIndex];
      messagesCache.splice(optimisticIndex, 1);
      
      const msgElements = messagesList?.querySelectorAll('.message-item');
      if (msgElements) {
        msgElements.forEach(el => {
          if (el.dataset.messageId === optimisticMsg.messageId) {
            el.remove();
            console.log('‚úÖ Removed optimistic message from DOM');
          }
        });
      }
    }
  }
  
  const isDuplicate = messagesCache.some(cached => {
    if (cached._localOnly) return false;
    
    if (cached.messageId && data.messageId && cached.messageId === data.messageId) {
      return true;
    }
    
    if (cached.userId === data.userId && 
        Math.abs((cached.timestamp || 0) - (data.timestamp || 0)) < 100) {
      return true;
    }
    
    return false;
  });
  
  if (isDuplicate) {
    console.warn(`‚ö†Ô∏è DUPLICATE MESSAGE DETECTED - SKIPPING`);
    console.log('üí¨ ========================================\n');
    return;
  }
  
  console.log(`‚úÖ New message validated - will render`);
  
  // ============================================
  // ATTACHMENT HANDLING - CHUNKED OR LEGACY
  // ============================================
  if (data.attachment) {
    console.log('üìé Message contains attachment');
    console.log(`   Chunked: ${data.attachment.chunked || false}`);
    
    if (data.attachment.chunked) {
      // CHUNKED: File will arrive via file_chunk events
      console.log('üì¶ Chunked attachment - file will be received separately');
      console.log(`   FileID: ${data.attachment.fileId}`);
      console.log(`   Total chunks: ${data.attachment.totalChunks}`);
      
      // Message will be rendered with placeholder
      // File will load when chunks complete
      
    } else if (data.userId !== currentUser.userId && data.attachment.data) {
      // LEGACY: Single base64 payload (for backward compatibility)
      console.log('üì¶ Legacy attachment format detected');
      
      try {
        const byteCharacters = atob(data.attachment.data);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], { type: data.attachment.type });
        
        const file = new File([blob], data.attachment.name, { type: data.attachment.type });
        const storedFileId = await storeFileToIndexedDB(file, roomData.roomId, data.messageId);
        
        data.attachment.fileId = storedFileId;
        delete data.attachment.data;
        console.log(`‚úÖ Legacy attachment stored: ${storedFileId}`);
        
      } catch (error) {
        console.error('‚ùå Failed to store legacy attachment:', error);
      }
    } else if (data.userId === currentUser.userId) {
      console.log('‚ÑπÔ∏è Own message - file already in IndexedDB');
      delete data.attachment.data;
    }
  }
  
  // ============================================
  // RENDER MESSAGE
  // ============================================
  console.log(`üé® Rendering message`);
  const msgEl = createMessageElement(data, isOwnMessage);
  
  if (messagesList) {
    messagesList.appendChild(msgEl);
    messagesList.scrollTop = messagesList.scrollHeight;
    console.log(`‚úÖ Message rendered in UI`);
  }
  
  // ============================================
  // UPDATE CACHE AND SAVE
  // ============================================
  messagesCache.push(data);
  console.log(`‚ûï Added to cache (new size: ${messagesCache.length})`);
  
  saveChatState(roomData.roomId, messagesCache);
  console.log(`üíæ Chat state saved`);
  
  console.log('üí¨ ========================================\n');
});

    socketInstance.on('user_left', (data) => {
      const msgEl = document.createElement('div');
      msgEl.className = 'text-center text-xs sm:text-sm text-gray-400 my-2';
      msgEl.textContent = `${data.username || 'A user'} left the room`;
      messagesList?.appendChild(msgEl);

      if (onlineCount && data.remainingUsers !== undefined) {
        onlineCount.textContent = `${data.remainingUsers} Online`;
      }

      if (data.remainingUsers <= 1) {
        toast('Room closing...', 'warning');
        clearChatState(true);
        setTimeout(() => window.location.href = '/mood.html', 2000);
      }
    });

socketInstance.on('left_room', (data) => {
  console.log('üëã Received left_room confirmation from server');
  toast('Left room', 'success');
  
  // CRITICAL: Don't clear storage here - already done in leave button handler
  // Just disconnect socket
  if (socketInstance) {
    socketInstance.disconnect();
  }
  
  console.log('‚úÖ Socket disconnected after leaving room');
});

socketInstance.on('incoming_call', (data) => {
  console.log('üìû ========================================');
  console.log('üìû INCOMING_CALL EVENT RECEIVED');
  console.log('üìû ========================================');
  console.log(`   Caller: ${data.callerUsername}`);
  console.log(`   Call ID: ${data.callId}`);
  console.log(`   Type: ${data.callType}`);
  
  // CRITICAL: Cache the call immediately
  const cachedCall = {
    callId: data.callId,
    callerUsername: data.callerUsername,
    callerPfp: data.callerPfp,
    callType: data.callType,
    roomId: data.roomId,
    timestamp: Date.now()
  };
  
  try {
    localStorage.setItem(CACHED_CALL_KEY, JSON.stringify(cachedCall));
    console.log('üíæ Call cached to localStorage');
  } catch (e) {
    console.error('‚ùå Failed to cache call:', e);
  }

  // Set pending call data
  pendingCallData = data;
  
  // Update modal UI
  const callerName = document.getElementById('callerName');
  const callType = document.getElementById('callType');
  const callerAvatar = document.getElementById('callerAvatar');
  
  if (callerName) callerName.textContent = `${data.callerUsername} is calling`;
  if (callType) callType.textContent = data.callType === 'video' ? 'Video Call' : 'Audio Call';
  if (callerAvatar) {
    callerAvatar.innerHTML = '';
    const pfp = createProfilePictureElement(data.callerPfp, data.callerUsername, 'w-full h-full');
    callerAvatar.appendChild(pfp);
  }
  
  // Show modal after 2 second delay
  setTimeout(() => {
    if (pendingCallData && pendingCallData.callId === data.callId) {
      incomingCallModal?.classList.remove('hidden');
      console.log(`‚úÖ Showing incoming call modal after 2s delay`);
    } else {
      console.log(`üìû Call already handled, skipping modal display`);
    }
  }, 2000);
  
  console.log('üìû ========================================\n');
});

    socketInstance.on('call_accepted', (data) => {
    console.log('‚úÖ Call accepted:', data);
    
    // Clear loading states
    isInitiatingCall = false;
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.classList.remove('calling');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.classList.remove('calling');
        videoCallBtn.disabled = false;
    }
    
    navigatingToCall = true;
    
    saveChatState(roomData.roomId, messagesCache);
    sessionStorage.setItem('returningFromCall', 'true');
    
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
        callId: data.callId,
        roomId: roomData.roomId,
        callType: data.callType,
        users: data.users
    }));
    
    console.log('üöÄ Navigating to call');
    window.location.href = '/call.html';
});

socketInstance.on('call_declined', (data) => {
    console.log('‚ùå Call was declined');
    
    // Clear loading states
    toast('Call was declined', 'warning');
    isInitiatingCall = false;
    if (audioCallBtn) {
        audioCallBtn.classList.remove('call-btn-loading');
        audioCallBtn.classList.remove('calling');
        audioCallBtn.disabled = false;
    }
    if (videoCallBtn) {
        videoCallBtn.classList.remove('call-btn-loading');
        videoCallBtn.classList.remove('calling');
        videoCallBtn.disabled = false;
    }
});

    socketInstance.on('call_declined', (data) => {
      toast('Call was declined', 'warning');
      isInitiatingCall = false;
      audioCallBtn?.classList.remove('calling');
      videoCallBtn?.classList.remove('calling');
    });
    
    socketInstance.on('call_state_update', (data) => {
  console.log('üìû Call state update:', data);
  
  if (data.isActive && data.participantCount > 0) {
    // CRITICAL FIX: Store call data so JOIN button can access it
    activeCallInRoom = {
      callId: data.callId,
      callType: data.callType,
      participantCount: data.participantCount
    };
    console.log(`üìû Stored active call: ${data.callId} with ${data.participantCount} participants`);
    
    updateCallButtonState(true, data);
  } else {
    // CRITICAL FIX: Clear call data when call ends
    activeCallInRoom = null;
    console.log('üìû Cleared active call - no participants');
    
    updateCallButtonState(false);
  }
});


    socketInstance.on('call_ended_notification', (data) => {
      console.log('üìû Call ended:', data.callId);
      updateCallButtonState(false);
    });

socketInstance.on('join_existing_call_success', (data) => {
  console.log('‚úÖ ========================================');
  console.log('‚úÖ JOIN_EXISTING_CALL_SUCCESS');
  console.log('‚úÖ ========================================');
  console.log(`   callId: ${data.callId}`);
  console.log(`   callType: ${data.callType}`);
  console.log(`   roomId: ${data.roomId}`);
  
  // Remove loading states
  if (joinCallBtn) {
    joinCallBtn.classList.remove('join-btn-loading');
    joinCallBtn.disabled = false;
  }
  if (acceptCallBtn) {
    acceptCallBtn.classList.remove('join-btn-loading');
    acceptCallBtn.disabled = false;
  }
  
  // Mark navigating
  navigatingToCall = true;
  
  // Save chat state (if not already saved)
  saveChatState(roomData.roomId, messagesCache);
  sessionStorage.setItem('returningFromCall', 'true');
  
  // Ensure call data is stored (should already be, but verify)
  const storedCall = localStorage.getItem(ACTIVE_CALL_KEY);
  console.log(`   Stored call data exists: ${!!storedCall}`);
  
  if (!storedCall) {
    console.warn('‚ö†Ô∏è No stored call data - storing now');
    localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
      callId: data.callId,
      roomId: data.roomId,
      callType: data.callType,
      users: []
    }));
  }
  
  console.log('üöÄ Navigating to call page in 500ms...');
  console.log('‚úÖ ========================================\n');
  
  // Navigate to call with small delay to ensure storage is written
  setTimeout(() => {
    window.location.href = '/call.html';
  }, 500);
});
  }

  // ============================================
  // EVENT LISTENERS
  // ============================================
  
  function setupEventListeners() {
    // Sidebar
    sidebarToggle?.addEventListener('click', toggleSidebar, { passive: true });
    sidebarClose?.addEventListener('click', closeSidebar, { passive: true });
    sidebarOverlay?.addEventListener('click', closeSidebar, { passive: true });
    
    // Reply
    cancelReplyBtn?.addEventListener('click', hideReplyPreview, { passive: true });
    
    
    
    
const attachmentBtn = document.querySelector('.attachment-btn');
if (attachmentBtn) {
  attachmentBtn.addEventListener('click', async () => {
    console.log('üìé ========================================');
    console.log('üìé ATTACHMENT BUTTON CLICKED');
    console.log('üìé ========================================');
    
    // Create file input dynamically (ensures fresh state)
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = Object.keys(SUPPORTED_FILE_TYPES).join(',') + ',' + 
                       Object.values(SUPPORTED_FILE_TYPES).flatMap(t => t.ext).join(',');
    fileInput.style.display = 'none';
    
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) {
        console.log('‚ÑπÔ∏è No file selected');
        console.log('üìé ========================================\n');
        return;
      }
      
      console.log(`üìÑ File selected: ${file.name}`);
      console.log(`   Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
      console.log(`   Type: ${file.type}`);
      
      // Validate file
      const validation = validateFile(file);
      if (!validation.valid) {
        toast(validation.error, 'error');
        console.log('üìé ========================================\n');
        return;
      }
      
      try {
        // Show loading indicator
        attachmentBtn.disabled = true;
        attachmentBtn.classList.add('opacity-50', 'cursor-not-allowed');
        const originalIcon = attachmentBtn.innerHTML;
        attachmentBtn.innerHTML = '<span class="material-symbols-outlined text-xl animate-spin">progress_activity</span>';
        
        // Store file to IndexedDB (disk-backed, not RAM)
        const fileId = await storeFileToIndexedDB(file, roomData.roomId, null);
        
        console.log(`‚úÖ File stored successfully: ${fileId}`);
        
        // Get file back from IndexedDB to show preview
        const storedFile = await getFileFromIndexedDB(fileId);
        if (storedFile) {
          await showAttachmentPreview(
            fileId,
            storedFile.name,
            storedFile.type,
            storedFile.size,
            storedFile.blob
          );
          toast(`File attached`, 'success');
        }
        
        // Restore button state
        attachmentBtn.disabled = false;
        attachmentBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        attachmentBtn.innerHTML = originalIcon;
        
      } catch (error) {
        console.error('‚ùå Failed to store file:', error);
        toast('Failed to attach file. Please try again.', 'error');
        
        // Restore button state
        attachmentBtn.disabled = false;
        attachmentBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        attachmentBtn.innerHTML = originalIcon;
      }
      
      console.log('üìé ========================================\n');
      
      // Clean up file input
      document.body.removeChild(fileInput);
    }, { once: true });
    
    // Trigger file picker
    document.body.appendChild(fileInput);
    fileInput.click();
    
  }, { passive: true });
}
    
    
    // Remove attachment button
const removeAttachmentBtn = document.getElementById('removeAttachment');
if (removeAttachmentBtn) {
  removeAttachmentBtn.addEventListener('click', async () => {
    console.log('üóëÔ∏è Remove attachment clicked');
    
    if (pendingAttachment) {
      try {
        // Delete from IndexedDB
        await deleteFileFromIndexedDB(pendingAttachment.fileId);
        console.log(`‚úÖ Deleted file: ${pendingAttachment.fileId}`);
        
        // Hide preview
        hideAttachmentPreview();
        
        toast('Attachment removed', 'success');
      } catch (error) {
        console.error('‚ùå Failed to remove attachment:', error);
        toast('Failed to remove attachment', 'error');
      }
    }
  }, { passive: true });
}
    
    
if (audioCallBtn) {
  audioCallBtn.addEventListener('click', async () => {
    console.log('üìû ========================================');
    console.log('üìû AUDIO CALL BUTTON CLICKED');
    console.log('üìû ========================================');
    console.log(`   Authentication state: ${isSocketAuthenticated}`);
    console.log(`   Socket connected: ${socketInstance?.connected}`);
    console.log(`   Already initiating: ${isInitiatingCall}`);
    
    // CRITICAL: Block if already initiating
    if (isInitiatingCall) {
      console.log('‚ö†Ô∏è Call already being initiated, ignoring click');
      console.log('üìû ========================================\n');
      return;
    }
    
    // CRITICAL: Wait for authentication if not ready
    if (!isSocketAuthenticated) {
      console.log('‚è≥ Not authenticated yet - waiting...');
      audioCallBtn.disabled = true;
      audioCallBtn.classList.add('animate-pulse');
      
      try {
        await waitForAuthentication();
        console.log('‚úÖ Authentication complete, proceeding with call');
      } catch (e) {
        console.error('‚ùå Authentication wait failed:', e);
        toast('Connection failed. Please refresh.', 'error');
        audioCallBtn.disabled = false;
        audioCallBtn.classList.remove('animate-pulse');
        console.log('üìû ========================================\n');
        return;
      }
    }
    
    // CRITICAL: Verify socket still connected
    if (!socketInstance || !socketInstance.connected) {
      console.error('‚ùå Socket disconnected during call initiation');
      toast('Connection lost. Please refresh.', 'error');
      console.log('üìû ========================================\n');
      return;
    }
    
    console.log('‚úÖ All checks passed - initiating audio call');
    isInitiatingCall = true;
    
    // Add loading state
    audioCallBtn.classList.add('call-btn-loading');
    audioCallBtn.disabled = true;
    if (videoCallBtn) {
      videoCallBtn.classList.add('calling');
      videoCallBtn.disabled = true;
    }
    
    socketInstance.emit('initiate_call', {
      roomId: roomData.roomId,
      callType: 'audio'
    });
    
    console.log('üì§ Audio call initiation sent to server');
    toast('Calling...', 'success');
    
    // Timeout after 30 seconds with recovery
    const timeoutId = setTimeout(() => {
      if (isInitiatingCall) {
        console.log('‚è∞ Call initiation timeout (30s)');
        isInitiatingCall = false;
        audioCallBtn.classList.remove('call-btn-loading');
        if (videoCallBtn) {
          videoCallBtn.classList.remove('calling');
        }
        
        // CRITICAL: Re-enable buttons after timeout
        if (isSocketAuthenticated) {
          enableCallButtons();
        }
        
        toast('Call timeout - no response', 'warning');
      }
    }, 30000);
    
    // Store timeout for cleanup
    audioCallBtn.dataset.timeoutId = timeoutId;
    
    console.log('üìû ========================================\n');
    
  }, { passive: true });
}

if (videoCallBtn) {
  videoCallBtn.addEventListener('click', async () => {
    console.log('üìû ========================================');
    console.log('üìû VIDEO CALL BUTTON CLICKED');
    console.log('üìû ========================================');
    console.log(`   Authentication state: ${isSocketAuthenticated}`);
    console.log(`   Socket connected: ${socketInstance?.connected}`);
    console.log(`   Already initiating: ${isInitiatingCall}`);
    
    // CRITICAL: Block if already initiating
    if (isInitiatingCall) {
      console.log('‚ö†Ô∏è Call already being initiated, ignoring click');
      console.log('üìû ========================================\n');
      return;
    }
    
    // CRITICAL: Wait for authentication if not ready
    if (!isSocketAuthenticated) {
      console.log('‚è≥ Not authenticated yet - waiting...');
      videoCallBtn.disabled = true;
      videoCallBtn.classList.add('animate-pulse');
      
      try {
        await waitForAuthentication();
        console.log('‚úÖ Authentication complete, proceeding with call');
      } catch (e) {
        console.error('‚ùå Authentication wait failed:', e);
        toast('Connection failed. Please refresh.', 'error');
        videoCallBtn.disabled = false;
        videoCallBtn.classList.remove('animate-pulse');
        console.log('üìû ========================================\n');
        return;
      }
    }
    
    // CRITICAL: Verify socket still connected
    if (!socketInstance || !socketInstance.connected) {
      console.error('‚ùå Socket disconnected during call initiation');
      toast('Connection lost. Please refresh.', 'error');
      console.log('üìû ========================================\n');
      return;
    }
    
    console.log('‚úÖ All checks passed - initiating video call');
    isInitiatingCall = true;
    
    // Add loading state
    videoCallBtn.classList.add('call-btn-loading');
    videoCallBtn.disabled = true;
    if (audioCallBtn) {
      audioCallBtn.classList.add('calling');
      audioCallBtn.disabled = true;
    }
    
    socketInstance.emit('initiate_call', {
      roomId: roomData.roomId,
      callType: 'video'
    });
    
    console.log('üì§ Video call initiation sent to server');
    toast('Calling...', 'success');
    
    // Timeout after 30 seconds with recovery
    const timeoutId = setTimeout(() => {
      if (isInitiatingCall) {
        console.log('‚è∞ Call initiation timeout (30s)');
        isInitiatingCall = false;
        videoCallBtn.classList.remove('call-btn-loading');
        if (audioCallBtn) {
          audioCallBtn.classList.remove('calling');
        }
        
        // CRITICAL: Re-enable buttons after timeout
        if (isSocketAuthenticated) {
          enableCallButtons();
        }
        
        toast('Call timeout - no response', 'warning');
      }
    }, 30000);
    
    // Store timeout for cleanup
    videoCallBtn.dataset.timeoutId = timeoutId;
    
    console.log('üìû ========================================\n');
    
  }, { passive: true });
}



if (joinCallBtn) {
    joinCallBtn.addEventListener('click', () => {
        console.log('üîò ========================================');
        console.log('üîò JOIN CALL BUTTON CLICKED');
        console.log('üîò ========================================');
        
        // Check if this is "Back to Call" or "Join Call"
        const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
        const userInCall = activeCallStr && JSON.parse(activeCallStr).roomId === roomData?.roomId;
        
        console.log(`   activeCallStr exists: ${!!activeCallStr}`);
        console.log(`   userInCall: ${userInCall}`);
        console.log(`   activeCallInRoom exists: ${!!activeCallInRoom}`);
        
        if (userInCall) {
            // User is already in call - show call UI in iframe/overlay
            console.log('üìû BACK TO CALL MODE');
            
            const activeCallData = JSON.parse(activeCallStr);
            console.log(`   callId: ${activeCallData.callId}`);
            console.log(`   Call is running in background - will hide chat overlay`);
            
            if (window.parent && window.parent !== window) {
                console.log('üì± We are in iframe - posting message to parent');
                window.parent.postMessage({ action: 'hideChat' }, '*');
            } else {
                console.log('‚ö†Ô∏è Not in iframe - navigating directly');
                window.location.href = '/call.html';
            }
            
            console.log('üîò ========================================\n');
        } else {
            // No active call - join existing call
            console.log('üìû JOIN EXISTING CALL MODE');
            
            if (!activeCallInRoom) {
                console.error('‚ùå activeCallInRoom is null/undefined!');
                console.log('   This should not happen - UI should not show Join button');
                toast('No active call to join', 'warning');
                console.log('üîò ========================================\n');
                return;
            }
            
            console.log(`   activeCallInRoom.callId: ${activeCallInRoom.callId}`);
            console.log(`   activeCallInRoom.callType: ${activeCallInRoom.callType}`);
            console.log(`   activeCallInRoom.participantCount: ${activeCallInRoom.participantCount}`);
            console.log(`   roomData.roomId: ${roomData.roomId}`);
            
            // Add loading state
            joinCallBtn.classList.add('join-btn-loading');
            joinCallBtn.disabled = true;
            console.log('‚è≥ Join button set to loading state');
            
            // CRITICAL FIX: Store call data BEFORE emitting join_existing_call
            const callDataToStore = {
                callId: activeCallInRoom.callId,
                roomId: roomData.roomId,
                callType: activeCallInRoom.callType,
                users: []
            };
            
            localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify(callDataToStore));
            console.log('üíæ Stored call data to localStorage (pre-join):');
            console.log('   ', JSON.stringify(callDataToStore, null, 2));
            
            const eventData = {
                callId: activeCallInRoom.callId,
                roomId: roomData.roomId
            };
            
            console.log('üì§ Emitting join_existing_call with data:');
            console.log('   ', JSON.stringify(eventData, null, 2));
            
            if (!socketInstance || !socketInstance.connected) {
                console.error('‚ùå Socket not connected!');
                toast('Connection lost. Please refresh the page.', 'error');
                joinCallBtn.classList.remove('join-btn-loading');
                joinCallBtn.disabled = false;
                console.log('üîò ========================================\n');
                return;
            }
            
            socketInstance.emit('join_existing_call', eventData);
            
            toast('Joining call...', 'success');
            console.log('‚úÖ Event emitted successfully');
            console.log('üîò ========================================\n');
        }
    }, { passive: true });
}

if (acceptCallBtn) {
  acceptCallBtn.addEventListener('click', () => {
    if (pendingCallData) {
      const callToAccept = pendingCallData;
      pendingCallData = null;
      
      console.log('‚úÖ ========================================');
      console.log('‚úÖ USER ACCEPTED INCOMING CALL');
      console.log('‚úÖ ========================================');
      console.log(`   callId: ${callToAccept.callId}`);
      
      // Clear cached call
      localStorage.removeItem(CACHED_CALL_KEY);
      
      // Hide modal
      incomingCallModal?.classList.add('hidden');
      
      // Mark navigating
      navigatingToCall = true;
      
      // Add loading state
      acceptCallBtn.classList.add('join-btn-loading');
      acceptCallBtn.disabled = true;
      
      // Save chat state
      saveChatState(roomData.roomId, messagesCache);
      sessionStorage.setItem('returningFromCall', 'true');
      
      // CRITICAL FIX: Store call data BEFORE emitting join_existing_call
      localStorage.setItem(ACTIVE_CALL_KEY, JSON.stringify({
        callId: callToAccept.callId,
        roomId: roomData.roomId,
        callType: callToAccept.callType,
        users: []
      }));
      console.log('üíæ Stored call data to localStorage (pre-join)');
      
      console.log('üì§ Emitting join_existing_call to server');
      
      // Use join_existing_call to ensure server adds us to participants list first
      socketInstance?.emit('join_existing_call', {
        callId: callToAccept.callId,
        roomId: roomData.roomId
      });
      
      console.log('‚úÖ Join request sent - will navigate on success');
      console.log('‚úÖ ========================================\n');
      
      // Don't navigate here - wait for join_existing_call_success event
    }
  }, { passive: true });
}

if (declineCallBtn) {
  declineCallBtn.addEventListener('click', () => {
    if (pendingCallData) {
      const callToDecline = pendingCallData;
      pendingCallData = null;
      
      console.log('‚ùå ========================================');
      console.log('‚ùå USER DECLINED INCOMING CALL');
      console.log('‚ùå ========================================');
      console.log(`   callId: ${callToDecline.callId}`);
      console.log(`   Call remains active - user can still join via JOIN button`);
      
      // Clear cached call
      localStorage.removeItem(CACHED_CALL_KEY);
      console.log('üóëÔ∏è Cleared cached call after decline');
      
      // Hide modal
      incomingCallModal?.classList.add('hidden');
      
      console.log('‚úÖ Modal dismissed - call still active in room');
      console.log('‚ùå ========================================\n');
    }
  }, { passive: true });
}

if (messageForm) {
  messageForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const message = messageInput?.value.trim();
    
    // Allow sending if there's a message OR an attachment
    if (!message && !pendingAttachment) {
      console.log('‚ö†Ô∏è No message or attachment to send');
      return;
    }

    console.log('üì§ ========================================');
    console.log('üì§ SENDING MESSAGE TO SERVER');
    console.log('üì§ ========================================');
    console.log(`   Message: ${message || '[attachment only]'}`);
    console.log(`   Has attachment: ${!!pendingAttachment}`);

    // ============================================
    // PREPARE SERVER MESSAGE DATA
    // ============================================
    const serverMessageData = {
      roomId: roomData.roomId,
      message: message || ''
    };

    // Add reply data for server
    if (replyingTo) {
      serverMessageData.replyTo = {
        messageId: replyingTo.messageId,
        username: replyingTo.username,
        message: replyingTo.message,
        userId: replyingTo.userId
      };
      hideReplyPreview();
    }

    // ============================================
    // HANDLE ATTACHMENT - CHUNKED TRANSMISSION
    // ============================================
    if (pendingAttachment) {
      try {
        console.log('üìé ========================================');
        console.log('üìé PREPARING CHUNKED ATTACHMENT TRANSMISSION');
        console.log('üìé ========================================');
        console.log(`   FileID: ${pendingAttachment.fileId}`);
        console.log(`   File: ${pendingAttachment.name}`);
        console.log(`   Size: ${(pendingAttachment.size / 1024 / 1024).toFixed(2)} MB`);
        
        // Show upload progress UI
        const progressDiv = document.createElement('div');
        progressDiv.id = 'uploadProgress';
        progressDiv.className = 'fixed top-4 right-4 bg-[#161b22] border border-[#30363d] rounded-lg px-4 py-3 shadow-lg z-50';
        progressDiv.innerHTML = `
          <div class="flex items-center gap-3">
            <div class="animate-spin">
              <span class="material-symbols-outlined text-[#06b6d4]">progress_activity</span>
            </div>
            <div>
              <div class="text-sm font-semibold text-gray-200">${pendingAttachment.name}</div>
              <div id="uploadProgressText" class="text-xs text-gray-400">Preparing...</div>
            </div>
          </div>
        `;
        document.body.appendChild(progressDiv);
        
        // Get file from IndexedDB
        const fileData = await getFileFromIndexedDB(pendingAttachment.fileId);
        
        if (!fileData || !fileData.blob) {
          throw new Error('Failed to retrieve file from storage');
        }
        
        console.log(`‚úÖ File retrieved from IndexedDB`);
        
        // Create File object from blob
        const file = new File([fileData.blob], fileData.name, { type: fileData.type });
        
        // Chunk the file
        const progressText = document.getElementById('uploadProgressText');
        if (progressText) progressText.textContent = 'Chunking...';
        
        const chunks = await chunkFile(file);
        
        console.log(`‚úÖ File chunked into ${chunks.length} pieces`);
        
        // Add attachment metadata (no data - will be sent separately)
        serverMessageData.attachment = {
          fileId: pendingAttachment.fileId,
          name: pendingAttachment.name,
          type: pendingAttachment.type,
          size: pendingAttachment.size,
          chunked: true, // Signal that chunks will follow
          totalChunks: chunks.length
        };
        
        // Send message metadata first (creates message in UI)
        console.log('üì§ Emitting message metadata to server...');
        socketInstance.emit('chat_message', serverMessageData);
        
        // Then send file chunks
        if (progressText) progressText.textContent = 'Uploading: 0%';
        
        await sendFileInChunks(
          pendingAttachment.fileId,
          pendingAttachment.name,
          pendingAttachment.type,
          pendingAttachment.size,
          chunks,
          roomData.roomId
        );
        
        console.log('‚úÖ File transmission complete');
        
        // Remove progress UI
        progressDiv.remove();
        
        toast(`File uploaded: ${pendingAttachment.name}`, 'success');
        
        console.log('üìé ========================================\n');
        
      } catch (error) {
        console.error('‚ùå Attachment transmission failed:', error);
        
        // Remove progress UI
        const progressDiv = document.getElementById('uploadProgress');
        if (progressDiv) progressDiv.remove();
        
        toast('Failed to send attachment. Please try again.', 'error');
        console.log('üìé ========================================\n');
        return; // Don't clear input on failure
      }
    } else {
      // No attachment - send message normally
      console.log('üì§ Emitting text-only message...');
      socketInstance.emit('chat_message', serverMessageData);
      console.log('‚úÖ Message sent to server');
    }

    console.log('üì§ ========================================\n');

    // ============================================
    // CLEAR INPUT AND ATTACHMENTS
    // ============================================
    if (messageInput) messageInput.value = '';
    
    if (pendingAttachment) {
      hideAttachmentPreview();
    }
  });
}

leaveBtn?.addEventListener('click', async () => {
  console.log('üö™ Leave button clicked - starting cleanup sequence');
  stopCachedCallMonitoring();
  
  // CRITICAL: Check if there's a background call running
  const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
  
  if (activeCallStr) {
    console.log('üìû Active call detected - cleaning up before leaving');
    
    try {
      const callData = JSON.parse(activeCallStr);
      
      // 1. Emit leave_call to server
      if (socketInstance && socketInstance.connected) {
        console.log('üì§ Emitting leave_call to server...');
        socketInstance.emit('leave_call', { callId: callData.callId });
        
        // Wait for server to process the leave_call
        await new Promise(resolve => setTimeout(resolve, 500));
        console.log('‚úÖ Leave_call processed');
      }
      
      // 2. Clear all call-related storage
      localStorage.removeItem(ACTIVE_CALL_KEY);
      sessionStorage.removeItem('hasBackgroundCall');
      sessionStorage.removeItem('returningFromCall');
      sessionStorage.removeItem('backgroundCallMode');
      sessionStorage.removeItem('returningToBackgroundCall');
      
      console.log('‚úÖ All call data cleared');
      
    } catch (e) {
      console.error('‚ùå Error during call cleanup:', e);
    }
  }
  
  // 3. Leave the chat room
  if (socketInstance && socketInstance.connected) {
    console.log('üì§ Emitting leave_room...');
    socketInstance.emit('leave_room');
    
    // Wait for server to process
    await new Promise(resolve => setTimeout(resolve, 300));
  }
  
  // 4. Clear chat state
  clearChatState(true);
  
  // 5. Navigate - this will handle both iframe and standalone cases
  console.log('‚úÖ Cleanup complete - initiating navigation');
  cleanupParentCallPage();
});

    // Visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        console.log('üì± Page hidden');
        saveChatState(roomData.roomId, messagesCache);
      } else {
        console.log('üì± Page visible');
      }
    });

window.addEventListener('beforeunload', (e) => {
  console.log('üö™ Chat page beforeunload event');
  stopCachedCallMonitoring();
  
  
    console.log('üßπ Cleaning up blob URLs...');
  const images = document.querySelectorAll('img[data-blob-url]');
  images.forEach(img => {
    const blobUrl = img.dataset.blobUrl;
    if (blobUrl) {
      URL.revokeObjectURL(blobUrl);
    }
  });
  console.log(`‚úÖ Revoked ${images.length} blob URL(s)`);
  
  // CRITICAL: Check if in background call mode
  if (isInBackgroundCall) {
    console.log('üîí Background call active - preserving floating socket');
    saveChatState(roomData.roomId, messagesCache);
    
    // Don't disconnect floating socket - let it persist
    if (floatingCallSocket) {
      console.log('‚úÖ Keeping floating call socket alive');
    }
    
    // Only disconnect main chat socket
    if (socketInstance) {
      socketInstance.emit('leave_room');
      socketInstance.disconnect();
    }
    
    return;
  }
  
  if (navigatingToCall) {
    console.log('üîí Navigating to call - keeping socket');
    saveChatState(roomData.roomId, messagesCache);
    return;
  }
  
  console.log('üóëÔ∏è Normal chat exit - cleanup already done in leave handler');
  
  // Only disconnect sockets - cleanup was already done by leave button handlers
  if (socketInstance) {
    socketInstance.disconnect();
  }
  if (timerInterval) clearInterval(timerInterval);
});
  }

  // ============================================
  // INITIALIZATION
  // ============================================
  
  
  try {
  await initFileDB();
  console.log('‚úÖ File storage initialized');
  
  // Clean up any orphaned files from previous sessions
  if (roomData?.roomId) {
    const fileCount = await getRoomFileCount(roomData.roomId);
    if (fileCount > 0) {
      console.log(`‚ÑπÔ∏è Found ${fileCount} existing file(s) for this room`);
    }
  }
} catch (error) {
  console.error('‚ö†Ô∏è File storage initialization failed:', error);
  console.error('   File attachments will be disabled');
  // Disable attachment button if IndexedDB fails
  const attachBtn = document.querySelector('.attachment-btn');
  if (attachBtn) {
    attachBtn.disabled = true;
    attachBtn.classList.add('opacity-50', 'cursor-not-allowed');
    attachBtn.title = 'File attachments unavailable';
  }
}
  
try {
    // Check if we're returning from a call OR if we're in an iframe (chat overlay)
    const returningFromCall = sessionStorage.getItem('returningFromCall') === 'true';
    const isBackgroundCall = sessionStorage.getItem('backgroundCallMode') === 'true';
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    const isInIframe = window.parent && window.parent !== window;
    
    // CRITICAL: If there's an active call in this room, we're likely returning from it
    let shouldPreserveState = returningFromCall || isBackgroundCall;
    
    if (!shouldPreserveState && activeCallStr && isInIframe) {
        try {
            const activeCall = JSON.parse(activeCallStr);
            const roomStr = localStorage.getItem('currentRoom');
            if (roomStr) {
                const room = JSON.parse(roomStr);
                if (activeCall.roomId === room.roomId) {
                    console.log('üîç Active call detected in iframe - treating as return from call');
                    shouldPreserveState = true;
                }
            }
        } catch (e) {
            console.warn('Failed to parse call/room data:', e);
        }
    }

    
    console.log('üîç Page load context:', { 
        returningFromCall, 
        isBackgroundCall, 
        isInIframe,
        shouldPreserveState,
        hasActiveCall: !!activeCallStr
    });
    
    if (!shouldPreserveState) {
        // Only clear if this is a fresh entry to chat (not returning from call)
        console.log('üßπ Fresh chat entry - clearing old state');
        clearAllChatData();
    } else {
        console.log('üîÑ Returning from call - preserving chat state');
        // Don't clear - we want to restore the previous state
    }
    
    // Auth check
    await _Auth.requireAuth();
  } catch (err) {
    console.error('‚ùå Auth failed:', err);
    window.location.href = '/login.html';
    return;
  }
  
  
// CRITICAL: Initialize floating call popup elements early
console.log('üéà Pre-initializing floating call popup');

// Check if returning from call
const returningFromCall = sessionStorage.getItem('returningFromCall');
if (returningFromCall === 'true') {
  console.log('üîÑ Returning from call - popup will be shown after room_joined');
  console.log('üîç Active call check:', !!localStorage.getItem(ACTIVE_CALL_KEY));
}

  const roomDataStr = localStorage.getItem('currentRoom');
  if (!roomDataStr) {
    console.error('‚ùå No currentRoom in localStorage');
    toast('No active room found', 'error');
    setTimeout(() => window.location.href = '/mood.html', 1500);
    return;
  }

  try {
    roomData = JSON.parse(roomDataStr);
    console.log('üì¶ Loaded room data from localStorage:');
    console.log(`   roomId: ${roomData.roomId}`);
    
    // CRITICAL: Don't trust localStorage expiresAt - wait for server
    if (roomData.expiresAt) {
      console.log(`   LocalStorage expiresAt: ${new Date(roomData.expiresAt).toISOString()}`);
      console.log(`   ‚ö†Ô∏è Will be replaced with server time after connection`);
    } else {
      console.log(`   No expiresAt in localStorage - will get from server`);
    }
    
    if (!roomData.roomId) {
      throw new Error('Invalid room data: missing roomId');
    }
    checkForBackgroundCall();
  } catch (err) {
    console.error('‚ùå Invalid room data:', err);
    toast('Invalid room data', 'error');
    clearChatState(true);
    setTimeout(() => window.location.href = '/mood.html', 1500);
    return;
  }

  // Get Firebase user
  const firebaseUser = firebase.auth().currentUser;
  if (!firebaseUser) {
    window.location.href = '/login.html';
    return;
  }

  // Get current user data
  try {
    const userData = await _API.get('/api/users/me');
    currentUser = {
      userId: userData._id,
      username: userData.username,
      pfpUrl: userData.pfpUrl
    };
  } catch (err) {
    console.error('‚ùå Failed to get user data:', err);
    toast('Failed to load user data', 'error');
    setTimeout(() => window.location.href = '/login.html', 1500);
    return;
  }

  
// CRITICAL: Start with buttons DISABLED until authenticated
console.log('üéöÔ∏è Initializing call buttons (disabled until authenticated)');
disableCallButtons(false); // false = don't show loading, just disabled

const cachedState = loadChatState();

if (cachedState && cachedState.roomId === roomData.roomId) {
  console.log('üé® Restoring UI from cache IMMEDIATELY on page load');
  console.log(`   Cached button state: ${cachedState.callButtonState}`);
  console.log(`   Cached activeCallInRoom:`, cachedState.activeCallInRoom);
  
  // Restore activeCallInRoom immediately
  if (cachedState.activeCallInRoom) {
    activeCallInRoom = cachedState.activeCallInRoom;
    console.log('üíæ Pre-loaded activeCallInRoom from cache');
  } else if (cachedState.callButtonState === 'back') {
    // Reconstruct from ACTIVE_CALL_KEY
    const activeCallStr = localStorage.getItem(ACTIVE_CALL_KEY);
    if (activeCallStr) {
      try {
        const activeCallData = JSON.parse(activeCallStr);
        activeCallInRoom = {
          callId: activeCallData.callId,
          callType: activeCallData.callType,
          participantCount: 2
        };
        console.log('üíæ Pre-loaded activeCallInRoom from ACTIVE_CALL_KEY');
      } catch (e) {
        console.error('Failed to reconstruct activeCallInRoom:', e);
      }
    }
  }
  
  // Set button state immediately from cache (but keep disabled until auth)
  if (cachedState.callButtonState === 'back') {
    updateCallButtonState(true, activeCallInRoom || { participantCount: 1 });
    console.log('‚úÖ "Back to Call" button shown immediately from cache (disabled until auth)');
  } else if (cachedState.callButtonState === 'join' && activeCallInRoom) {
    updateCallButtonState(true, activeCallInRoom);
    console.log('‚úÖ "Join Call" button shown immediately from cache (disabled until auth)');
  } else {
    setInitialCallButtonState();
  }
} else {
  // No cache - use normal initial state (disabled)
  setInitialCallButtonState();
}
  // Render initial users
  if (usersList && Array.isArray(roomData.users)) {
    roomData.users.forEach(user => {
      const userCard = document.createElement('div');
      userCard.className = 'user-card flex items-center gap-2 sm:gap-3 p-2 sm:p-3 rounded-lg hover:bg-gray-50 transition-all cursor-pointer';
      
      const pfpElement = createProfilePictureElement(user.pfpUrl, user.username, 'w-10 h-10 sm:w-12 sm:h-12');
      
      const userInfo = document.createElement('div');
      userInfo.className = 'flex-1 min-w-0';
      
      const nameSpan = document.createElement('div');
      nameSpan.className = 'text-sm font-semibold truncate';
      nameSpan.textContent = user.username || 'User';
      
      const statusSpan = document.createElement('div');
      statusSpan.className = 'text-xs text-gray-500 flex items-center gap-1';
      statusSpan.innerHTML = '<span class="flex h-2 w-2 rounded-full bg-green-500 flex-shrink-0"></span> Online';
      
      userInfo.appendChild(nameSpan);
      userInfo.appendChild(statusSpan);
      
      userCard.appendChild(pfpElement);
      userCard.appendChild(userInfo);
      usersList.appendChild(userCard);
    });

    setupUserCardClick();

    if (onlineCount) {
      onlineCount.textContent = `${roomData.users.length} Online`;
    }
  }

  console.log('‚è∞ Starting timer interval (will update when server data arrives)');
  // Start timer interval (will show "--" until server data arrives)
  timerInterval = setInterval(updateTimer, 1000);
  updateTimer();

  // Initialize socket
  try {
    const idToken = await firebaseUser.getIdToken();
    const socketUrl = window.location.origin;
    
    socketInstance = io(socketUrl, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 500,
      reconnectionAttempts: 10,
      auth: { token: idToken },
      timeout: 10000
    });

    setupSocketHandlers();
  } catch (err) {
    console.error('‚ùå Socket initialization failed:', err);
    toast('Connection failed', 'error');
  }

  // Setup all event listeners
  setupEventListeners();

  // Setup back button handler
  setupBackButtonHandler();

  console.log('‚úÖ Chat initialization complete');

})();
</script>
</body>
</html>
