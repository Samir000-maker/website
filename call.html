<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Active Call - MoodLog</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#33bfcc",
                        "background-light": "#f2f2f3",
                        "background-dark": "#121417",
                        "surface-dark": "#1e2124",
                        "accent-red": "#ef4444",
                    },
                    fontFamily: {
                        "display": ["Manrope", "sans-serif"]
                    }
                },
            },
        }
    </script>
    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }
        
        .active-speaker {
            box-shadow: 0 0 0 3px #33bfcc, 0 0 15px rgba(51, 191, 204, 0.4) !important;
            border-color: #33bfcc !important;
        }
        
        body {
            font-family: 'Manrope', sans-serif;
            overscroll-behavior: none;
        }
        
        .video-tile {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            max-width: 400px;
            background: #000;
            overflow: hidden;
            border-radius: 1rem;
        }
        
        .video-container {
            position: absolute;
            inset: 0;
        }
        
        video {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .pfp-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        
        .participant-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 400px));
            justify-content: center;
            gap: 1rem;
            width: 100%;
            padding: 1rem;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        @media (min-width: 1024px) {
            .participant-grid {
                grid-template-columns: repeat(auto-fit, minmax(300px, 400px));
            }
        }
        
        @media (max-width: 640px) {
            .participant-grid {
                grid-template-columns: 1fr;
                padding: 0.75rem;
            }
            .video-tile {
                max-width: 100%;
            }
        }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-900 dark:text-white min-h-screen flex flex-col font-display">
    <header class="w-full border-b border-slate-200 dark:border-slate-800 px-4 sm:px-6 py-3 sm:py-4 flex items-center justify-between bg-background-light dark:bg-background-dark z-10">
        <div class="flex items-center gap-3 sm:gap-4 flex-1 min-w-0">
            <div class="bg-primary/20 p-1.5 sm:p-2 rounded-lg flex-shrink-0">
                <span class="material-symbols-outlined text-primary text-lg sm:text-2xl" id="callIcon">videocam</span>
            </div>
            <div class="min-w-0">
                <h1 class="text-sm sm:text-lg font-bold tracking-tight truncate" id="callTitle">Video Call</h1>
                <p class="text-[10px] sm:text-xs text-slate-500 dark:text-slate-400 truncate" id="callSubtitle">Connecting...</p>
            </div>
        </div>
        <div class="flex items-center gap-2 sm:gap-3 flex-shrink-0">
            <div class="flex items-center gap-1.5 sm:gap-2 bg-slate-200 dark:bg-surface-dark px-2 sm:px-4 py-1.5 sm:py-2 rounded-lg sm:rounded-xl border border-slate-300 dark:border-slate-700">
                <span class="relative flex h-2 w-2">
                    <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-primary opacity-75"></span>
                    <span class="relative inline-flex rounded-full h-2 w-2 bg-primary"></span>
                </span>
                <span class="text-[10px] sm:text-sm font-bold font-mono" id="callDuration">00:00:00</span>
            </div>
        </div>
    </header>

    <main class="flex-1 overflow-y-auto">
        <div id="participantGrid" class="participant-grid"></div>
    </main>

    <footer class="w-full px-3 sm:px-6 py-3 sm:py-4 flex justify-center sticky bottom-0 z-20">
        <div class="bg-white/95 dark:bg-surface-dark/95 backdrop-blur-lg shadow-2xl rounded-xl sm:rounded-2xl border border-slate-200 dark:border-slate-800 p-2 sm:p-2.5 flex items-center gap-1 sm:gap-2">
            <div class="flex items-center gap-1 sm:gap-2 px-1 sm:px-2 border-r border-slate-200 dark:border-slate-800">
                <button id="micBtn" class="w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-primary text-white hover:brightness-110 transition-all active:scale-95">
                    <span class="material-symbols-outlined text-lg sm:text-2xl">mic</span>
                </button>
                <button id="videoBtn" class="w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-slate-200 dark:bg-background-dark text-slate-700 dark:text-white hover:bg-slate-300 dark:hover:bg-slate-800 transition-all">
                    <span class="material-symbols-outlined text-lg sm:text-2xl">videocam_off</span>
                </button>
            </div>
            
            <div class="hidden sm:flex items-center gap-2 px-2">
                <button id="moodBtn" class="flex items-center gap-1.5 sm:gap-2 px-3 sm:px-4 h-10 sm:h-12 rounded-lg sm:rounded-xl bg-slate-100 dark:bg-background-dark text-slate-700 dark:text-white border border-slate-200 dark:border-slate-700 hover:border-primary transition-all text-xs sm:text-sm">
                    <span class="text-base sm:text-xl">üòä</span>
                    <span class="font-bold hidden md:inline">Update Mood</span>
                </button>
            </div>
            
            <div class="pl-1 sm:pl-2 border-l border-slate-200 dark:border-slate-800">
                <button id="leaveCallBtn" class="flex items-center gap-1.5 sm:gap-2 px-4 sm:px-6 h-10 sm:h-12 rounded-lg sm:rounded-xl bg-accent-red text-white hover:brightness-110 transition-all active:scale-95">
                    <span class="material-symbols-outlined font-bold text-lg sm:text-2xl">call_end</span>
                    <span class="font-bold text-xs sm:text-sm">Leave</span>
                </button>
            </div>
        </div>
    </footer>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };
      if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="app.js"></script>



    <script>
    (async () => {
      const MoodApp = window.MoodApp || {};
      const _Auth = MoodApp.Auth;
      const _API = MoodApp.API;
      const _Toast = MoodApp.Toast;
      const toast = (m, t='success') => { 
        if (_Toast && typeof _Toast[t] === 'function') return _Toast[t](m); 
        console[t==='error'?'error':'log'](m); 
      };

      let ICE_SERVERS = null;
      async function fetchIceServers() {
        try {
          const response = await _API.get('/api/ice-servers');
          ICE_SERVERS = response.iceServers;
          console.log(`‚úÖ ICE servers loaded`);
          return ICE_SERVERS;
        } catch (error) {
          console.error('‚ùå ICE servers failed:', error);
          ICE_SERVERS = [{ urls: ['stun:stun.cloudflare.com:3478', 'stun:stun.l.google.com:19302'] }];
          return ICE_SERVERS;
        }
      }

      const PEER_CONNECTION_CONFIG = { iceCandidatePoolSize: 10, iceTransportPolicy: 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' };
      let localStream = null, peerConnections = new Map(), audioContexts = new Map(), socketInstance = null;
      let callData = null, currentUser = null, isAudioEnabled = true, isVideoEnabled = false;
      let callStartTime = null, durationInterval = null, isInitializing = false, hasJoinedCall = false;
      let pendingIceCandidates = new Map(), connectionStats = new Map();
      let renderedParticipants = new Set(); // CRITICAL FIX: Track rendered participants

      function createProfilePicture(pfpUrl, username) {
        const initial = username ? username.charAt(0).toUpperCase() : 'U';
        const div = document.createElement('div');
        div.className = 'w-16 h-16 sm:w-20 sm:h-20 rounded-full overflow-hidden bg-slate-100 dark:bg-slate-800 border-2 border-primary/30';
        if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
          const img = document.createElement('img');
          img.src = pfpUrl;
          img.alt = username;
          img.className = 'w-full h-full object-cover';
          img.onerror = () => { div.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-xl sm:text-2xl">${initial}</div>`; };
          div.appendChild(img);
        } else {
          div.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-xl sm:text-2xl">${initial}</div>`;
        }
        return div;
      }

      function createParticipantTile(user, isSelf = false) {
  console.log(`üé® Creating tile for ${user.username} (userId: ${user.userId}, isSelf: ${isSelf})`);
  
  // CRITICAL: Check if tile already exists in DOM
  const existingTile = document.getElementById(`participant-${user.userId}`);
  if (existingTile) {
    console.warn(`‚ö†Ô∏è Tile for ${user.userId} already exists in DOM! Removing old tile.`);
    existingTile.remove();
    renderedParticipants.delete(user.userId);
  }
  
  // Double-check tracking set
  if (renderedParticipants.has(user.userId)) {
    console.warn(`‚ö†Ô∏è Tile for ${user.userId} in tracking set but not in DOM! Clearing.`);
    renderedParticipants.delete(user.userId);
  }
  
  const tile = document.createElement('div');
  tile.id = `participant-${user.userId}`;
  tile.className = `video-tile ${isSelf ? 'border-2 border-dashed border-primary/30' : 'border border-white/5'}`;
  
  const videoContainer = document.createElement('div');
  videoContainer.className = 'video-container';
  
  const video = document.createElement('video');
  video.id = `video-${user.userId}`;
  video.className = 'hidden';
  video.autoplay = true;
  video.playsInline = true;
  video.setAttribute('playsinline', '');
  video.setAttribute('webkit-playsinline', '');
  
  if (isSelf) {
    video.muted = true;
    video.volume = 0;
    console.log(`üîá Self video will be muted (userId: ${user.userId})`);
  } else {
    video.muted = false;
    video.volume = 1.0;
    console.log(`üîä Remote video will NOT be muted (userId: ${user.userId})`);
  }
  
  videoContainer.appendChild(video);
  
  const pfpOverlay = document.createElement('div');
  pfpOverlay.id = `pfp-${user.userId}`;
  pfpOverlay.className = 'pfp-overlay';
  pfpOverlay.appendChild(createProfilePicture(user.pfpUrl, user.username));
  videoContainer.appendChild(pfpOverlay);
  
  tile.appendChild(videoContainer);
  
  const label = document.createElement('div');
  label.className = 'absolute bottom-3 sm:bottom-4 left-3 sm:left-4 z-10';
  label.innerHTML = `<div class="${isSelf ? 'bg-primary/80' : 'bg-black/60'} backdrop-blur-md px-2 sm:px-3 py-1 sm:py-1.5 rounded-full border ${isSelf ? 'border-primary/20' : 'border-white/10'} flex items-center gap-1.5 sm:gap-2">
    <span class="text-white text-xs sm:text-sm font-semibold">${isSelf ? 'You' : user.username}</span>
    <span class="text-base sm:text-lg">üòä</span>
  </div>`;
  tile.appendChild(label);
  
  const speaking = document.createElement('div');
  speaking.id = `speaking-${user.userId}`;
  speaking.className = 'absolute top-3 sm:top-4 right-3 sm:right-4 bg-primary px-1.5 sm:px-2 py-0.5 rounded text-[9px] sm:text-[10px] font-bold text-white uppercase hidden z-10';
  speaking.textContent = 'SPEAKING';
  tile.appendChild(speaking);
  
  const micOff = document.createElement('div');
  micOff.id = `mic-${user.userId}`;
  micOff.className = 'absolute top-3 sm:top-4 right-3 sm:right-4 bg-accent-red p-1 sm:p-1.5 rounded-full text-white shadow-lg hidden z-10';
  micOff.innerHTML = '<span class="material-symbols-outlined text-[14px] sm:text-[16px]">mic_off</span>';
  tile.appendChild(micOff);
  
  if (isSelf) {
    const overlay = document.createElement('div');
    overlay.className = 'absolute inset-0 bg-primary/5 pointer-events-none';
    tile.appendChild(overlay);
  }
  
  renderedParticipants.add(user.userId);
  console.log(`‚úÖ Tile created for ${user.username} (${user.userId})`);
  console.log(`üìä Rendered participants now:`, Array.from(renderedParticipants));
  return tile;
}

      function setupAudioDetection(userId, stream) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          const analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          source.connect(analyser);
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          let isSpeaking = false, lastSpeakTime = 0;
          
          function detect() {
            const speaking = document.getElementById(`speaking-${userId}`);
            const tile = document.getElementById(`participant-${userId}`);
            if (!speaking || !tile) { audioContext.close(); return; }
            
            analyser.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a,b)=>a+b) / dataArray.length;
            const now = Date.now();
            
            if (avg > 30) {
              if (!isSpeaking) {
                isSpeaking = true;
                speaking.classList.remove('hidden');
                tile.classList.add('active-speaker');
                if (socketInstance && userId === currentUser.userId) {
                  socketInstance.emit('speaking_state', { callId: callData.callId, speaking: true });
                }
              }
              lastSpeakTime = now;
            } else if (isSpeaking && now - lastSpeakTime > 300) {
              isSpeaking = false;
              speaking.classList.add('hidden');
              tile.classList.remove('active-speaker');
              if (socketInstance && userId === currentUser.userId) {
                socketInstance.emit('speaking_state', { callId: callData.callId, speaking: false });
              }
            }
            requestAnimationFrame(detect);
          }
          detect();
          audioContexts.set(userId, audioContext);
        } catch (e) { console.error('Audio detection error:', e); }
      }

      async function initLocalMedia() {
  try {
    console.log(`üé• Requesting media (${callData.callType})...`);
    const constraints = {
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
      video: callData.callType === 'video' ? { 
        width: {ideal:640}, 
        height: {ideal:480},
        facingMode: 'user'
      } : false
    };
    
    let mediaAttempt = 1;
    let hasVideo = false;
    let hasAudio = false;
    
    // ATTEMPT 1: Try full constraints
    try {
      console.log(`üé¨ [Attempt ${mediaAttempt}] Requesting video + audio...`);
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      hasVideo = localStream.getVideoTracks().length > 0;
      hasAudio = localStream.getAudioTracks().length > 0;
      console.log(`‚úÖ [Attempt ${mediaAttempt}] SUCCESS: video=${hasVideo}, audio=${hasAudio}`);
    } catch (videoError) {
      console.warn(`‚ö†Ô∏è [Attempt ${mediaAttempt}] FAILED: ${videoError.name} - ${videoError.message}`);
      
      // ATTEMPT 2: Try audio only
      mediaAttempt = 2;
      try {
        console.log(`üé¨ [Attempt ${mediaAttempt}] Requesting audio only...`);
        const audioOnlyConstraints = {
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
          video: false
        };
        localStream = await navigator.mediaDevices.getUserMedia(audioOnlyConstraints);
        hasAudio = localStream.getAudioTracks().length > 0;
        console.log(`‚úÖ [Attempt ${mediaAttempt}] SUCCESS: audio=${hasAudio}`);
        toast('Camera not available, using audio only', 'warning');
      } catch (audioError) {
        console.error(`‚ùå [Attempt ${mediaAttempt}] FAILED: ${audioError.name} - ${audioError.message}`);
        
        // ATTEMPT 3: Check what devices are available
        mediaAttempt = 3;
        try {
          console.log(`üîç [Attempt ${mediaAttempt}] Checking available devices...`);
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(d => d.kind === 'videoinput');
          const audioDevices = devices.filter(d => d.kind === 'audioinput');
          
          console.log(`üìπ Video devices found: ${videoDevices.length}`);
          videoDevices.forEach((d, i) => console.log(`   [${i}] ${d.label || 'Unknown'} (${d.deviceId.substring(0, 20)}...)`));
          
          console.log(`üé§ Audio devices found: ${audioDevices.length}`);
          audioDevices.forEach((d, i) => console.log(`   [${i}] ${d.label || 'Unknown'} (${d.deviceId.substring(0, 20)}...)`));
          
          if (videoDevices.length === 0 && audioDevices.length === 0) {
            throw new Error('No media devices found. Please check your browser permissions.');
          }
          
          // ATTEMPT 4: Try with explicit device IDs
          if (audioDevices.length > 0) {
            mediaAttempt = 4;
            console.log(`üé¨ [Attempt ${mediaAttempt}] Trying with explicit audio device ID...`);
            const explicitConstraints = {
              audio: { 
                deviceId: { exact: audioDevices[0].deviceId },
                echoCancellation: true, 
                noiseSuppression: true, 
                autoGainControl: true 
              },
              video: false
            };
            localStream = await navigator.mediaDevices.getUserMedia(explicitConstraints);
            hasAudio = localStream.getAudioTracks().length > 0;
            console.log(`‚úÖ [Attempt ${mediaAttempt}] SUCCESS with explicit device: audio=${hasAudio}`);
            toast('Connected with audio only', 'warning');
          } else {
            throw new Error('No audio devices available');
          }
          
        } catch (deviceError) {
          console.error(`‚ùå [Attempt ${mediaAttempt}] Device enumeration failed:`, deviceError);
          
          // FINAL FALLBACK: Create empty stream (call will work but no media)
          console.warn(`‚ö†Ô∏è FINAL FALLBACK: Creating empty MediaStream`);
          localStream = new MediaStream();
          hasVideo = false;
          hasAudio = false;
          toast('No media devices available. You can still join the call but others won\'t hear or see you.', 'error');
        }
      }
    }
    
    // Set final states
    isVideoEnabled = hasVideo;
    isAudioEnabled = hasAudio;
    
    console.log(`üìä Final media state: video=${isVideoEnabled}, audio=${isAudioEnabled}`);
    console.log(`üìä LocalStream tracks: ${localStream.getTracks().map(t => `${t.kind}(${t.enabled})`).join(', ')}`);
    
    // Setup audio detection if we have audio
    if (hasAudio) {
      const audioTrack = localStream.getAudioTracks()[0];
      if (audioTrack) {
        setupAudioDetection(currentUser.userId, localStream);
        console.log(`üé§ Audio detection setup for ${currentUser.username}`);
      }
    }
    
    // Update UI icon
    const callIcon = document.getElementById('callIcon');
    if (callIcon) callIcon.textContent = isVideoEnabled ? 'videocam' : 'graphic_eq';
    
    // Setup local video element
    const localVid = document.getElementById(`video-${currentUser.userId}`);
    const localPfp = document.getElementById(`pfp-${currentUser.userId}`);
    
    console.log(`üîß Setting up local video element for ${currentUser.username}`);
    console.log(`   Video element found: ${!!localVid}`);
    console.log(`   PFP element found: ${!!localPfp}`);
    console.log(`   LocalStream exists: ${!!localStream}`);
    console.log(`   Video tracks: ${localStream.getVideoTracks().length}`);
    console.log(`   Audio tracks: ${localStream.getAudioTracks().length}`);
    
    if (localVid && localStream) {
      localVid.srcObject = localStream;
      localVid.muted = true;
      localVid.volume = 0;
      
      console.log(`‚úÖ Local stream attached to video element`);
      
      if (isVideoEnabled) {
        console.log(`üìπ Attempting to show local video...`);
        
        // CRITICAL: Wait for video to be ready before showing
        localVid.onloadedmetadata = () => {
          console.log(`üìπ Video metadata loaded for ${currentUser.username}`);
          console.log(`   Video dimensions: ${localVid.videoWidth}x${localVid.videoHeight}`);
          
          localVid.play()
            .then(() => {
              console.log(`‚ñ∂Ô∏è Local video playback started successfully`);
              localVid.classList.remove('hidden');
              if (localPfp) localPfp.classList.add('hidden');
              console.log(`‚úÖ Local video now visible for ${currentUser.username}`);
            })
            .catch(e => {
              console.error('‚ùå Local video play failed:', e);
              // Fallback: show anyway
              localVid.classList.remove('hidden');
              if (localPfp) localPfp.classList.add('hidden');
            });
        };
        
        // Trigger load
        localVid.load();
        
        const btn = document.getElementById('videoBtn');
        const icon = btn?.querySelector('.material-symbols-outlined');
        if (btn && icon) {
          btn.classList.add('bg-primary', 'text-white');
          btn.classList.remove('bg-slate-200', 'dark:bg-background-dark');
          icon.textContent = 'videocam';
          console.log(`‚úÖ Video button set to ON state`);
        }
      } else {
        console.log(`üìπ Video disabled for ${currentUser.username}`);
        localVid.classList.add('hidden');
        if (localPfp) localPfp.classList.remove('hidden');
        
        const btn = document.getElementById('videoBtn');
        const icon = btn?.querySelector('.material-symbols-outlined');
        if (btn && icon) {
          btn.classList.remove('bg-primary', 'text-white');
          btn.classList.add('bg-slate-200', 'dark:bg-background-dark');
          icon.textContent = 'videocam_off';
          console.log(`‚úÖ Video button set to OFF state`);
        }
      }
      
      // Update mic button
      if (isAudioEnabled) {
        const micBtn = document.getElementById('micBtn');
        const micIcon = micBtn?.querySelector('.material-symbols-outlined');
        if (micBtn && micIcon) {
          micBtn.classList.add('bg-primary', 'text-white');
          micBtn.classList.remove('bg-accent-red');
          micIcon.textContent = 'mic';
          console.log(`‚úÖ Mic button set to ON state`);
        }
      } else {
        const micBtn = document.getElementById('micBtn');
        const micIcon = micBtn?.querySelector('.material-symbols-outlined');
        if (micBtn && micIcon) {
          micBtn.classList.remove('bg-primary');
          micBtn.classList.add('bg-accent-red', 'text-white');
          micIcon.textContent = 'mic_off';
          console.log(`‚úÖ Mic button set to OFF state`);
        }
      }
    } else {
      console.error(`‚ùå Cannot setup local video: localVid=${!!localVid}, localStream=${!!localStream}`);
    }
    
    console.log(`‚úÖ initLocalMedia() complete - stream ready for PeerConnection`);
    return localStream;
    
  } catch (e) {
    console.error('‚ùå CRITICAL: Media initialization completely failed:', e);
    console.error('‚ùå Error name:', e.name);
    console.error('‚ùå Error message:', e.message);
    console.error('‚ùå Error stack:', e.stack);
    
    // ABSOLUTE FINAL FALLBACK
    localStream = new MediaStream();
    isVideoEnabled = false;
    isAudioEnabled = false;
    
    toast('Unable to access camera or microphone. Check browser permissions and try again.', 'error');
    console.log(`‚ö†Ô∏è Created empty MediaStream as absolute fallback`);
    return localStream;
  }
}

function createPC(userId) {
  console.log(`üîó Creating PC for ${userId}`);
  
  // CRITICAL: Validate localStream exists
  if (!localStream) {
    console.error(`‚ùå CRITICAL: localStream is null when creating PC for ${userId}!`);
    console.error(`‚ùå This should never happen. Stack trace:`);
    console.trace();
    throw new Error('Cannot create PeerConnection without localStream');
  }
  
  console.log(`‚úÖ localStream validated: ${localStream.getTracks().length} tracks`);
  
  const pc = new RTCPeerConnection({ ...PEER_CONNECTION_CONFIG, iceServers: ICE_SERVERS });
  connectionStats.set(userId, { startTime: Date.now(), iceState: 'new', connectionState: 'new', candidatesReceived: 0, candidatesSent: 0 });
  
  const tracks = localStream.getTracks();
  console.log(`üìä Adding ${tracks.length} tracks to PC for ${userId}:`);
  
  tracks.forEach(track => {
    pc.addTrack(track, localStream);
    console.log(`   ‚ûï ${track.kind} track (id=${track.id.substring(0, 8)}..., enabled=${track.enabled}, readyState=${track.readyState})`);
  });
  
  if (tracks.length === 0) {
    console.warn(`‚ö†Ô∏è WARNING: No tracks in localStream for ${userId} - peer will receive empty stream`);
  }
  
  pc.ontrack = (e) => {
    console.log(`üì• Received ${e.track.kind} track from ${userId}, readyState=${e.track.readyState}, enabled=${e.track.enabled}, muted=${e.track.muted}`);
    const vid = document.getElementById(`video-${userId}`);
    const pfp = document.getElementById(`pfp-${userId}`);
    
    if (!vid) {
      console.error(`‚ùå Video element not found for ${userId}`);
      return;
    }
    
    if (!vid.srcObject) {
      vid.srcObject = new MediaStream();
      console.log(`üì∫ Created new MediaStream for ${userId}`);
    }
    
    const existingTracks = vid.srcObject.getTracks().filter(t => t.kind === e.track.kind);
    existingTracks.forEach(t => {
      console.log(`üîÑ Removing old ${t.kind} track from ${userId}`);
      vid.srcObject.removeTrack(t);
    });
    
    vid.srcObject.addTrack(e.track);
    console.log(`‚ûï Added ${e.track.kind} track to MediaStream for ${userId}`);
    console.log(`üìä Stream now has ${vid.srcObject.getTracks().length} tracks:`, vid.srcObject.getTracks().map(t => `${t.kind}(${t.enabled})`).join(', '));
    
    if (e.track.kind === 'video') {
      console.log(`üìπ Video track for ${userId}: enabled=${e.track.enabled}, muted=${e.track.muted}, readyState=${e.track.readyState}`);
      
      const updateVideoVisibility = () => {
        const shouldShowVideo = e.track.enabled && !e.track.muted && e.track.readyState === 'live';
        console.log(`üìπ Video visibility for ${userId}: shouldShow=${shouldShowVideo} (enabled=${e.track.enabled}, muted=${e.track.muted}, ready=${e.track.readyState})`);
        
        if (shouldShowVideo) {
          vid.classList.remove('hidden');
          if (pfp) pfp.classList.add('hidden');
        } else {
          vid.classList.add('hidden');
          if (pfp) pfp.classList.remove('hidden');
        }
      };
      
      setTimeout(updateVideoVisibility, 500);
      
      e.track.onunmute = () => {
        console.log(`üìπ Video UNMUTED for ${userId}`);
        setTimeout(updateVideoVisibility, 100);
      };
      
      e.track.onmute = () => {
        console.log(`üìπ Video MUTED for ${userId}`);
        updateVideoVisibility();
      };
      
      e.track.onended = () => {
        console.log(`üìπ Video ENDED for ${userId}`);
        vid.classList.add('hidden');
        if (pfp) pfp.classList.remove('hidden');
      };
      
    } else if (e.track.kind === 'audio') {
      console.log(`üîä Audio track for ${userId}: enabled=${e.track.enabled}, readyState=${e.track.readyState}`);
      
      vid.volume = 1.0;
      vid.muted = false;
      
      setupAudioDetection(userId, new MediaStream([e.track]));
      
      e.track.onended = () => {
        console.log(`üîä Audio track ended for ${userId}`);
      };
      
      e.track.onmute = () => {
        console.log(`üîä Audio MUTED for ${userId}`);
      };
      
      e.track.onunmute = () => {
        console.log(`üîä Audio UNMUTED for ${userId}`);
      };
    }
    
    vid.play()
      .then(() => {
        console.log(`‚ñ∂Ô∏è Playback started for ${userId} (${e.track.kind})`);
      })
      .catch(err => {
        console.warn(`‚ö†Ô∏è Playback error for ${userId}:`, err.message);
        if (err.name === 'NotAllowedError') {
          console.warn(`‚ö†Ô∏è Autoplay blocked - waiting for user interaction`);
          document.addEventListener('click', () => {
            vid.play().catch(e => console.warn('Retry play failed:', e));
          }, { once: true });
        }
      });
  };
  
  pc.onicecandidate = (e) => {
    if (e.candidate) {
      connectionStats.get(userId).candidatesSent++;
      socketInstance.emit('ice_candidate', { callId: callData.callId, targetUserId: userId, candidate: e.candidate });
    }
  };
  
  pc.oniceconnectionstatechange = () => {
    const state = pc.iceConnectionState;
    connectionStats.get(userId).iceState = state;
    console.log(`üßä ICE state for ${userId}: ${state}`);
    
    if (state === 'connected' || state === 'completed') {
      console.log(`‚úÖ ICE connection established for ${userId}`);
    } else if (state === 'failed') {
      console.warn(`‚ö†Ô∏è ICE failed for ${userId}, attempting restart`);
      pc.restartIce();
    } else if (state === 'disconnected') {
      console.warn(`‚ö†Ô∏è ICE disconnected for ${userId}`);
    }
  };

  pc.onconnectionstatechange = () => {
    const state = pc.connectionState;
    connectionStats.get(userId).connectionState = state;
    console.log(`üîå Connection state for ${userId}: ${state}`);
    
    if (state === 'connected') {
      console.log(`‚úÖ‚úÖ‚úÖ PEER CONNECTION ESTABLISHED for ${userId} ‚úÖ‚úÖ‚úÖ`);
      
      const subtitle = document.getElementById('callSubtitle');
      const count = Array.from(connectionStats.values()).filter(s => s.connectionState === 'connected').length + 1;
      if (subtitle) subtitle.textContent = `${count} participant${count>1?'s':''} connected`;
      
      pc.getStats().then(stats => {
        stats.forEach(r => {
          if (r.type === 'candidate-pair' && r.state === 'succeeded') {
            const local = stats.get(r.localCandidateId);
            if (local) {
              console.log(`‚úÖ Using ${local.candidateType} connection for ${userId}`);
              socketInstance.emit('connection_state_update', { 
                callId: callData.callId, 
                state: 'connected', 
                candidateType: local.candidateType 
              });
            }
          }
        });
      });
    } else if (state === 'failed') {
      console.error(`‚ùå Connection FAILED for ${userId}, will retry`);
      setTimeout(() => { 
        if (pc.connectionState === 'failed') {
          console.log(`üîÑ Restarting ICE for ${userId}`);
          pc.restartIce(); 
        }
      }, 1000);
    } else if (state === 'disconnected') {
      console.warn(`‚ö†Ô∏è Connection disconnected for ${userId}`);
    }
  };
  
  peerConnections.set(userId, pc);
  return pc;
}

async function createOffer(userId) {
  try {
    console.log(`üì§ Creating offer for ${userId}`);
    
    // Wait a bit to ensure remote peer has joined the call
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const pc = createPC(userId);
    
    // Ensure we have local stream before creating offer
    if (!localStream || localStream.getTracks().length === 0) {
      console.error(`‚ùå No local stream available when creating offer for ${userId}`);
      return;
    }
    
    console.log(`üìä Local stream for offer: ${localStream.getTracks().map(t => `${t.kind}(${t.enabled})`).join(', ')}`);
    
    const offer = await pc.createOffer({ 
      offerToReceiveAudio: true, 
      offerToReceiveVideo: true 
    });
    await pc.setLocalDescription(offer);
    
    console.log(`‚úÖ Offer created and set as local description for ${userId}`);
    socketInstance.emit('webrtc_offer', { callId: callData.callId, targetUserId: userId, offer });
  } catch (e) { 
    console.error(`‚ùå Offer creation error for ${userId}:`, e); 
  }
}

async function handleOffer(fromUserId, offer) {
  try {
    console.log(`üì• Received offer from ${fromUserId}`);
    console.log(`üìä Offer type: ${offer.type}, sdp length: ${offer.sdp?.length || 0}`);
    
    // Validate localStream exists before proceeding
    if (!localStream) {
      console.error(`‚ùå CRITICAL: No localStream when handling offer from ${fromUserId}`);
      console.error(`‚ùå Cannot create answer without local media`);
      return;
    }
    
    console.log(`‚úÖ LocalStream validated: ${localStream.getTracks().length} tracks`);
    
    let pc = peerConnections.get(fromUserId);
    if (pc) {
      console.log(`‚ö†Ô∏è PC already exists for ${fromUserId} (state: ${pc.signalingState}), closing and recreating`);
      pc.close();
      peerConnections.delete(fromUserId);
    }
    
    console.log(`üîß Creating new PeerConnection for ${fromUserId}...`);
    pc = createPC(fromUserId);
    
    if (!pc) {
      console.error(`‚ùå Failed to create PeerConnection for ${fromUserId}`);
      return;
    }
    
    console.log(`üîß Setting remote description (offer) for ${fromUserId}`);
    console.log(`üìä PC state before setRemoteDescription: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    console.log(`‚úÖ Remote description set successfully`);
    console.log(`üìä PC state after setRemoteDescription: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    // Process pending ICE candidates
    if (pendingIceCandidates.has(fromUserId)) {
      const cands = pendingIceCandidates.get(fromUserId);
      console.log(`üßä Adding ${cands.length} pending ICE candidates for ${fromUserId}`);
      for (const c of cands) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(c));
          console.log(`‚úÖ Added pending ICE candidate (type: ${c.candidate?.split(' ')[7] || 'unknown'})`);
        } catch (e) {
          console.warn(`‚ö†Ô∏è Failed to add ICE candidate:`, e.message);
        }
      }
      pendingIceCandidates.delete(fromUserId);
    }
    
    console.log(`üì§ Creating answer for ${fromUserId}...`);
    const answer = await pc.createAnswer();
    
    console.log(`üìä Answer created: type=${answer.type}, sdp length=${answer.sdp?.length || 0}`);
    
    await pc.setLocalDescription(answer);
    console.log(`‚úÖ Answer set as local description`);
    console.log(`üìä PC state after setLocalDescription: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    console.log(`üì§ Sending answer to ${fromUserId} via socket...`);
    socketInstance.emit('webrtc_answer', { callId: callData.callId, targetUserId: fromUserId, answer });
    console.log(`‚úÖ Answer emitted successfully`);
    
  } catch (e) { 
    console.error(`‚ùå Handle offer error for ${fromUserId}:`, e);
    console.error(`‚ùå Error name: ${e.name}`);
    console.error(`‚ùå Error message: ${e.message}`);
    console.error(`‚ùå Error stack:`, e.stack);
  }
}

async function handleAnswer(fromUserId, answer) {
  try {
    console.log(`üì• Received answer from ${fromUserId}`);
    console.log(`üìä Answer type: ${answer.type}, sdp length: ${answer.sdp?.length || 0}`);
    
    const pc = peerConnections.get(fromUserId);
    
    if (!pc) {
      console.error(`‚ùå No PC found for ${fromUserId} when handling answer`);
      console.error(`‚ùå Available PCs:`, Array.from(peerConnections.keys()));
      return;
    }
    
    console.log(`üìä PC state before handling answer: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    if (pc.signalingState === 'stable') {
      console.warn(`‚ö†Ô∏è PC already stable for ${fromUserId}, ignoring answer`);
      return;
    }
    
    if (pc.signalingState !== 'have-local-offer') {
      console.warn(`‚ö†Ô∏è Unexpected signaling state '${pc.signalingState}' for ${fromUserId}, expected 'have-local-offer'`);
    }
    
    console.log(`üîß Setting remote description (answer) for ${fromUserId}`);
    await pc.setRemoteDescription(new RTCSessionDescription(answer));
    console.log(`‚úÖ Answer set as remote description`);
    console.log(`üìä PC state after setRemoteDescription: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    // Process pending ICE candidates
    if (pendingIceCandidates.has(fromUserId)) {
      const cands = pendingIceCandidates.get(fromUserId);
      console.log(`üßä Adding ${cands.length} pending ICE candidates for ${fromUserId}`);
      for (const c of cands) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(c));
          console.log(`‚úÖ Added pending ICE candidate (type: ${c.candidate?.split(' ')[7] || 'unknown'})`);
        } catch (e) {
          console.warn(`‚ö†Ô∏è Failed to add ICE candidate:`, e.message);
        }
      }
      pendingIceCandidates.delete(fromUserId);
    }
    
    console.log(`‚úÖ Answer handling complete for ${fromUserId}`);
    
  } catch (e) { 
    console.error(`‚ùå Handle answer error for ${fromUserId}:`, e);
    console.error(`‚ùå Error name: ${e.name}`);
    console.error(`‚ùå Error message: ${e.message}`);
    console.error(`‚ùå Error stack:`, e.stack);
  }
}

async function handleIceCandidate(fromUserId, candidate) {
  try {
    const pc = peerConnections.get(fromUserId);
    if (pc && pc.remoteDescription) {
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
      const stats = connectionStats.get(fromUserId);
      if (stats) stats.candidatesReceived++;
      console.log(`üßä Added ICE candidate from ${fromUserId} (total: ${stats?.candidatesReceived || 0})`);
    } else {
      if (!pendingIceCandidates.has(fromUserId)) pendingIceCandidates.set(fromUserId, []);
      pendingIceCandidates.get(fromUserId).push(candidate);
      console.log(`üßä Queued ICE candidate from ${fromUserId} (pending: ${pendingIceCandidates.get(fromUserId).length})`);
    }
  } catch (e) { 
    console.warn(`‚ö†Ô∏è ICE candidate error for ${fromUserId}:`, e.message); 
  }
}

function toggleMic() {
  if (localStream) {
    const track = localStream.getAudioTracks()[0];
    if (track) {
      track.enabled = !track.enabled;
      isAudioEnabled = track.enabled;
      const btn = document.getElementById('micBtn');
      const icon = btn.querySelector('.material-symbols-outlined');
      const mic = document.getElementById(`mic-${currentUser.userId}`);
      
      console.log(`üé§ Mic toggled: ${isAudioEnabled ? 'ON' : 'OFF'}`);
      
      if (isAudioEnabled) {
        btn.classList.add('bg-primary', 'text-white');
        btn.classList.remove('bg-accent-red');
        icon.textContent = 'mic';
        if (mic) mic.classList.add('hidden');
      } else {
        btn.classList.remove('bg-primary');
        btn.classList.add('bg-accent-red', 'text-white');
        icon.textContent = 'mic_off';
        if (mic) mic.classList.remove('hidden');
      }
      
      socketInstance.emit('audio_state_changed', { callId: callData.callId, enabled: isAudioEnabled });
    }
  }
}

async function toggleVideo() {
  if (callData.callType === 'audio') { 
    toast('Video not available in audio call', 'warning'); 
    return; 
  }
  
  if (localStream) {
    const track = localStream.getVideoTracks()[0];
    if (track) {
      track.enabled = !track.enabled;
      isVideoEnabled = track.enabled;
      
      const btn = document.getElementById('videoBtn');
      const icon = btn.querySelector('.material-symbols-outlined');
      const vid = document.getElementById(`video-${currentUser.userId}`);
      const pfp = document.getElementById(`pfp-${currentUser.userId}`);
      
      console.log(`üìπ Video toggled: ${isVideoEnabled ? 'ON' : 'OFF'}`);
      
      if (isVideoEnabled) {
        btn.classList.add('bg-primary', 'text-white');
        btn.classList.remove('bg-slate-200', 'dark:bg-background-dark');
        icon.textContent = 'videocam';
        if (vid) vid.classList.remove('hidden');
        if (pfp) pfp.classList.add('hidden');
      } else {
        btn.classList.remove('bg-primary', 'text-white');
        btn.classList.add('bg-slate-200', 'dark:bg-background-dark');
        icon.textContent = 'videocam_off';
        if (vid) vid.classList.add('hidden');
        if (pfp) pfp.classList.remove('hidden');
      }
      
      // Only emit ONCE after state is updated
      socketInstance.emit('video_state_changed', { callId: callData.callId, enabled: isVideoEnabled });
    }
  }
}

      function updateDuration() {
        if (!callStartTime) return;
        const e = Math.floor((Date.now() - callStartTime) / 1000);
        const h = Math.floor(e / 3600), m = Math.floor((e % 3600) / 60), s = e % 60;
        const el = document.getElementById('callDuration');
        if (el) el.textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
      }

      function leaveCall() {
        if (isInitializing) return;
        isInitializing = true;
        audioContexts.forEach(c => c.close());
        audioContexts.clear();
        if (localStream) localStream.getTracks().forEach(t => t.stop());
        peerConnections.forEach(pc => pc.close());
        peerConnections.clear();
        if (socketInstance && socketInstance.connected) socketInstance.emit('leave_call', { callId: callData.callId });
        if (durationInterval) clearInterval(durationInterval);
        localStorage.removeItem('activeCall');
        setTimeout(() => { window.location.href = '/chat.html'; }, 500);
      }

      async function initCall() {
        if (isInitializing) return;
        isInitializing = true;
        console.log('=== INIT CALL ===');
        
        try {
          await _Auth.requireAuth();
          await fetchIceServers();
          
          const callStr = localStorage.getItem('activeCall');
          if (!callStr) { toast('No active call', 'error'); setTimeout(() => window.location.href = '/chat.html', 1500); return; }
          
          callData = JSON.parse(callStr);
          console.log(`üìû Call: ${callData.callId} (${callData.callType})`);
          
          const firebaseUser = firebase.auth().currentUser;
          if (!firebaseUser) { window.location.href = '/login.html'; return; }
          
          const userData = await _API.get('/api/users/me');
          currentUser = { userId: userData._id, username: userData.username, pfpUrl: userData.pfpUrl };
          console.log(`üë§ Current user: ${currentUser.username} (${currentUser.userId})`);
          
          const title = document.getElementById('callTitle');
          if (title) title.textContent = `${callData.callType === 'video' ? 'Video' : 'Audio'} Call`;
          
          const token = await firebaseUser.getIdToken();
          socketInstance = io(window.location.origin, {
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            auth: { token }
          });
          
          socketInstance.on('connect', () => {
            console.log(`üîå Connected: ${socketInstance.id}`);
            socketInstance.emit('authenticate', { token, userId: currentUser.userId });
          });
          
          socketInstance.on('authenticated', async () => {
            console.log('‚úÖ Authenticated');
            if (!hasJoinedCall) {
              hasJoinedCall = true;
              socketInstance.emit('join_call', { callId: callData.callId });
            }
          });
          
          
          socketInstance.on('webrtc_offer', (d) => {
  console.log(`üîî [SOCKET] webrtc_offer event received from ${d.fromUserId}`);
  handleOffer(d.fromUserId, d.offer);
});

socketInstance.on('webrtc_answer', (d) => {
  console.log(`üîî [SOCKET] webrtc_answer event received from ${d.fromUserId}`);
  handleAnswer(d.fromUserId, d.answer);
});

socketInstance.on('ice_candidate', (d) => {
  console.log(`üîî [SOCKET] ice_candidate event received from ${d.fromUserId}`);
  handleIceCandidate(d.fromUserId, d.candidate);
});
          
          
          socketInstance.on('call_joined', async (data) => {
  console.log(`‚úÖ Joined: ${data.participants.length} participants`);
  console.log('üîç Full participant data:', JSON.stringify(data.participants.map(p => ({
    userId: p.userId,
    username: p.username,
    videoEnabled: p.videoEnabled,
    audioEnabled: p.audioEnabled
  })), null, 2));
  
  const subtitle = document.getElementById('callSubtitle');
  if (subtitle) subtitle.textContent = `${data.participants.length} participant${data.participants.length>1?'s':''}`;
  
  console.log(`üé¨ Initializing local media...`);
  try {
    await initLocalMedia();
    console.log(`‚úÖ Local media initialized successfully`);
  } catch (mediaError) {
    console.error(`‚ùå Media initialization failed:`, mediaError);
    toast('Failed to initialize media. You may not be able to communicate.', 'error');
  }
  
  if (!localStream) {
    console.error(`‚ùå CRITICAL: localStream is still null after initLocalMedia()!`);
    console.error(`‚ùå Creating emergency empty stream...`);
    localStream = new MediaStream();
  }
  
  console.log(`üìä LocalStream validation: ${localStream.getTracks().length} tracks`);
  localStream.getTracks().forEach(t => {
    console.log(`   - ${t.kind}: id=${t.id.substring(0, 8)}..., enabled=${t.enabled}, readyState=${t.readyState}`);
  });
  
  const grid = document.getElementById('participantGrid');
  if (grid) {
    console.log(`üßπ Clearing grid and tracking before render`);
    grid.innerHTML = '';
    renderedParticipants.clear();
    
    console.log(`üìã Rendering ${data.participants.length} tiles`);
    
    const sortedParticipants = [...data.participants].sort((a, b) => 
      a.userId.localeCompare(b.userId)
    );
    
    sortedParticipants.forEach((p, index) => {
      const isSelf = p.userId === currentUser.userId;
      const videoState = p.videoEnabled !== undefined ? p.videoEnabled : (callData.callType === 'video');
      const audioState = p.audioEnabled !== undefined ? p.audioEnabled : true;
      
      console.log(`[${index}] Rendering ${p.username} (${p.userId}) isSelf=${isSelf} video=${videoState} audio=${audioState}`);
      
      const tile = createParticipantTile(p, isSelf);
      if (tile) {
        grid.appendChild(tile);
        console.log(`‚úÖ [${index}] Tile added to DOM for ${p.username}`);
        
        const micIndicator = document.getElementById(`mic-${p.userId}`);
        if (micIndicator) {
          if (audioState === false) {
            micIndicator.classList.remove('hidden');
            console.log(`üé§ [${index}] Initial audio OFF for ${p.username}`);
          } else {
            micIndicator.classList.add('hidden');
            console.log(`üé§ [${index}] Initial audio ON for ${p.username}`);
          }
        }
        
        if (!isSelf && videoState === false) {
          const vid = document.getElementById(`video-${p.userId}`);
          const pfp = document.getElementById(`pfp-${p.userId}`);
          if (vid && pfp) {
            vid.classList.add('hidden');
            pfp.classList.remove('hidden');
            console.log(`üìπ [${index}] Initial video OFF for ${p.username}`);
          }
        }
        
        if (!isSelf) {
          const shouldInitiateOffer = currentUser.userId < p.userId;
          console.log(`üîó [${index}] Offer decision for ${p.username}: shouldInitiate=${shouldInitiateOffer}`);
          
          if (shouldInitiateOffer) {
            setTimeout(() => {
              console.log(`üì§ [${index}] INITIATING offer to ${p.username} (${p.userId})`);
              createOffer(p.userId);
            }, 1500);
          } else {
            console.log(`‚è∏Ô∏è [${index}] WAITING for offer from ${p.username} (${p.userId})`);
          }
        }
      }
    });
    
    console.log(`üé® Grid render complete. DOM children: ${grid.children.length}, Expected: ${data.participants.length}`);
    console.log(`üìä Tracked participants:`, Array.from(renderedParticipants));
  }
  
  callStartTime = Date.now();
  durationInterval = setInterval(updateDuration, 1000);
  isInitializing = false;
  console.log('=== INIT COMPLETE ===');
});
          
          socketInstance.on('user_joined_call', (data) => {
  const videoState = data.user.videoEnabled !== undefined ? data.user.videoEnabled : (callData.callType === 'video');
  const audioState = data.user.audioEnabled !== undefined ? data.user.audioEnabled : true;
  
  console.log(`üëã User joined: ${data.user.username} (${data.user.userId}) video:${videoState} audio:${audioState}`);
  
  const grid = document.getElementById('participantGrid');
  const existingTile = document.getElementById(`participant-${data.user.userId}`);
  
  if (existingTile) {
    console.warn(`‚ö†Ô∏è Tile already exists for ${data.user.username}! This is OK if both users joined simultaneously.`);
    return;
  }
  
  // This event fires when a NEW user joins AFTER we're already in the call
  // In your case with 2 users, both join at the same time, so this won't fire
  console.log(`‚ûï Adding NEW participant ${data.user.username} who joined after us`);
  
  if (grid) {
    const tile = createParticipantTile(data.user, false);
    if (tile) {
      grid.appendChild(tile);
      
      const micIndicator = document.getElementById(`mic-${data.user.userId}`);
      if (micIndicator && audioState === false) {
        micIndicator.classList.remove('hidden');
      }
      
      // For truly late joiners, initiate connection
      const shouldInitiateOffer = currentUser.userId < data.user.userId;
      if (shouldInitiateOffer) {
        setTimeout(() => createOffer(data.user.userId), 1500);
      }
    }
  }
});
          
          socketInstance.on('user_left_call', (data) => {
            console.log(`üëã User left: ${data.userId}`);
            const tile = document.getElementById(`participant-${data.userId}`);
            if (tile) tile.remove();
            renderedParticipants.delete(data.userId);
            const pc = peerConnections.get(data.userId);
            if (pc) { pc.close(); peerConnections.delete(data.userId); }
            const ac = audioContexts.get(data.userId);
            if (ac) { ac.close(); audioContexts.delete(data.userId); }
            connectionStats.delete(data.userId);
            pendingIceCandidates.delete(data.userId);
          });
          
          socketInstance.on('webrtc_offer', (d) => handleOffer(d.fromUserId, d.offer));
          socketInstance.on('webrtc_answer', (d) => handleAnswer(d.fromUserId, d.answer));
          socketInstance.on('ice_candidate', (d) => handleIceCandidate(d.fromUserId, d.candidate));
          
          socketInstance.on('speaking_state', (d) => {
            const s = document.getElementById(`speaking-${d.userId}`);
            const t = document.getElementById(`participant-${d.userId}`);
            if (s && t) {
              if (d.speaking) { s.classList.remove('hidden'); t.classList.add('active-speaker'); }
              else { s.classList.add('hidden'); t.classList.remove('active-speaker'); }
            }
          });
          
          socketInstance.on('audio_state_changed', (d) => {
  console.log(`üé§ Remote audio state changed: userId=${d.userId}, enabled=${d.enabled}`);
  const m = document.getElementById(`mic-${d.userId}`);
  if (m) {
    if (d.enabled) {
      m.classList.add('hidden');
    } else {
      m.classList.remove('hidden');
    }
  }
});

socketInstance.on('video_state_changed', (d) => {
  console.log(`üìπ Remote video state changed: userId=${d.userId}, enabled=${d.enabled}`);
  
  // Don't manipulate video visibility here - let the track events handle it
  // Just log for debugging
  const vid = document.getElementById(`video-${d.userId}`);
  const pfp = document.getElementById(`pfp-${d.userId}`);
  
  if (vid && pfp) {
    console.log(`üìπ Video elements found for ${d.userId}`);
    // The ontrack handler will manage visibility based on actual track state
  }
});
          
          socketInstance.on('video_state_changed', (d) => {
  console.log(`üìπ Video state changed: userId=${d.userId}, enabled=${d.enabled}`);
  
  const vid = document.getElementById(`video-${d.userId}`);
  const pfp = document.getElementById(`pfp-${d.userId}`);
  
  if (!vid || !pfp) {
    console.warn(`‚ö†Ô∏è Video elements not found for userId ${d.userId}`);
    return;
  }
  
  if (d.enabled) {
    console.log(`üìπ Showing video for ${d.userId} (waiting for track...)`);
    // Video will be shown when track.onunmute fires in ontrack handler
    // Don't force it here - let WebRTC handle it
  } else {
    console.log(`üìπ Hiding video, showing pfp for ${d.userId}`);
    vid.classList.add('hidden');
    pfp.classList.remove('hidden');
  }
});
          
          socketInstance.on('call_ended', () => { toast('Call ended', 'warning'); leaveCall(); });
          
          const mic = document.getElementById('micBtn');
          const vid = document.getElementById('videoBtn');
          const leave = document.getElementById('leaveCallBtn');
          if (mic) mic.addEventListener('click', toggleMic);
          if (vid) vid.addEventListener('click', toggleVideo);
          if (leave) leave.addEventListener('click', leaveCall);
          window.addEventListener('beforeunload', () => leaveCall());
          
        } catch (e) {
          console.error('‚ùå Init error:', e);
          toast('Failed to initialize call', 'error');
          isInitializing = false;
          setTimeout(() => window.location.href = '/chat.html', 2000);
        }
      }

      console.log('‚úÖ Page loaded - starting initialization');
      initCall();
    })();
    </script>
</body>
</html>
