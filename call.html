<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Call - MoodLog (Enhanced)</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#33bfcc",
                        "background-light": "#f2f2f3",
                        "background-dark": "#1c1e22",
                        "surface-dark": "#272A2E",
                        "accent-red": "#ef4444",
                    },
                    fontFamily: {
                        "display": ["Manrope", "sans-serif"]
                    }
                },
            },
        }
    </script>
    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }
        .active-speaker {
            box-shadow: 0 0 0 3px #33bfcc;
        }
        body {
            font-family: 'Manrope', sans-serif;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .video-tile {
            position: relative;
            background: #1c1e22;
        }
        .debug-panel {
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
        }
        .debug-entry {
            padding: 2px 4px;
            border-bottom: 1px solid #e5e7eb;
        }
        .debug-success { color: #10b981; }
        .debug-error { color: #ef4444; }
        .debug-warning { color: #f59e0b; }
        .debug-info { color: #3b82f6; }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-900 dark:text-white min-h-screen flex flex-col font-display">
    <!-- Top Navigation Bar -->
    <header class="sticky top-0 z-50 w-full border-b border-slate-200 dark:border-slate-800 px-6 py-4 flex items-center justify-between bg-background-light dark:bg-background-dark">
        <div class="flex items-center gap-4">
            <div class="bg-primary/20 p-2 rounded-lg">
                <span class="material-symbols-outlined text-primary">graphic_eq</span>
            </div>
            <div>
                <h1 class="text-lg font-bold tracking-tight" id="callTitle">Mindful Space Call</h1>
                <p class="text-xs text-slate-500 dark:text-slate-400" id="callSubtitle">Connecting...</p>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-2 bg-slate-200 dark:bg-surface-dark px-4 py-2 rounded-xl border border-slate-300 dark:border-slate-700">
                <span class="relative flex h-2 w-2">
                    <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-primary opacity-75"></span>
                    <span class="relative inline-flex rounded-full h-2 w-2 bg-primary"></span>
                </span>
                <span class="text-sm font-bold font-mono" id="callDuration">00:00:00</span>
            </div>
            <button id="toggleDebug" class="p-2 hover:bg-slate-200 dark:hover:bg-surface-dark rounded-lg transition-colors" title="Toggle Debug Panel">
                <span class="material-symbols-outlined">bug_report</span>
            </button>
            <button class="p-2 hover:bg-slate-200 dark:hover:bg-surface-dark rounded-lg transition-colors">
                <span class="material-symbols-outlined">info</span>
            </button>
        </div>
    </header>

    <!-- Debug Panel (Collapsible) -->
    <div id="debugPanel" class="hidden border-b border-slate-200 dark:border-slate-800 bg-white dark:bg-surface-dark">
        <div class="p-4">
            <div class="flex items-center justify-between mb-3">
                <h3 class="text-sm font-bold">WebRTC Debug Console</h3>
                <div class="flex gap-2">
                    <span id="connectionQuality" class="text-xs px-2 py-1 rounded bg-gray-200 dark:bg-gray-700">Initializing...</span>
                    <button id="clearDebug" class="text-xs px-2 py-1 rounded bg-red-500 text-white hover:bg-red-600">Clear</button>
                </div>
            </div>
            <div id="debugLogs" class="debug-panel bg-gray-50 dark:bg-gray-900 rounded p-2"></div>
        </div>
    </div>

    <!-- Main Content: Participant Grid -->
    <main class="flex-1 overflow-y-auto p-6 md:p-12">
        <div class="max-w-6xl mx-auto">
            <div id="participantGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                <!-- Participant tiles will be dynamically generated here -->
            </div>
        </div>
    </main>

    <!-- Bottom Persistent Control Bar -->
    <footer class="w-full p-6 flex justify-center sticky bottom-0 bg-gradient-to-t from-background-light dark:from-background-dark via-background-light/95 dark:via-background-dark/95 to-transparent">
        <div class="bg-white dark:bg-surface-dark shadow-2xl rounded-2xl border border-slate-200 dark:border-slate-700 p-2 flex items-center gap-2">
            <div class="flex items-center gap-1 px-2 border-r border-slate-200 dark:border-slate-700">
                <button id="micBtn" class="w-12 h-12 flex items-center justify-center rounded-xl bg-primary text-white hover:opacity-90 transition-all active:scale-95">
                    <span class="material-symbols-outlined">mic</span>
                </button>
                <button id="videoBtn" class="w-12 h-12 flex items-center justify-center rounded-xl text-slate-500 hover:bg-slate-100 dark:hover:bg-slate-700 transition-all">
                    <span class="material-symbols-outlined">videocam_off</span>
                </button>
                <button id="screenShareBtn" class="w-12 h-12 flex items-center justify-center rounded-xl text-slate-500 hover:bg-slate-100 dark:hover:bg-slate-700 transition-all">
                    <span class="material-symbols-outlined">screen_share</span>
                </button>
            </div>
            <div class="flex items-center gap-2 px-4">
                <button id="moodBtn" class="flex items-center gap-2 px-4 h-12 rounded-xl bg-slate-100 dark:bg-background-dark text-slate-700 dark:text-white border border-slate-200 dark:border-slate-700 hover:border-primary transition-all">
                    <span class="text-xl" id="currentMoodEmoji">ðŸ˜Š</span>
                    <span class="text-sm font-bold">Update Mood</span>
                </button>
            </div>
            <div class="pl-2">
                <button id="leaveCallBtn" class="flex items-center gap-2 px-6 h-12 rounded-xl bg-accent-red text-white hover:brightness-110 shadow-lg shadow-accent-red/20 transition-all active:scale-95">
                    <span class="material-symbols-outlined font-bold">call_end</span>
                    <span class="font-bold text-sm">Leave Call</span>
                </button>
            </div>
        </div>
    </footer>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };

      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>

    <!-- Socket.IO -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>

    <!-- App -->
    <script src="app.js"></script>

    <script>
    (async () => {
      const MoodApp = window.MoodApp || {};
      const _Auth = MoodApp.Auth;
      const _API = MoodApp.API;
      const _Toast = MoodApp.Toast;

      const toast = (m, t='success') => { 
        if (_Toast && typeof _Toast[t] === 'function') return _Toast[t](m); 
        console[t==='error'?'error':'log'](m); 
      };

      // ============================================
      // DEBUG LOGGING SYSTEM
      // ============================================
      
      const debugLogs = [];
      const debugContainer = document.getElementById('debugLogs');
      const debugPanel = document.getElementById('debugPanel');
      
      function debugLog(message, type = 'info') {
        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
        const entry = { timestamp, message, type };
        debugLogs.push(entry);
        
        if (debugContainer) {
          const logDiv = document.createElement('div');
          logDiv.className = `debug-entry debug-${type}`;
          logDiv.textContent = `[${timestamp}] ${message}`;
          debugContainer.appendChild(logDiv);
          debugContainer.scrollTop = debugContainer.scrollHeight;
        }
        
        console.log(`[WebRTC ${type.toUpperCase()}]`, message);
      }

      document.getElementById('toggleDebug')?.addEventListener('click', () => {
        debugPanel.classList.toggle('hidden');
      });

      document.getElementById('clearDebug')?.addEventListener('click', () => {
        debugLogs.length = 0;
        if (debugContainer) debugContainer.innerHTML = '';
      });

      // ============================================
      // ENHANCED ICE CONFIGURATION
      // ============================================
      
      let ICE_SERVERS = null;

      async function fetchIceServers() {
        try {
          debugLog('Fetching ICE servers from backend...', 'info');
          const response = await _API.get('/api/ice-servers');
          ICE_SERVERS = response.iceServers;
          
          debugLog(`ICE servers loaded: ${ICE_SERVERS.length} configurations`, 'success');
          ICE_SERVERS.forEach((server, idx) => {
            if (server.urls) {
              const urls = Array.isArray(server.urls) ? server.urls : [server.urls];
              urls.forEach(url => {
                const hasCredentials = !!(server.username && server.credential);
                const serverType = url.startsWith('turn:') ? 'TURN' : 'STUN';
                debugLog(`  [${idx}] ${serverType}: ${url} ${hasCredentials ? '(authenticated)' : ''}`, 'info');
              });
            }
          });
          
          return ICE_SERVERS;
        } catch (error) {
          debugLog(`Failed to fetch ICE servers: ${error.message}`, 'error');
          
          // Fallback to STUN-only configuration
          ICE_SERVERS = [
            {
              urls: [
                'stun:stun.cloudflare.com:3478',
                'stun:stun.l.google.com:19302',
                'stun:stun1.l.google.com:19302'
              ]
            }
          ];
          debugLog('Using fallback STUN-only configuration', 'warning');
          return ICE_SERVERS;
        }
      }

      // Enhanced WebRTC Configuration
      const PEER_CONNECTION_CONFIG = {
        iceCandidatePoolSize: 10,
        iceTransportPolicy: 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      };

      // State management
      let localStream = null;
      let peerConnections = new Map();
      let socketInstance = null;
      let callData = null;
      let currentUser = null;
      let isAudioEnabled = true;
      let isVideoEnabled = false;
      let callStartTime = null;
      let durationInterval = null;
      let isInitializing = false;
      let hasJoinedCall = false;
      
      // Connection quality tracking
      const connectionStats = new Map();

      // Helper function to create profile picture element
      function createProfilePictureElement(pfpUrl, username, size = 'w-24 h-24') {
        const initial = username ? username.charAt(0).toUpperCase() : 'U';
        const container = document.createElement('div');
        container.className = `${size} rounded-full overflow-hidden bg-slate-100 dark:bg-slate-800 border-4 border-primary/30 flex-shrink-0`;
        
        if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
          const img = document.createElement('img');
          img.src = pfpUrl;
          img.alt = username;
          img.className = 'h-full w-full object-cover';
          img.onerror = function() {
            this.onerror = null;
            container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-2xl">${initial}</div>`;
          };
          container.appendChild(img);
        } else {
          container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-2xl">${initial}</div>`;
        }
        
        return container;
      }

      // Create participant tile
      function createParticipantTile(user, isSelf = false) {
        const tile = document.createElement('div');
        tile.id = `participant-${user.userId}`;
        tile.className = `video-tile relative group bg-slate-100 dark:bg-surface-dark rounded-xl p-6 flex flex-col items-center justify-center text-center border transition-all duration-300 ${isSelf ? 'border-2 border-dashed border-primary/40 bg-primary/10 dark:bg-primary/5' : 'border-transparent hover:border-slate-300 dark:hover:border-slate-600'}`;
        
        const videoContainer = document.createElement('div');
        videoContainer.className = 'relative mb-4';
        
        const videoElement = document.createElement('video');
        videoElement.id = `video-${user.userId}`;
        videoElement.className = 'w-24 h-24 rounded-full object-cover hidden';
        videoElement.autoplay = true;
        videoElement.playsInline = true;
        if (isSelf) {
          videoElement.muted = true;
        }
        
        const pfpElement = createProfilePictureElement(user.pfpUrl, user.username, 'w-24 h-24');
        pfpElement.id = `pfp-${user.userId}`;
        
        videoContainer.appendChild(videoElement);
        videoContainer.appendChild(pfpElement);
        
        const moodBadge = document.createElement('div');
        moodBadge.className = 'absolute -bottom-1 -right-1 bg-white dark:bg-background-dark p-1.5 rounded-full shadow-lg border border-slate-200 dark:border-slate-700';
        moodBadge.innerHTML = '<span class="text-xl leading-none">ðŸ˜Š</span>';
        videoContainer.appendChild(moodBadge);
        
        const micIndicator = document.createElement('div');
        micIndicator.id = `mic-${user.userId}`;
        micIndicator.className = 'absolute top-0 right-0 bg-accent-red p-1 rounded-full text-white hidden';
        micIndicator.innerHTML = '<span class="material-symbols-outlined text-[14px] font-bold">mic_off</span>';
        videoContainer.appendChild(micIndicator);
        
        tile.appendChild(videoContainer);
        
        const userInfo = document.createElement('div');
        const username = document.createElement('p');
        username.className = 'text-slate-900 dark:text-white text-base font-bold';
        username.textContent = isSelf ? 'You' : (user.username || 'User');
        
        const status = document.createElement('p');
        status.id = `status-${user.userId}`;
        status.className = 'text-slate-500 dark:text-slate-400 text-sm';
        status.textContent = 'Connecting...';
        
        userInfo.appendChild(username);
        userInfo.appendChild(status);
        tile.appendChild(userInfo);
        
        return tile;
      }

      // Initialize local media
      async function initializeLocalMedia() {
        try {
          debugLog(`Requesting local media (type: ${callData.callType})...`, 'info');
          
          const constraints = {
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            },
            video: callData.callType === 'video' ? {
              width: { ideal: 640 },
              height: { ideal: 480 },
              frameRate: { ideal: 30 }
            } : false
          };
          
          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          const tracks = localStream.getTracks();
          debugLog(`Local media initialized: ${tracks.map(t => `${t.kind}(${t.label})`).join(', ')}`, 'success');
          
          isVideoEnabled = callData.callType === 'video';
          isAudioEnabled = true;
          
          if (isVideoEnabled) {
            const localVideo = document.getElementById(`video-${currentUser.userId}`);
            const localPfp = document.getElementById(`pfp-${currentUser.userId}`);
            if (localVideo && localStream) {
              localVideo.srcObject = localStream;
              await localVideo.play().catch(e => debugLog(`Video play warning: ${e.message}`, 'warning'));
              localVideo.classList.remove('hidden');
              if (localPfp) localPfp.classList.add('hidden');
            }
          }
          
          return localStream;
        } catch (error) {
          debugLog(`Failed to get local media: ${error.name} - ${error.message}`, 'error');
          toast('Failed to access camera/microphone. Please check permissions.', 'error');
          throw error;
        }
      }

      // Create peer connection with enhanced logging
      function createPeerConnection(userId) {
        debugLog(`Creating peer connection for user: ${userId}`, 'info');
        
        const config = {
          ...PEER_CONNECTION_CONFIG,
          iceServers: ICE_SERVERS
        };
        
        const pc = new RTCPeerConnection(config);
        
        // Track connection stats
        connectionStats.set(userId, {
          startTime: Date.now(),
          iceState: 'new',
          connectionState: 'new',
          candidatesReceived: 0,
          candidatesSent: 0,
          selectedCandidate: null
        });
        
        // Add local tracks
        if (localStream) {
          localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
            debugLog(`Added local ${track.kind} track to connection with ${userId}`, 'info');
          });
        }
        
        // Handle incoming tracks
        pc.ontrack = (event) => {
          debugLog(`Received remote ${event.track.kind} from ${userId} (readyState: ${event.track.readyState})`, 'success');
          const remoteVideo = document.getElementById(`video-${userId}`);
          const remotePfp = document.getElementById(`pfp-${userId}`);
          
          if (remoteVideo) {
            if (!remoteVideo.srcObject) {
              remoteVideo.srcObject = new MediaStream();
            }
            remoteVideo.srcObject.addTrack(event.track);
            remoteVideo.play().catch(e => debugLog(`Remote video play warning: ${e.message}`, 'warning'));
            
            if (event.track.kind === 'video') {
              event.track.onunmute = () => {
                debugLog(`Video track unmuted for ${userId}`, 'info');
                remoteVideo.classList.remove('hidden');
                if (remotePfp) remotePfp.classList.add('hidden');
              };
            }
          }
        };
        
        // Handle ICE candidates with detailed logging
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            const stats = connectionStats.get(userId);
            stats.candidatesSent++;
            
            const c = event.candidate;
            debugLog(`ICE candidate for ${userId}: type=${c.type}, protocol=${c.protocol}, priority=${c.priority}`, 'info');
            
            socketInstance.emit('ice_candidate', {
              callId: callData.callId,
              targetUserId: userId,
              candidate: c
            });
          } else {
            debugLog(`ICE gathering completed for ${userId}`, 'success');
          }
        };
        
        // ICE gathering state
        pc.onicegatheringstatechange = () => {
          const state = pc.iceGatheringState;
          debugLog(`ICE gathering state for ${userId}: ${state}`, 'info');
          connectionStats.get(userId).iceGatheringState = state;
        };
        
        // Connection state with detailed tracking
        pc.onconnectionstatechange = () => {
          const state = pc.connectionState;
          const stats = connectionStats.get(userId);
          stats.connectionState = state;
          
          debugLog(`Connection state with ${userId}: ${state}`, state === 'connected' ? 'success' : state === 'failed' ? 'error' : 'info');
          
          const statusEl = document.getElementById(`status-${userId}`);
          if (statusEl) {
            switch (state) {
              case 'connected':
                statusEl.textContent = 'Connected';
                statusEl.className = 'text-primary text-xs font-semibold uppercase tracking-wider';
                // Get selected candidate pair
                pc.getStats().then(stats => {
                  stats.forEach(report => {
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                      const localCandidate = stats.get(report.localCandidateId);
                      const remoteCandidate = stats.get(report.remoteCandidateId);
                      if (localCandidate) {
                        debugLog(`Selected candidate pair for ${userId}: local=${localCandidate.candidateType}, remote=${remoteCandidate?.candidateType}`, 'success');
                        stats.selectedCandidate = localCandidate.candidateType;
                        updateConnectionQuality();
                        
                        // Report to server
                        socketInstance.emit('connection_state_update', {
                          callId: callData.callId,
                          state: 'connected',
                          candidateType: localCandidate.candidateType
                        });
                      }
                    }
                  });
                });
                break;
              case 'connecting':
                statusEl.textContent = 'Connecting...';
                statusEl.className = 'text-yellow-500 text-sm';
                break;
              case 'disconnected':
                statusEl.textContent = 'Reconnecting...';
                statusEl.className = 'text-yellow-500 text-sm';
                break;
              case 'failed':
                debugLog(`Connection failed with ${userId} - attempting ICE restart`, 'error');
                statusEl.textContent = 'Connection failed';
                statusEl.className = 'text-red-500 text-sm';
                setTimeout(() => {
                  if (pc.connectionState === 'failed') {
                    debugLog(`Restarting ICE for ${userId}`, 'warning');
                    pc.restartIce();
                  }
                }, 1000);
                socketInstance.emit('connection_state_update', {
                  callId: callData.callId,
                  state: 'failed'
                });
                break;
              case 'closed':
                statusEl.textContent = 'Disconnected';
                statusEl.className = 'text-slate-500 text-sm';
                break;
            }
          }
        };
        
        // ICE connection state
        pc.oniceconnectionstatechange = () => {
          const state = pc.iceConnectionState;
          debugLog(`ICE connection state with ${userId}: ${state}`, 'info');
          connectionStats.get(userId).iceState = state;
          
          if (state === 'failed') {
            debugLog(`ICE connection failed with ${userId} - attempting restart`, 'error');
            pc.restartIce();
          }
        };
        
        peerConnections.set(userId, pc);
        return pc;
      }

      // Update connection quality indicator
      function updateConnectionQuality() {
        const qualityEl = document.getElementById('connectionQuality');
        if (!qualityEl) return;
        
        let hasRelay = false;
        let hasSrflx = false;
        let hasHost = false;
        let connectedCount = 0;
        
        connectionStats.forEach((stats, userId) => {
          if (stats.connectionState === 'connected') {
            connectedCount++;
            if (stats.selectedCandidate === 'relay') hasRelay = true;
            else if (stats.selectedCandidate === 'srflx') hasSrflx = true;
            else if (stats.selectedCandidate === 'host') hasHost = true;
          }
        });
        
        let quality = 'Unknown';
        let bgClass = 'bg-gray-200 dark:bg-gray-700';
        
        if (connectedCount > 0) {
          if (hasRelay) {
            quality = 'TURN Relay';
            bgClass = 'bg-yellow-200 dark:bg-yellow-800 text-yellow-900 dark:text-yellow-100';
          } else if (hasSrflx) {
            quality = 'P2P (STUN)';
            bgClass = 'bg-green-200 dark:bg-green-800 text-green-900 dark:text-green-100';
          } else if (hasHost) {
            quality = 'P2P Direct';
            bgClass = 'bg-green-200 dark:bg-green-800 text-green-900 dark:text-green-100';
          }
        }
        
        qualityEl.textContent = quality;
        qualityEl.className = `text-xs px-2 py-1 rounded ${bgClass}`;
      }

      // Create and send offer
      async function createOffer(userId) {
        try {
          debugLog(`Creating offer for ${userId}`, 'info');
          const pc = createPeerConnection(userId);
          
          const offer = await pc.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: callData.callType === 'video'
          });
          
          await pc.setLocalDescription(offer);
          debugLog(`Offer created and set as local description for ${userId}`, 'success');
          
          socketInstance.emit('webrtc_offer', {
            callId: callData.callId,
            targetUserId: userId,
            offer: offer
          });
          
          debugLog(`Offer sent to ${userId}`, 'info');
        } catch (error) {
          debugLog(`Error creating offer for ${userId}: ${error.message}`, 'error');
        }
      }

      // Handle incoming offer
      async function handleOffer(fromUserId, offer) {
        try {
          debugLog(`Received offer from ${fromUserId}`, 'info');
          const pc = createPeerConnection(fromUserId);
          
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          debugLog(`Remote description set from ${fromUserId}`, 'success');
          
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          debugLog(`Answer created for ${fromUserId}`, 'success');
          
          socketInstance.emit('webrtc_answer', {
            callId: callData.callId,
            targetUserId: fromUserId,
            answer: answer
          });
          
          debugLog(`Answer sent to ${fromUserId}`, 'info');
        } catch (error) {
          debugLog(`Error handling offer from ${fromUserId}: ${error.message}`, 'error');
        }
      }

      // Handle incoming answer
      async function handleAnswer(fromUserId, answer) {
        try {
          debugLog(`Received answer from ${fromUserId}`, 'info');
          const pc = peerConnections.get(fromUserId);
          if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
            debugLog(`Remote description (answer) set from ${fromUserId}`, 'success');
          } else {
            debugLog(`No peer connection found for ${fromUserId} when handling answer`, 'warning');
          }
        } catch (error) {
          debugLog(`Error handling answer from ${fromUserId}: ${error.message}`, 'error');
        }
      }

      // Handle ICE candidate
      async function handleIceCandidate(fromUserId, candidate) {
        try {
          const pc = peerConnections.get(fromUserId);
          if (pc && pc.remoteDescription) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            const stats = connectionStats.get(fromUserId);
            stats.candidatesReceived++;
            debugLog(`ICE candidate added from ${fromUserId}: type=${candidate.type}`, 'info');
          } else {
            debugLog(`Cannot add ICE candidate from ${fromUserId} - ${!pc ? 'no connection' : 'no remote description'}`, 'warning');
          }
        } catch (error) {
          debugLog(`Error adding ICE candidate from ${fromUserId}: ${error.message}`, 'error');
        }
      }

      // Toggle microphone
      function toggleMicrophone() {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            isAudioEnabled = audioTrack.enabled;
            
            const micBtn = document.getElementById('micBtn');
            const micIcon = micBtn.querySelector('.material-symbols-outlined');
            const micIndicator = document.getElementById(`mic-${currentUser.userId}`);
            
            if (isAudioEnabled) {
              micBtn.classList.add('bg-primary', 'text-white');
              micBtn.classList.remove('bg-accent-red');
              micIcon.textContent = 'mic';
              if (micIndicator) micIndicator.classList.add('hidden');
            } else {
              micBtn.classList.remove('bg-primary', 'text-white');
              micBtn.classList.add('bg-accent-red', 'text-white');
              micIcon.textContent = 'mic_off';
              if (micIndicator) micIndicator.classList.remove('hidden');
            }
            
            debugLog(`Audio ${isAudioEnabled ? 'enabled' : 'disabled'}`, 'info');
            socketInstance.emit('audio_state_changed', {
              callId: callData.callId,
              enabled: isAudioEnabled
            });
          }
        }
      }

      // Toggle video
      async function toggleVideo() {
        if (callData.callType === 'audio') {
          toast('Video not available in audio-only call', 'warning');
          return;
        }
        
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            isVideoEnabled = videoTrack.enabled;
            
            const videoBtn = document.getElementById('videoBtn');
            const videoIcon = videoBtn.querySelector('.material-symbols-outlined');
            const localVideo = document.getElementById(`video-${currentUser.userId}`);
            const localPfp = document.getElementById(`pfp-${currentUser.userId}`);
            
            if (isVideoEnabled) {
              videoBtn.classList.remove('text-slate-500');
              videoBtn.classList.add('bg-primary', 'text-white');
              videoIcon.textContent = 'videocam';
              if (localVideo) localVideo.classList.remove('hidden');
              if (localPfp) localPfp.classList.add('hidden');
            } else {
              videoBtn.classList.add('text-slate-500');
              videoBtn.classList.remove('bg-primary', 'text-white');
              videoIcon.textContent = 'videocam_off';
              if (localVideo) localVideo.classList.add('hidden');
              if (localPfp) localPfp.classList.remove('hidden');
            }
            
            debugLog(`Video ${isVideoEnabled ? 'enabled' : 'disabled'}`, 'info');
            socketInstance.emit('video_state_changed', {
              callId: callData.callId,
              enabled: isVideoEnabled
            });
          }
        }
      }

      // Update call duration
      function updateCallDuration() {
        if (!callStartTime) return;
        
        const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
        const hours = Math.floor(elapsed / 3600);
        const minutes = Math.floor((elapsed % 3600) / 60);
        const seconds = elapsed % 60;
        
        const durationEl = document.getElementById('callDuration');
        if (durationEl) {
          durationEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
      }

      // Leave call
      function leaveCall() {
        if (isInitializing) {
          debugLog('Still initializing, preventing duplicate leave', 'warning');
          return;
        }
        
        debugLog('Leaving call...', 'info');
        isInitializing = true;
        
        if (localStream) {
          localStream.getTracks().forEach(track => {
            track.stop();
            debugLog(`Stopped ${track.kind} track`, 'info');
          });
        }
        
        peerConnections.forEach((pc, userId) => {
          debugLog(`Closing connection to ${userId}`, 'info');
          pc.close();
        });
        peerConnections.clear();
        
        if (socketInstance && socketInstance.connected) {
          socketInstance.emit('leave_call', {
            callId: callData.callId
          });
        }
        
        if (durationInterval) {
          clearInterval(durationInterval);
        }
        
        localStorage.removeItem('activeCall');
        
        setTimeout(() => {
          window.location.href = '/chat.html';
        }, 500);
      }

      // Initialize call
      async function initializeCall() {
        if (isInitializing) {
          debugLog('Already initializing call', 'warning');
          return;
        }
        
        isInitializing = true;
        debugLog('=== Initializing Call ===', 'info');
        
        try {
          await _Auth.requireAuth();
          
          // Fetch ICE servers first
          await fetchIceServers();
          
          const callDataStr = localStorage.getItem('activeCall');
          if (!callDataStr) {
            toast('No active call found', 'error');
            setTimeout(() => window.location.href = '/chat.html', 1500);
            return;
          }
          
          callData = JSON.parse(callDataStr);
          debugLog(`Call data loaded: ${JSON.stringify(callData)}`, 'info');
          
          const firebaseUser = firebase.auth().currentUser;
          if (!firebaseUser) {
            window.location.href = '/login.html';
            return;
          }
          
          const userData = await _API.get('/api/users/me');
          currentUser = {
            userId: userData._id,
            username: userData.username,
            pfpUrl: userData.pfpUrl
          };
          
          debugLog(`Current user: ${currentUser.username} (${currentUser.userId})`, 'info');
          
          const callTitle = document.getElementById('callTitle');
          const callSubtitle = document.getElementById('callSubtitle');
          if (callTitle) callTitle.textContent = `${callData.callType === 'video' ? 'Video' : 'Audio'} Call`;
          if (callSubtitle) callSubtitle.textContent = 'Initializing...';
          
          const idToken = await firebaseUser.getIdToken();
          const socketUrl = window.location.origin;
          socketInstance = io(socketUrl, {
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            auth: { token: idToken }
          });
          
          socketInstance.on('connect', () => {
            debugLog(`Socket connected: ${socketInstance.id}`, 'success');
            socketInstance.emit('authenticate', {
              token: idToken,
              userId: currentUser.userId
            });
          });
          
          socketInstance.on('authenticated', async () => {
            debugLog('Socket authenticated', 'success');
            
            if (!hasJoinedCall) {
              hasJoinedCall = true;
              socketInstance.emit('join_call', {
                callId: callData.callId
              });
            }
          });
          
          socketInstance.on('call_joined', async (data) => {
            debugLog(`Call joined: ${data.participants.length} participants`, 'success');
            
            if (callSubtitle) callSubtitle.textContent = `${data.participants.length} participant${data.participants.length > 1 ? 's' : ''}`;
            
            await initializeLocalMedia();
            
            const participantGrid = document.getElementById('participantGrid');
            if (participantGrid) {
              participantGrid.innerHTML = '';
              
              data.participants.forEach(participant => {
                const isSelf = participant.userId === currentUser.userId;
                const tile = createParticipantTile(participant, isSelf);
                participantGrid.appendChild(tile);
                
                if (!isSelf) {
                  setTimeout(() => createOffer(participant.userId), 500);
                }
              });
            }
            
            callStartTime = Date.now();
            durationInterval = setInterval(updateCallDuration, 1000);
            
            isInitializing = false;
            debugLog('=== Call Initialization Complete ===', 'success');
          });
          
          socketInstance.on('user_joined_call', (data) => {
            debugLog(`User joined call: ${data.user.username}`, 'info');
            
            const participantGrid = document.getElementById('participantGrid');
            if (participantGrid && !document.getElementById(`participant-${data.user.userId}`)) {
              const tile = createParticipantTile(data.user, false);
              participantGrid.appendChild(tile);
              setTimeout(() => createOffer(data.user.userId), 500);
            }
          });
          
          socketInstance.on('user_left_call', (data) => {
            debugLog(`User left call: ${data.userId}`, 'info');
            
            const tile = document.getElementById(`participant-${data.userId}`);
            if (tile) tile.remove();
            
            const pc = peerConnections.get(data.userId);
            if (pc) {
              pc.close();
              peerConnections.delete(data.userId);
            }
            
            connectionStats.delete(data.userId);
            updateConnectionQuality();
          });
          
          socketInstance.on('webrtc_offer', (data) => {
            handleOffer(data.fromUserId, data.offer);
          });
          
          socketInstance.on('webrtc_answer', (data) => {
            handleAnswer(data.fromUserId, data.answer);
          });
          
          socketInstance.on('ice_candidate', (data) => {
            handleIceCandidate(data.fromUserId, data.candidate);
          });
          
          socketInstance.on('audio_state_changed', (data) => {
            const micIndicator = document.getElementById(`mic-${data.userId}`);
            if (micIndicator) {
              if (data.enabled) {
                micIndicator.classList.add('hidden');
              } else {
                micIndicator.classList.remove('hidden');
              }
            }
          });
          
          socketInstance.on('video_state_changed', (data) => {
            const video = document.getElementById(`video-${data.userId}`);
            const pfp = document.getElementById(`pfp-${data.userId}`);
            if (video && pfp) {
              if (data.enabled) {
                video.classList.remove('hidden');
                pfp.classList.add('hidden');
              } else {
                video.classList.add('hidden');
                pfp.classList.remove('hidden');
              }
            }
          });
          
          socketInstance.on('call_ended', () => {
            debugLog('Call ended by host', 'warning');
            toast('Call ended', 'warning');
            leaveCall();
          });
          
          const micBtn = document.getElementById('micBtn');
          const videoBtn = document.getElementById('videoBtn');
          const leaveCallBtn = document.getElementById('leaveCallBtn');
          
          if (micBtn) micBtn.addEventListener('click', toggleMicrophone);
          if (videoBtn) videoBtn.addEventListener('click', toggleVideo);
          if (leaveCallBtn) leaveCallBtn.addEventListener('click', leaveCall);
          
          window.addEventListener('beforeunload', (e) => {
            leaveCall();
          });
          
        } catch (error) {
          debugLog(`Call initialization error: ${error.message}`, 'error');
          toast('Failed to initialize call', 'error');
          isInitializing = false;
          setTimeout(() => window.location.href = '/chat.html', 2000);
        }
      }

      sessionStorage.removeItem('navigatingToCall');
      debugLog('Cleared navigation flag', 'info');
      
      initializeCall();
      
    })();
    </script>
</body>
</html>
