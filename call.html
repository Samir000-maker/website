<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Active Call - MoodLog</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#33bfcc",
                        "background-light": "#f2f2f3",
                        "background-dark": "#121417",
                        "surface-dark": "#1e2124",
                        "accent-red": "#ef4444",
                    },
                    fontFamily: {
                        "display": ["Manrope", "sans-serif"]
                    }
                },
            },
        }
    </script>
    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }
        
        .active-speaker {
            box-shadow: 0 0 0 3px #33bfcc, 0 0 15px rgba(51, 191, 204, 0.4) !important;
            border-color: #33bfcc !important;
        }
        
        body {
            font-family: 'Manrope', sans-serif;
            overscroll-behavior: none;
        }
        
        .video-tile {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            max-width: 400px;
            background: #000;
            overflow: hidden;
            border-radius: 1rem;
        }
        
        .video-container {
            position: absolute;
            inset: 0;
        }
        
        video {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .pfp-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        
        .participant-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 400px));
            justify-content: center;
            gap: 1rem;
            width: 100%;
            padding: 1rem;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        @media (min-width: 1024px) {
            .participant-grid {
                grid-template-columns: repeat(auto-fit, minmax(300px, 400px));
            }
        }
        
        @media (max-width: 640px) {
            .participant-grid {
                grid-template-columns: 1fr;
                padding: 0.75rem;
            }
            .video-tile {
                max-width: 100%;
            }
        }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-900 dark:text-white min-h-screen flex flex-col font-display">
    <header class="w-full border-b border-slate-200 dark:border-slate-800 px-4 sm:px-6 py-3 sm:py-4 flex items-center justify-between bg-background-light dark:bg-background-dark z-10">
        <div class="flex items-center gap-3 sm:gap-4 flex-1 min-w-0">
            <div class="bg-primary/20 p-1.5 sm:p-2 rounded-lg flex-shrink-0">
                <span class="material-symbols-outlined text-primary text-lg sm:text-2xl" id="callIcon">videocam</span>
            </div>
            <div class="min-w-0">
                <h1 class="text-sm sm:text-lg font-bold tracking-tight truncate" id="callTitle">Video Call</h1>
                <p class="text-[10px] sm:text-xs text-slate-500 dark:text-slate-400 truncate" id="callSubtitle">Connecting...</p>
            </div>
        </div>
        <div class="flex items-center gap-2 sm:gap-3 flex-shrink-0">
            <div class="flex items-center gap-1.5 sm:gap-2 bg-slate-200 dark:bg-surface-dark px-2 sm:px-4 py-1.5 sm:py-2 rounded-lg sm:rounded-xl border border-slate-300 dark:border-slate-700">
                <span class="relative flex h-2 w-2">
                    <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-primary opacity-75"></span>
                    <span class="relative inline-flex rounded-full h-2 w-2 bg-primary"></span>
                </span>
                <span class="text-[10px] sm:text-sm font-bold font-mono" id="callDuration">00:00:00</span>
            </div>
        </div>
    </header>

    <main class="flex-1 overflow-y-auto">
        <div id="participantGrid" class="participant-grid"></div>
    </main>

    <footer class="w-full px-3 sm:px-6 py-3 sm:py-4 flex justify-center sticky bottom-0 z-20">
        <div class="bg-white/95 dark:bg-surface-dark/95 backdrop-blur-lg shadow-2xl rounded-xl sm:rounded-2xl border border-slate-200 dark:border-slate-800 p-2 sm:p-2.5 flex items-center gap-1 sm:gap-2">
            <div class="flex items-center gap-1 sm:gap-2 px-1 sm:px-2 border-r border-slate-200 dark:border-slate-800">
                <button id="micBtn" class="w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-primary text-white hover:brightness-110 transition-all active:scale-95">
                    <span class="material-symbols-outlined text-lg sm:text-2xl">mic</span>
                </button>
                <button id="videoBtn" class="w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-slate-200 dark:bg-background-dark text-slate-700 dark:text-white hover:bg-slate-300 dark:hover:bg-slate-800 transition-all">
                    <span class="material-symbols-outlined text-lg sm:text-2xl">videocam_off</span>
                </button>
            </div>
            
            <div class="hidden sm:flex items-center gap-2 px-2">
                <button id="moodBtn" class="flex items-center gap-1.5 sm:gap-2 px-3 sm:px-4 h-10 sm:h-12 rounded-lg sm:rounded-xl bg-slate-100 dark:bg-background-dark text-slate-700 dark:text-white border border-slate-200 dark:border-slate-700 hover:border-primary transition-all text-xs sm:text-sm">
                    <span class="text-base sm:text-xl">üòä</span>
                    <span class="font-bold hidden md:inline">Update Mood</span>
                </button>
            </div>
            
            <div class="pl-1 sm:pl-2 border-l border-slate-200 dark:border-slate-800">
                <button id="leaveCallBtn" class="flex items-center gap-1.5 sm:gap-2 px-4 sm:px-6 h-10 sm:h-12 rounded-lg sm:rounded-xl bg-accent-red text-white hover:brightness-110 transition-all active:scale-95">
                    <span class="material-symbols-outlined font-bold text-lg sm:text-2xl">call_end</span>
                    <span class="font-bold text-xs sm:text-sm">Leave</span>
                </button>
            </div>
        </div>
    </footer>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };
      if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="app.js"></script>

    <script>
    (async () => {
      const MoodApp = window.MoodApp || {};
      const _Auth = MoodApp.Auth;
      const _API = MoodApp.API;
      const _Toast = MoodApp.Toast;
      const toast = (m, t='success') => { 
        if (_Toast && typeof _Toast[t] === 'function') return _Toast[t](m); 
        console[t==='error'?'error':'log'](m); 
      };

      let ICE_SERVERS = null;
      async function fetchIceServers() {
        try {
          const response = await _API.get('/api/ice-servers');
          ICE_SERVERS = response.iceServers;
          console.log(`‚úÖ ICE servers loaded`);
          return ICE_SERVERS;
        } catch (error) {
          console.error('‚ùå ICE servers failed:', error);
          ICE_SERVERS = [{ urls: ['stun:stun.cloudflare.com:3478', 'stun:stun.l.google.com:19302'] }];
          return ICE_SERVERS;
        }
      }

      const PEER_CONNECTION_CONFIG = { iceCandidatePoolSize: 10, iceTransportPolicy: 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' };
      let localStream = null, peerConnections = new Map(), audioContexts = new Map(), socketInstance = null;
      let callData = null, currentUser = null, isAudioEnabled = true, isVideoEnabled = false;
      let callStartTime = null, durationInterval = null, isInitializing = false, hasJoinedCall = false;
      let pendingIceCandidates = new Map(), connectionStats = new Map();
      let renderedParticipants = new Set(); // CRITICAL FIX: Track rendered participants

      function createProfilePicture(pfpUrl, username) {
        const initial = username ? username.charAt(0).toUpperCase() : 'U';
        const div = document.createElement('div');
        div.className = 'w-16 h-16 sm:w-20 sm:h-20 rounded-full overflow-hidden bg-slate-100 dark:bg-slate-800 border-2 border-primary/30';
        if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
          const img = document.createElement('img');
          img.src = pfpUrl;
          img.alt = username;
          img.className = 'w-full h-full object-cover';
          img.onerror = () => { div.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-xl sm:text-2xl">${initial}</div>`; };
          div.appendChild(img);
        } else {
          div.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-xl sm:text-2xl">${initial}</div>`;
        }
        return div;
      }

      function createParticipantTile(user, isSelf = false) {
        console.log(`üé® Creating tile for ${user.username} (userId: ${user.userId}, isSelf: ${isSelf})`);
        
        // CRITICAL: Check if already rendered
        if (renderedParticipants.has(user.userId)) {
          console.warn(`‚ö†Ô∏è Tile for ${user.userId} already exists! Skipping.`);
          return null;
        }
        
        const tile = document.createElement('div');
        tile.id = `participant-${user.userId}`;
        tile.className = `video-tile ${isSelf ? 'border-2 border-dashed border-primary/30' : 'border border-white/5'}`;
        
        const videoContainer = document.createElement('div');
        videoContainer.className = 'video-container';
        
        const video = document.createElement('video');
        video.id = `video-${user.userId}`;
        video.className = 'hidden';
        video.autoplay = true;
        video.playsInline = true;
        if (isSelf) video.muted = true;
        videoContainer.appendChild(video);
        
        const pfpOverlay = document.createElement('div');
        pfpOverlay.id = `pfp-${user.userId}`;
        pfpOverlay.className = 'pfp-overlay';
        pfpOverlay.appendChild(createProfilePicture(user.pfpUrl, user.username));
        videoContainer.appendChild(pfpOverlay);
        
        tile.appendChild(videoContainer);
        
        const label = document.createElement('div');
        label.className = 'absolute bottom-3 sm:bottom-4 left-3 sm:left-4 z-10';
        label.innerHTML = `<div class="${isSelf ? 'bg-primary/80' : 'bg-black/60'} backdrop-blur-md px-2 sm:px-3 py-1 sm:py-1.5 rounded-full border ${isSelf ? 'border-primary/20' : 'border-white/10'} flex items-center gap-1.5 sm:gap-2">
          <span class="text-white text-xs sm:text-sm font-semibold">${isSelf ? 'You' : user.username}</span>
          <span class="text-base sm:text-lg">üòä</span>
        </div>`;
        tile.appendChild(label);
        
        const speaking = document.createElement('div');
        speaking.id = `speaking-${user.userId}`;
        speaking.className = 'absolute top-3 sm:top-4 right-3 sm:right-4 bg-primary px-1.5 sm:px-2 py-0.5 rounded text-[9px] sm:text-[10px] font-bold text-white uppercase hidden z-10';
        speaking.textContent = 'SPEAKING';
        tile.appendChild(speaking);
        
        const micOff = document.createElement('div');
        micOff.id = `mic-${user.userId}`;
        micOff.className = 'absolute top-3 sm:top-4 right-3 sm:right-4 bg-accent-red p-1 sm:p-1.5 rounded-full text-white shadow-lg hidden z-10';
        micOff.innerHTML = '<span class="material-symbols-outlined text-[14px] sm:text-[16px]">mic_off</span>';
        tile.appendChild(micOff);
        
        if (isSelf) {
          const overlay = document.createElement('div');
          overlay.className = 'absolute inset-0 bg-primary/5 pointer-events-none';
          tile.appendChild(overlay);
        }
        
        renderedParticipants.add(user.userId); // Mark as rendered
        console.log(`‚úÖ Tile created for ${user.username} (${user.userId})`);
        return tile;
      }

      function setupAudioDetection(userId, stream) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          const analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          source.connect(analyser);
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          let isSpeaking = false, lastSpeakTime = 0;
          
          function detect() {
            const speaking = document.getElementById(`speaking-${userId}`);
            const tile = document.getElementById(`participant-${userId}`);
            if (!speaking || !tile) { audioContext.close(); return; }
            
            analyser.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a,b)=>a+b) / dataArray.length;
            const now = Date.now();
            
            if (avg > 30) {
              if (!isSpeaking) {
                isSpeaking = true;
                speaking.classList.remove('hidden');
                tile.classList.add('active-speaker');
                if (socketInstance && userId === currentUser.userId) {
                  socketInstance.emit('speaking_state', { callId: callData.callId, speaking: true });
                }
              }
              lastSpeakTime = now;
            } else if (isSpeaking && now - lastSpeakTime > 300) {
              isSpeaking = false;
              speaking.classList.add('hidden');
              tile.classList.remove('active-speaker');
              if (socketInstance && userId === currentUser.userId) {
                socketInstance.emit('speaking_state', { callId: callData.callId, speaking: false });
              }
            }
            requestAnimationFrame(detect);
          }
          detect();
          audioContexts.set(userId, audioContext);
        } catch (e) { console.error('Audio detection error:', e); }
      }

      async function initLocalMedia() {
        try {
          console.log(`üé• Requesting media (${callData.callType})...`);
          const constraints = {
            audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
            video: callData.callType === 'video' ? { width: {ideal:640}, height: {ideal:480} } : false
          };
          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          console.log(`‚úÖ Media initialized`);
          
          isVideoEnabled = callData.callType === 'video';
          isAudioEnabled = true;
          
          const audio = localStream.getAudioTracks()[0];
          if (audio) setupAudioDetection(currentUser.userId, localStream);
          
          const callIcon = document.getElementById('callIcon');
          if (callIcon) callIcon.textContent = callData.callType === 'video' ? 'videocam' : 'graphic_eq';
          
          if (isVideoEnabled) {
            const vid = document.getElementById(`video-${currentUser.userId}`);
            const pfp = document.getElementById(`pfp-${currentUser.userId}`);
            if (vid && localStream) {
              vid.srcObject = localStream;
              await vid.play().catch(e => console.warn('Play:', e));
              vid.classList.remove('hidden');
              if (pfp) pfp.classList.add('hidden');
              console.log(`üìπ Local video showing for ${currentUser.username}`);
            }
            const btn = document.getElementById('videoBtn');
            const icon = btn.querySelector('.material-symbols-outlined');
            btn.classList.add('bg-primary', 'text-white');
            btn.classList.remove('bg-slate-200', 'dark:bg-background-dark');
            icon.textContent = 'videocam';
          }
          return localStream;
        } catch (e) {
          console.error('‚ùå Media error:', e);
          toast('Failed to access camera/microphone', 'error');
          throw e;
        }
      }

      function createPC(userId) {
        console.log(`üîó Creating PC for ${userId}`);
        const pc = new RTCPeerConnection({ ...PEER_CONNECTION_CONFIG, iceServers: ICE_SERVERS });
        connectionStats.set(userId, { startTime: Date.now(), iceState: 'new', connectionState: 'new', candidatesReceived: 0, candidatesSent: 0 });
        
        if (localStream) {
          localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
            console.log(`‚ûï Added ${track.kind} to ${userId}`);
          });
        }
        
        pc.ontrack = (e) => {
          console.log(`üì• Track ${e.track.kind} from ${userId}`);
          const vid = document.getElementById(`video-${userId}`);
          const pfp = document.getElementById(`pfp-${userId}`);
          
          if (vid) {
            if (!vid.srcObject) vid.srcObject = new MediaStream();
            vid.srcObject.addTrack(e.track);
            
            if (e.track.kind === 'video') {
              vid.play().catch(e => console.warn('Play:', e));
              e.track.onunmute = () => {
                console.log(`üìπ Video unmuted ${userId} - showing video`);
                vid.classList.remove('hidden');
                if (pfp) pfp.classList.add('hidden');
              };
              e.track.onmute = () => {
                console.log(`üìπ Video muted ${userId} - showing pfp`);
                vid.classList.add('hidden');
                if (pfp) pfp.classList.remove('hidden');
              };
              e.track.onended = () => {
                console.log(`üìπ Video ended ${userId} - showing pfp`);
                vid.classList.add('hidden');
                if (pfp) pfp.classList.remove('hidden');
              };
            } else if (e.track.kind === 'audio') {
              vid.play().catch(e => console.warn('Play:', e));
              setupAudioDetection(userId, new MediaStream([e.track]));
            }
          }
        };
        
        pc.onicecandidate = (e) => {
          if (e.candidate) {
            connectionStats.get(userId).candidatesSent++;
            socketInstance.emit('ice_candidate', { callId: callData.callId, targetUserId: userId, candidate: e.candidate });
          }
        };
        
        pc.oniceconnectionstatechange = () => {
          connectionStats.get(userId).iceState = pc.iceConnectionState;
          if (pc.iceConnectionState === 'failed') pc.restartIce();
        };
        
        pc.onconnectionstatechange = () => {
          const state = pc.connectionState;
          connectionStats.get(userId).connectionState = state;
          console.log(`üîå ${userId}: ${state}`);
          
          const subtitle = document.getElementById('callSubtitle');
          if (state === 'connected') {
            const count = Array.from(connectionStats.values()).filter(s => s.connectionState === 'connected').length + 1;
            if (subtitle) subtitle.textContent = `${count} participant${count>1?'s':''} connected`;
            
            pc.getStats().then(stats => {
              stats.forEach(r => {
                if (r.type === 'candidate-pair' && r.state === 'succeeded') {
                  const local = stats.get(r.localCandidateId);
                  if (local) {
                    console.log(`‚úÖ Using ${local.candidateType} for ${userId}`);
                    socketInstance.emit('connection_state_update', { callId: callData.callId, state: 'connected', candidateType: local.candidateType });
                  }
                }
              });
            });
          } else if (state === 'failed') {
            setTimeout(() => { if (pc.connectionState === 'failed') pc.restartIce(); }, 1000);
          }
        };
        
        peerConnections.set(userId, pc);
        return pc;
      }

      async function createOffer(userId) {
        try {
          console.log(`üì§ Creating offer for ${userId}`);
          const pc = createPC(userId);
          const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
          await pc.setLocalDescription(offer);
          socketInstance.emit('webrtc_offer', { callId: callData.callId, targetUserId: userId, offer });
        } catch (e) { console.error('Offer error:', e); }
      }

      async function handleOffer(fromUserId, offer) {
        try {
          console.log(`üì• Offer from ${fromUserId}`);
          const pc = createPC(fromUserId);
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          
          if (pendingIceCandidates.has(fromUserId)) {
            const cands = pendingIceCandidates.get(fromUserId);
            for (const c of cands) await pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{});
            pendingIceCandidates.delete(fromUserId);
          }
          
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socketInstance.emit('webrtc_answer', { callId: callData.callId, targetUserId: fromUserId, answer });
        } catch (e) { console.error('Handle offer error:', e); }
      }

      async function handleAnswer(fromUserId, answer) {
        try {
          const pc = peerConnections.get(fromUserId);
          if (pc && pc.signalingState !== 'stable') {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
            if (pendingIceCandidates.has(fromUserId)) {
              const cands = pendingIceCandidates.get(fromUserId);
              for (const c of cands) await pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{});
              pendingIceCandidates.delete(fromUserId);
            }
          }
        } catch (e) { console.error('Handle answer error:', e); }
      }

      async function handleIceCandidate(fromUserId, candidate) {
        try {
          const pc = peerConnections.get(fromUserId);
          if (pc && pc.remoteDescription) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            connectionStats.get(fromUserId).candidatesReceived++;
          } else {
            if (!pendingIceCandidates.has(fromUserId)) pendingIceCandidates.set(fromUserId, []);
            pendingIceCandidates.get(fromUserId).push(candidate);
          }
        } catch (e) { console.error('ICE error:', e); }
      }

      function toggleMic() {
        if (localStream) {
          const track = localStream.getAudioTracks()[0];
          if (track) {
            track.enabled = !track.enabled;
            isAudioEnabled = track.enabled;
            const btn = document.getElementById('micBtn');
            const icon = btn.querySelector('.material-symbols-outlined');
            const mic = document.getElementById(`mic-${currentUser.userId}`);
            if (isAudioEnabled) {
              btn.classList.add('bg-primary', 'text-white');
              btn.classList.remove('bg-accent-red');
              icon.textContent = 'mic';
              if (mic) mic.classList.add('hidden');
            } else {
              btn.classList.remove('bg-primary');
              btn.classList.add('bg-accent-red', 'text-white');
              icon.textContent = 'mic_off';
              if (mic) mic.classList.remove('hidden');
            }
            socketInstance.emit('audio_state_changed', { callId: callData.callId, enabled: isAudioEnabled });
          }
        }
      }

      async function toggleVideo() {
        if (callData.callType === 'audio') { toast('Video not available in audio call', 'warning'); return; }
        if (localStream) {
          const track = localStream.getVideoTracks()[0];
          if (track) {
            track.enabled = !track.enabled;
            isVideoEnabled = track.enabled;
            const btn = document.getElementById('videoBtn');
            const icon = btn.querySelector('.material-symbols-outlined');
            const vid = document.getElementById(`video-${currentUser.userId}`);
            const pfp = document.getElementById(`pfp-${currentUser.userId}`);
            if (isVideoEnabled) {
              btn.classList.add('bg-primary', 'text-white');
              btn.classList.remove('bg-slate-200', 'dark:bg-background-dark');
              icon.textContent = 'videocam';
              if (vid) vid.classList.remove('hidden');
              if (pfp) pfp.classList.add('hidden');
            } else {
              btn.classList.remove('bg-primary', 'text-white');
              btn.classList.add('bg-slate-200', 'dark:bg-background-dark');
              icon.textContent = 'videocam_off';
              if (vid) vid.classList.add('hidden');
              if (pfp) pfp.classList.remove('hidden');
            }
            socketInstance.emit('video_state_changed', { callId: callData.callId, enabled: isVideoEnabled });
          }
        }
      }

      function updateDuration() {
        if (!callStartTime) return;
        const e = Math.floor((Date.now() - callStartTime) / 1000);
        const h = Math.floor(e / 3600), m = Math.floor((e % 3600) / 60), s = e % 60;
        const el = document.getElementById('callDuration');
        if (el) el.textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
      }

      function leaveCall() {
        if (isInitializing) return;
        isInitializing = true;
        audioContexts.forEach(c => c.close());
        audioContexts.clear();
        if (localStream) localStream.getTracks().forEach(t => t.stop());
        peerConnections.forEach(pc => pc.close());
        peerConnections.clear();
        if (socketInstance && socketInstance.connected) socketInstance.emit('leave_call', { callId: callData.callId });
        if (durationInterval) clearInterval(durationInterval);
        localStorage.removeItem('activeCall');
        setTimeout(() => { window.location.href = '/chat.html'; }, 500);
      }

      async function initCall() {
        if (isInitializing) return;
        isInitializing = true;
        console.log('=== INIT CALL ===');
        
        try {
          await _Auth.requireAuth();
          await fetchIceServers();
          
          const callStr = localStorage.getItem('activeCall');
          if (!callStr) { toast('No active call', 'error'); setTimeout(() => window.location.href = '/chat.html', 1500); return; }
          
          callData = JSON.parse(callStr);
          console.log(`üìû Call: ${callData.callId} (${callData.callType})`);
          
          const firebaseUser = firebase.auth().currentUser;
          if (!firebaseUser) { window.location.href = '/login.html'; return; }
          
          const userData = await _API.get('/api/users/me');
          currentUser = { userId: userData._id, username: userData.username, pfpUrl: userData.pfpUrl };
          console.log(`üë§ Current user: ${currentUser.username} (${currentUser.userId})`);
          
          const title = document.getElementById('callTitle');
          if (title) title.textContent = `${callData.callType === 'video' ? 'Video' : 'Audio'} Call`;
          
          const token = await firebaseUser.getIdToken();
          socketInstance = io(window.location.origin, {
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            auth: { token }
          });
          
          socketInstance.on('connect', () => {
            console.log(`üîå Connected: ${socketInstance.id}`);
            socketInstance.emit('authenticate', { token, userId: currentUser.userId });
          });
          
          socketInstance.on('authenticated', async () => {
            console.log('‚úÖ Authenticated');
            if (!hasJoinedCall) {
              hasJoinedCall = true;
              socketInstance.emit('join_call', { callId: callData.callId });
            }
          });
          
          socketInstance.on('call_joined', async (data) => {
            console.log(`‚úÖ Joined: ${data.participants.length} participants`);
            console.log('Participants:', data.participants.map(p => `${p.username} (${p.userId})`).join(', '));
            
            const subtitle = document.getElementById('callSubtitle');
            if (subtitle) subtitle.textContent = `${data.participants.length} participant${data.participants.length>1?'s':''}`;
            
            await initLocalMedia();
            
            const grid = document.getElementById('participantGrid');
            if (grid) {
              grid.innerHTML = ''; // Clear grid
              renderedParticipants.clear(); // Clear tracking
              console.log(`üìã Rendering ${data.participants.length} tiles`);
              
              data.participants.forEach((p, index) => {
                const isSelf = p.userId === currentUser.userId;
                console.log(`[${index}] Creating tile for ${p.username} (${p.userId}) isSelf=${isSelf}`);
                const tile = createParticipantTile(p, isSelf);
                if (tile) {
                  grid.appendChild(tile);
                  console.log(`‚úÖ [${index}] Tile added to grid for ${p.username}`);
                } else {
                  console.error(`‚ùå [${index}] Tile creation returned null for ${p.username}`);
                }
                
                if (!isSelf) {
                  setTimeout(() => createOffer(p.userId), 500);
                }
              });
              
              console.log(`üé® Grid now has ${grid.children.length} children (expected: ${data.participants.length})`);
              console.log(`üìä Rendered participants:`, Array.from(renderedParticipants));
            }
            
            callStartTime = Date.now();
            durationInterval = setInterval(updateDuration, 1000);
            isInitializing = false;
            console.log('=== INIT COMPLETE ===');
          });
          
          socketInstance.on('user_joined_call', (data) => {
            console.log(`üëã User joined: ${data.user.username} (${data.user.userId})`);
            const grid = document.getElementById('participantGrid');
            if (grid && !document.getElementById(`participant-${data.user.userId}`)) {
              const tile = createParticipantTile(data.user, false);
              if (tile) {
                grid.appendChild(tile);
                setTimeout(() => createOffer(data.user.userId), 500);
              }
            }
          });
          
          socketInstance.on('user_left_call', (data) => {
            console.log(`üëã User left: ${data.userId}`);
            const tile = document.getElementById(`participant-${data.userId}`);
            if (tile) tile.remove();
            renderedParticipants.delete(data.userId);
            const pc = peerConnections.get(data.userId);
            if (pc) { pc.close(); peerConnections.delete(data.userId); }
            const ac = audioContexts.get(data.userId);
            if (ac) { ac.close(); audioContexts.delete(data.userId); }
            connectionStats.delete(data.userId);
            pendingIceCandidates.delete(data.userId);
          });
          
          socketInstance.on('webrtc_offer', (d) => handleOffer(d.fromUserId, d.offer));
          socketInstance.on('webrtc_answer', (d) => handleAnswer(d.fromUserId, d.answer));
          socketInstance.on('ice_candidate', (d) => handleIceCandidate(d.fromUserId, d.candidate));
          
          socketInstance.on('speaking_state', (d) => {
            const s = document.getElementById(`speaking-${d.userId}`);
            const t = document.getElementById(`participant-${d.userId}`);
            if (s && t) {
              if (d.speaking) { s.classList.remove('hidden'); t.classList.add('active-speaker'); }
              else { s.classList.add('hidden'); t.classList.remove('active-speaker'); }
            }
          });
          
          socketInstance.on('audio_state_changed', (d) => {
            const m = document.getElementById(`mic-${d.userId}`);
            if (m) d.enabled ? m.classList.add('hidden') : m.classList.remove('hidden');
          });
          
          socketInstance.on('video_state_changed', (d) => {
            const v = document.getElementById(`video-${d.userId}`);
            const p = document.getElementById(`pfp-${d.userId}`);
            if (v && p) {
              if (!d.enabled) { v.classList.add('hidden'); p.classList.remove('hidden'); }
            }
          });
          
          socketInstance.on('call_ended', () => { toast('Call ended', 'warning'); leaveCall(); });
          
          const mic = document.getElementById('micBtn');
          const vid = document.getElementById('videoBtn');
          const leave = document.getElementById('leaveCallBtn');
          if (mic) mic.addEventListener('click', toggleMic);
          if (vid) vid.addEventListener('click', toggleVideo);
          if (leave) leave.addEventListener('click', leaveCall);
          window.addEventListener('beforeunload', () => leaveCall());
          
        } catch (e) {
          console.error('‚ùå Init error:', e);
          toast('Failed to initialize call', 'error');
          isInitializing = false;
          setTimeout(() => window.location.href = '/chat.html', 2000);
        }
      }

      console.log('‚úÖ Page loaded - starting initialization');
      initCall();
    })();
    </script>
</body>
</html>
