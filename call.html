<!DOCTYPE html>
<html lang="en" class="dark">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Active Call - MoodLog</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap"
    rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
  <script id="tailwind-config">
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            "primary": "#33bfcc",
            "background-light": "#f2f2f3",
            "background-dark": "#121417",
            "surface-dark": "#1e2124",
            "accent-red": "#ef4444",
          },
          fontFamily: {
            "display": ["Manrope", "sans-serif"]
          }
        },
      },
    }
  </script>
  <style>
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }

    .active-speaker {
      box-shadow: 0 0 0 3px #33bfcc, 0 0 15px rgba(51, 191, 204, 0.4) !important;
      border-color: #33bfcc !important;
    }

    body {
      font-family: 'Manrope', sans-serif;
      overscroll-behavior: none;
    }

    .video-tile {
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;
      max-width: 400px;
      background: #000;
      overflow: hidden;
      border-radius: 1rem;
    }

    .video-container {
      position: absolute;
      inset: 0;
    }

    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .pfp-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
    }

    .participant-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 400px));
      justify-content: center;
      gap: 1rem;
      width: 100%;
      padding: 1rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    @media (min-width: 1024px) {
      .participant-grid {
        grid-template-columns: repeat(auto-fit, minmax(300px, 400px));
      }
    }

    @media (max-width: 640px) {
      .participant-grid {
        grid-template-columns: 1fr;
        padding: 0.75rem;
      }

      .video-tile {
        max-width: 100%;
      }
    }


    #chatContainer {
      animation: slideInFromBottom 0.3s ease-out;
    }

    @keyframes slideInFromBottom {
      from {
        transform: translateY(100%);
      }

      to {
        transform: translateY(0);
      }
    }

    #miniCallIndicator {
      animation: slideInFromRight 0.3s ease-out;
    }

    @keyframes slideInFromRight {
      from {
        opacity: 0;
        transform: translateX(100px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes bounce-slow {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-10px);
      }
    }

    .animate-bounce-slow {
      animation: bounce-slow 2s ease-in-out infinite;
    }
  </style>
</head>

<body
  class="bg-background-light dark:bg-background-dark text-slate-900 dark:text-white min-h-screen flex flex-col font-display">
  <header
    class="w-full border-b border-slate-200 dark:border-slate-800 px-4 sm:px-6 py-3 sm:py-4 flex items-center justify-between bg-background-light dark:bg-background-dark z-10">
    <div class="flex items-center gap-3 sm:gap-4 flex-1 min-w-0">
      <div class="bg-primary/20 p-1.5 sm:p-2 rounded-lg flex-shrink-0">
        <span class="material-symbols-outlined text-primary text-lg sm:text-2xl" id="callIcon">videocam</span>
      </div>
      <div class="min-w-0">
        <h1 class="text-sm sm:text-lg font-bold tracking-tight truncate" id="callTitle">Video Call</h1>
        <p class="text-[10px] sm:text-xs text-slate-500 dark:text-slate-400 truncate" id="callSubtitle">Connecting...
        </p>
      </div>
    </div>
    <div class="flex items-center gap-2 sm:gap-3 flex-shrink-0">
      <div
        class="flex items-center gap-1.5 sm:gap-2 bg-slate-200 dark:bg-surface-dark px-2 sm:px-4 py-1.5 sm:py-2 rounded-lg sm:rounded-xl border border-slate-300 dark:border-slate-700">
        <span class="relative flex h-2 w-2">
          <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-primary opacity-75"></span>
          <span class="relative inline-flex rounded-full h-2 w-2 bg-primary"></span>
        </span>
        <span class="text-[10px] sm:text-sm font-bold font-mono" id="callDuration">00:00:00</span>
      </div>
    </div>
  </header>

  <main class="flex-1 overflow-y-auto">
    <div id="participantGrid" class="participant-grid"></div>
  </main>

  <footer class="w-full px-3 sm:px-6 py-3 sm:py-4 flex justify-center sticky bottom-0 z-20">
    <div
      class="bg-white/95 dark:bg-surface-dark/95 backdrop-blur-lg shadow-2xl rounded-xl sm:rounded-2xl border border-slate-200 dark:border-slate-800 p-2 sm:p-2.5 flex items-center gap-1 sm:gap-2">
      <div class="flex items-center gap-1 sm:gap-2 px-1 sm:px-2 border-r border-slate-200 dark:border-slate-800">
        <button id="micBtn"
          class="w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-primary text-white hover:brightness-110 transition-all active:scale-95">
          <span class="material-symbols-outlined text-lg sm:text-2xl">mic</span>
        </button>
        <button id="videoBtn"
          class="w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-slate-200 dark:bg-background-dark text-slate-700 dark:text-white hover:bg-slate-300 dark:hover:bg-slate-800 transition-all">
          <span class="material-symbols-outlined text-lg sm:text-2xl">videocam_off</span>
        </button>
      </div>

      <div class="hidden sm:flex items-center gap-2 px-2">
        <button id="moodBtn"
          class="flex items-center gap-1.5 sm:gap-2 px-3 sm:px-4 h-10 sm:h-12 rounded-lg sm:rounded-xl bg-slate-100 dark:bg-background-dark text-slate-700 dark:text-white border border-slate-200 dark:border-slate-700 hover:border-primary transition-all text-xs sm:text-sm">
          <span class="text-base sm:text-xl">üòä</span>
          <span class="font-bold hidden md:inline">Update Mood</span>
        </button>
      </div>

      <div class="pl-1 sm:pl-2 border-l border-slate-200 dark:border-slate-800">
        <button id="leaveCallBtn"
          class="flex items-center gap-1.5 sm:gap-2 px-4 sm:px-6 h-10 sm:h-12 rounded-lg sm:rounded-xl bg-accent-red text-white hover:brightness-110 transition-all active:scale-95">
          <span class="material-symbols-outlined font-bold text-lg sm:text-2xl">call_end</span>
          <span class="font-bold text-xs sm:text-sm">Leave</span>
        </button>
      </div>
    </div>
  </footer>

  <div id="chatOverlayContainer" class="hidden fixed inset-0 z-[9999] bg-white">
    <iframe id="chatOverlayIframe" class="w-full h-full border-none"></iframe>
  </div>

  <!-- Mini Call Indicator -->
  <!-- <button id="miniCallIndicator" class="hidden fixed bottom-20 right-4 z-[10000] bg-green-600 hover:bg-green-700 active:bg-green-800 text-white rounded-full p-4 shadow-2xl transition-all hover:scale-110 active:scale-95">
    <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-2xl">call</span>
        <span class="text-sm font-bold">Back to Call</span>
    </div>
</button> -->

  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
      authDomain: "projectt3-8c55e.firebaseapp.com",
      projectId: "projectt3-8c55e",
      storageBucket: "projectt3-8c55e.firebasestorage.app",
      messagingSenderId: "64611387728",
      appId: "1:64611387728:web:2e53a18151ab3de1b60455",
      measurementId: "G-0Z91D0Q6EE"
    };
    if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
    firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
  </script>
  <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
  <script src="app.js"></script>



  <script>
    (async () => {
      const MoodApp = window.MoodApp || {};
      const _Auth = MoodApp.Auth;
      const _API = MoodApp.API;
      const _Toast = MoodApp.Toast;
      const toast = (m, t = 'success') => {
        if (_Toast && typeof _Toast[t] === 'function') return _Toast[t](m);
        console[t === 'error' ? 'error' : 'log'](m);
      };



      let videoStateChangeTimeout = null;
      let isTogglingVideo = false;
      let isJoiningCall = false;

      let negotiationMutex = new Map(); // userId -> Promise to prevent duplicate offer handling
      let makingOffer = new Map();

      let ICE_SERVERS = null;
      let useTurnFallback = false; // Global flag for TURN fallback

      // ============================================
      // CALL CONNECTION STATE TRACKING
      // ============================================
      let callConnectionState = 'initializing'; // 'initializing', 'connecting', 'connected', 'failed'
      let hasEstablishedConnection = false;

      async function fetchIceServers() {
        try {
          // ‚úÖ Request STUN-only by default, TURN only if fallback enabled
          const endpoint = useTurnFallback
            ? '/api/ice-servers?includeTurn=true'
            : '/api/ice-servers';

          console.log(`üì° Fetching ICE servers: ${useTurnFallback ? 'TURN fallback mode' : 'STUN-only mode'}`);

          const response = await _API.get(endpoint);

          const stunServers = response.iceServers.filter(server =>
            server.urls.some(url => url.startsWith('stun:'))
          );

          const turnServers = response.iceServers.filter(server =>
            server.urls.some(url => url.startsWith('turn:') || url.startsWith('turns:'))
          );

          ICE_SERVERS = response.iceServers;

          console.log(`‚úÖ ICE servers loaded:`);
          console.log(`   - ${stunServers.length} STUN server group(s)`);
          console.log(`   - ${turnServers.length} TURN server group(s)`);

          if (turnServers.length === 0) {
            console.log(`   üí∞ Zero TURN usage - pure peer-to-peer mode`);
            console.log(`   üìä Cloudflare analytics should show 0 KB`);
          } else {
            console.warn(`   ‚ö†Ô∏è TURN enabled (fallback mode after connection failure)`);
          }

          return ICE_SERVERS;
        } catch (error) {
          console.error('‚ùå ICE servers failed:', error);
          ICE_SERVERS = [{ urls: ['stun:stun.cloudflare.com:3478', 'stun:stun.l.google.com:19302'] }];
          return ICE_SERVERS;
        }
      }


      const PEER_CONNECTION_CONFIG = {
        iceCandidatePoolSize: 10,
        iceTransportPolicy: 'all', // MUST be 'all' to try STUN first, NOT 'relay'
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        // Enable ICE restart for failed connections
        iceRestart: false
      };
      let localStream = null, peerConnections = new Map(), audioContexts = new Map(), socketInstance = null;
      let callData = null, currentUser = null, isAudioEnabled = true, isVideoEnabled = false;
      let durationInterval = null, isInitializing = false, hasJoinedCall = false;
      let pendingIceCandidates = new Map(), connectionStats = new Map();
      let renderedParticipants = new Set(); // CRITICAL FIX: Track rendered participants
      let isNavigatingToChat = false;
      let isInChatView = false;

      function setupCallBackButtonHandler() {
        console.log('üîô Setting up call page back button handler');

        // Set initial state
        history.pushState({ view: 'call' }, 'Call', window.location.href);


        // Listen for messages from chat iframe
        window.addEventListener('message', (event) => {
          console.log('üì® ========================================');
          console.log('üì® MESSAGE RECEIVED FROM IFRAME');
          console.log('üì® ========================================');
          console.log(`   action: ${event.data?.action}`);

          if (event.data && event.data.action === 'hideChat') {
            console.log('üí¨ Hiding chat overlay as requested by iframe');
            hideChat();
            history.pushState({ view: 'call' }, 'Call', window.location.href);
          }

          console.log('üì® ========================================\n');
        });

        console.log('‚úÖ Message listener added for iframe communication');

        window.addEventListener('popstate', (event) => {
          console.log('‚¨ÖÔ∏è ========================================');
          console.log('‚¨ÖÔ∏è BACK BUTTON PRESSED');
          console.log('‚¨ÖÔ∏è ========================================');

          const chatOverlay = document.getElementById('chatOverlayContainer');
          const isShowingChat = chatOverlay && !chatOverlay.classList.contains('hidden');

          console.log(`   Currently showing: ${isShowingChat ? 'chat overlay' : 'call UI'}`);
          console.log(`   Call state: ${callConnectionState}`);
          console.log(`   Has callData: ${!!callData}`);

          if (isShowingChat) {
            // Hide chat, show call
            console.log('üìû Hiding chat, showing call');
            hideChat();
            history.pushState({ view: 'call' }, 'Call', window.location.href);
          } else {
            // CRITICAL: If call exists (even if connecting), show chat iframe instead of navigating away
            if (!callData) {
              console.log('‚ö†Ô∏è No active call - allowing navigation to chat.html');
              window.location.href = '/chat.html';
              return;
            }

            // Call exists (initializing, connecting, or connected) - keep page alive, show chat iframe
            console.log('üí¨ Call active - hiding UI and showing chat iframe');
            console.log(`   Call state: ${callConnectionState}`);
            console.log(`   This keeps the connection process running in background`);
            console.log(`   Active peer connections: ${peerConnections.size}`);
            console.log(`   Local stream: ${localStream ? 'exists' : 'pending'}`);

            showChat();
            history.pushState({ view: 'chat' }, 'Chat', window.location.href);
          }

          console.log('‚¨ÖÔ∏è ========================================\n');
        });
      }

      function showChat() {
        console.log('üí¨ ========================================');
        console.log('üí¨ SHOWING CHAT OVERLAY');
        console.log('üí¨ ========================================');

        // Hide call UI elements
        const header = document.querySelector('header');
        const main = document.querySelector('main');
        const footer = document.querySelector('footer');

        if (header) header.style.display = 'none';
        if (main) main.style.display = 'none';
        if (footer) footer.style.display = 'none';

        // Show chat overlay
        const chatOverlay = document.getElementById('chatOverlayContainer');
        const chatIframe = document.getElementById('chatOverlayIframe');
        const miniIndicator = document.getElementById('miniCallIndicator');

        if (chatOverlay) {
          chatOverlay.classList.remove('hidden');

          // Load chat page in iframe
          if (chatIframe) {
            chatIframe.src = '/chat.html';
            console.log('‚úÖ Chat iframe loaded');
          }
        }

        // Show mini indicator
        if (miniIndicator) {
          miniIndicator.classList.remove('hidden');
          miniIndicator.onclick = () => {
            console.log('üîô Mini indicator clicked');
            hideChat();
            history.pushState({ view: 'call' }, 'Call', window.location.href);
          };
        }

        console.log('‚úÖ Chat overlay shown - call remains active');
        console.log(`   PeerConnections: ${peerConnections.size}`);
        console.log(`   LocalStream: ${localStream?.getTracks().length} tracks`);
        console.log('üí¨ ========================================\n');
      }

      function hideChat() {
        console.log('üìû ========================================');
        console.log('üìû HIDING CHAT OVERLAY');
        console.log('üìû ========================================');

        // Hide chat overlay
        const chatOverlay = document.getElementById('chatOverlayContainer');
        const miniIndicator = document.getElementById('miniCallIndicator');

        if (chatOverlay) chatOverlay.classList.add('hidden');
        if (miniIndicator) miniIndicator.classList.add('hidden');

        // CRITICAL: Also hide the floating button that might be in the parent window
        try {
          if (window.parent && window.parent !== window) {
            const parentFloatingBtn = window.parent.document.getElementById('floatingReturnToCall');
            if (parentFloatingBtn) {
              parentFloatingBtn.classList.add('hidden');
              console.log('‚úÖ Parent floating button hidden');
            }
          }
        } catch (e) {
          console.warn('‚ö†Ô∏è Could not access parent window:', e);
        }

        // Show call UI elements
        const header = document.querySelector('header');
        const main = document.querySelector('main');
        const footer = document.querySelector('footer');

        if (header) header.style.display = '';
        if (main) main.style.display = '';
        if (footer) footer.style.display = '';

        console.log('‚úÖ Call UI restored - connections still active');
        console.log(`   PeerConnections: ${peerConnections.size}`);
        console.log(`   LocalStream: ${localStream?.getTracks().length} tracks`);
        console.log('üìû ========================================\n');
      }

      function showChatView() {
        console.log('üí¨ ========================================');
        console.log('üí¨ SHOWING CHAT VIEW');
        console.log('üí¨ ========================================');

        isInChatView = true;

        // CRITICAL: Navigate to actual chat page while keeping call alive
        // Save that we have background call
        sessionStorage.setItem('hasBackgroundCall', 'true');

        console.log('‚úÖ Navigating to chat with background call');
        console.log(`   PeerConnections: ${peerConnections.size} (will remain connected)`);
        console.log(`   LocalStream: ${localStream?.getTracks().length} tracks (will remain active)`);

        // Navigate to chat page
        window.location.href = '/chat.html';

        console.log('üí¨ ========================================\n');
      }


      function showCallView() {
        console.log('üìû ========================================');
        console.log('üìû SHOWING CALL VIEW');
        console.log('üìû ========================================');

        isInChatView = false;

        // Get all main elements
        const header = document.querySelector('header');
        const main = document.querySelector('main');
        const footer = document.querySelector('footer');
        const miniIndicator = document.getElementById('miniCallIndicator');

        // Show call UI
        if (header) header.style.display = '';
        if (main) main.style.display = '';
        if (footer) footer.style.display = '';

        // Hide mini indicator
        if (miniIndicator) miniIndicator.classList.add('hidden');

        // Clear session flags
        sessionStorage.removeItem('hasBackgroundCall');

        console.log('‚úÖ Call view restored');
        console.log(`   PeerConnections active: ${peerConnections.size}`);
        console.log(`   LocalStream active: ${localStream?.getTracks().length} tracks`);
        console.log('üìû ========================================\n');
      }

      function returnToCallView() {
        console.log('üîô ========================================');
        console.log('üîô RETURNING TO CALL VIEW (MAXIMIZING)');
        console.log('üîô ========================================');

        // CRITICAL: Mark that we're no longer navigating
        isNavigatingToChat = false;

        // Hide chat container
        const chatContainer = document.getElementById('chatContainer');
        const miniIndicator = document.getElementById('miniCallIndicator');

        if (chatContainer) chatContainer.classList.add('hidden');
        if (miniIndicator) miniIndicator.classList.add('hidden');

        // Show call UI elements
        const header = document.querySelector('header');
        const main = document.querySelector('main');
        const footer = document.querySelector('footer');

        if (header) header.style.display = '';
        if (main) main.style.display = '';
        if (footer) footer.style.display = '';

        // Clear session flags
        sessionStorage.removeItem('returningFromCall');
        sessionStorage.removeItem('backgroundCallMode');

        console.log('‚úÖ Call maximized - UI restored');
        console.log(`   PeerConnections still active: ${peerConnections.size}`);
        console.log(`   LocalStream still active: ${localStream?.getTracks().length || 0} tracks`);
        console.log('üîô ========================================\n');
      }

      function returnToCallView() {
        console.log('üîô Returning to call view');

        const chatContainer = document.getElementById('chatContainer');
        const miniIndicator = document.getElementById('miniCallIndicator');

        if (chatContainer) chatContainer.classList.add('hidden');
        if (miniIndicator) miniIndicator.classList.add('hidden');

        document.body.style.overflow = '';

        // Clear session flags
        sessionStorage.removeItem('returningFromCall');
        sessionStorage.removeItem('backgroundCallMode');

        console.log('‚úÖ Returned to call view');
      }

      function updateMiniCallIndicator() {
        const miniAvatar = document.getElementById('miniCallAvatar');

        if (miniAvatar && currentUser) {
          miniAvatar.innerHTML = '';
          const initial = currentUser.username?.charAt(0).toUpperCase() || 'U';
          miniAvatar.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-lg">${initial}</div>`;
        }

        // Update duration periodically
        setInterval(() => {
          const miniDuration = document.getElementById('miniCallDuration');
          const mainDuration = document.getElementById('callDuration');

          if (miniDuration && mainDuration) {
            miniDuration.textContent = mainDuration.textContent;
          }
        }, 1000);
      }

      // Fallback: Create iframe overlay for chat
      function showChatOverlay() {
        console.log('üé® Creating chat overlay on call page');

        // Create overlay container
        const overlay = document.createElement('div');
        overlay.id = 'chatOverlay';
        overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 9999;
    background: white;
  `;

        // Create iframe
        const iframe = document.createElement('iframe');
        iframe.src = '/chat.html';
        iframe.style.cssText = `
    width: 100%;
    height: 100%;
    border: none;
  `;

        // Create close button
        const closeBtn = document.createElement('button');
        closeBtn.innerHTML = '‚Üê Back to Call';
        closeBtn.style.cssText = `
    position: absolute;
    top: 1rem;
    left: 1rem;
    z-index: 10000;
    background: #367d7d;
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    border: none;
    font-weight: 600;
    cursor: pointer;
  `;

        closeBtn.onclick = () => {
          console.log('üîô Returning to call from overlay');
          document.body.removeChild(overlay);
          isNavigatingToChat = false;
        };

        overlay.appendChild(closeBtn);
        overlay.appendChild(iframe);
        document.body.appendChild(overlay);

        isNavigatingToChat = true;

        console.log('‚úÖ Chat overlay created');
      }

      function setupCallCleanup() {
        window.addEventListener('beforeunload', (e) => {
          console.log('üö™ ========================================');
          console.log('üö™ CALL PAGE BEFOREUNLOAD');
          console.log('üö™ ========================================');

          // Check if chat is showing (means we're not actually leaving)
          const chatOverlay = document.getElementById('chatOverlayContainer');
          const isShowingChat = chatOverlay && !chatOverlay.classList.contains('hidden');

          if (isShowingChat) {
            console.log('üîí Chat overlay active - NOT cleaning up');
            console.log('   This should not happen - preventing navigation');
            console.log('üö™ ========================================\n');
            return;
          }

          console.log('üóëÔ∏è Performing full cleanup');

          // Stop timer
          if (durationInterval) {
            clearInterval(durationInterval);
            console.log('   ‚úì Timer stopped');
          }

          // Close audio contexts
          audioContexts.forEach((ac, userId) => {
            try {
              if (ac.stop) ac.stop();
              if (ac.context && ac.context.state !== 'closed') {
                ac.context.close().catch(e => console.warn('Failed to close audio context:', e));
              }
            } catch (e) {
              console.warn(`Failed to cleanup audio context for ${userId}:`, e);
            }
          });
          audioContexts.clear();
          console.log('   ‚úì Audio contexts closed');

          // Stop local stream
          if (localStream) {
            localStream.getTracks().forEach(t => {
              try {
                t.stop();
              } catch (e) {
                console.warn('Failed to stop track:', e);
              }
            });
            console.log('   ‚úì Local stream stopped');
          }

          // Close peer connections
          peerConnections.forEach((pc, userId) => {
            try {
              pc.close();
            } catch (e) {
              console.warn(`Failed to close PC for ${userId}:`, e);
            }
          });
          peerConnections.clear();
          console.log('   ‚úì Peer connections closed');

          // Emit leave call
          if (socketInstance && socketInstance.connected) {
            socketInstance.emit('leave_call', { callId: callData.callId });
            console.log('   ‚úì Leave call emitted');
          }

          // Clear storage
          localStorage.removeItem('activeCall');

          console.log('‚úÖ Full cleanup complete');
          console.log('üö™ ========================================\n');
        });
      }

      function createProfilePicture(pfpUrl, username) {
        const initial = username ? username.charAt(0).toUpperCase() : 'U';
        const div = document.createElement('div');
        div.className = 'w-16 h-16 sm:w-20 sm:h-20 rounded-full overflow-hidden bg-slate-100 dark:bg-slate-800 border-2 border-primary/30';
        if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
          const img = document.createElement('img');
          img.src = pfpUrl;
          img.alt = username;
          img.className = 'w-full h-full object-cover';
          img.onerror = () => { div.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-xl sm:text-2xl">${initial}</div>`; };
          div.appendChild(img);
        } else {
          div.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-xl sm:text-2xl">${initial}</div>`;
        }
        return div;
      }


      function updateVideoVisibility(userId, enabled, trackReady = true) {
        const vid = document.getElementById(`video-${userId}`);
        const pfp = document.getElementById(`pfp-${userId}`);

        if (!vid || !pfp) {
          console.warn(`‚ö†Ô∏è Video elements not found for ${userId}`);
          return;
        }

        // ‚úÖ Enhanced check: verify video track exists in stream
        const hasVideoTrack = vid.srcObject && vid.srcObject.getVideoTracks().length > 0;
        const videoTrackEnabled = hasVideoTrack ? vid.srcObject.getVideoTracks()[0].enabled : false;

        const shouldShowVideo = enabled && trackReady && hasVideoTrack && videoTrackEnabled;

        console.log(`üìπ ========================================`);
        console.log(`üìπ updateVideoVisibility(${userId})`);
        console.log(`üìπ ========================================`);
        console.log(`   enabled: ${enabled}`);
        console.log(`   trackReady: ${trackReady}`);
        console.log(`   hasVideoTrack: ${hasVideoTrack}`);
        console.log(`   videoTrackEnabled: ${videoTrackEnabled}`);
        console.log(`   shouldShowVideo: ${shouldShowVideo}`);

        if (vid.srcObject) {
          console.log(`   srcObject video tracks: ${vid.srcObject.getVideoTracks().length}`);
          const tracks = vid.srcObject.getVideoTracks();
          tracks.forEach((track, i) => {
            console.log(`      [${i}] ${track.kind} - enabled:${track.enabled}, readyState:${track.readyState}, id:${track.id.substring(0, 8)}...`);
          });
        } else {
          console.log(`   srcObject: null`);
        }

        if (shouldShowVideo) {
          vid.classList.remove('hidden');
          pfp.classList.add('hidden');
          console.log(`   ‚úÖ Video SHOWN, profile picture HIDDEN`);
        } else {
          vid.classList.add('hidden');
          pfp.classList.remove('hidden');
          console.log(`   ‚úÖ Video HIDDEN, profile picture SHOWN`);
        }
        console.log(`üìπ ========================================\n`);
      }


      function createParticipantTile(user, isSelf = false) {
        console.log(`üé® Creating tile for ${user.username} (userId: ${user.userId}, isSelf: ${isSelf})`);

        // CRITICAL: Check if tile already exists in DOM
        const existingTile = document.getElementById(`participant-${user.userId}`);
        if (existingTile) {
          console.warn(`‚ö†Ô∏è Tile for ${user.userId} already exists in DOM! Removing old tile.`);
          existingTile.remove();
          renderedParticipants.delete(user.userId);
        }

        // Double-check tracking set
        if (renderedParticipants.has(user.userId)) {
          console.warn(`‚ö†Ô∏è Tile for ${user.userId} in tracking set but not in DOM! Clearing.`);
          renderedParticipants.delete(user.userId);
        }

        const tile = document.createElement('div');
        tile.id = `participant-${user.userId}`;
        tile.className = `video-tile ${isSelf ? 'border-2 border-dashed border-primary/30' : 'border border-white/5'}`;

        const videoContainer = document.createElement('div');
        videoContainer.className = 'video-container';

        const video = document.createElement('video');
        video.id = `video-${user.userId}`;
        video.className = 'hidden';
        video.autoplay = true;
        video.playsInline = true;
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');

        video.style.transform = 'scaleX(1)';  // Normal orientation for everyone

        if (isSelf) {
          video.muted = true;
          video.volume = 0;
          console.log(`üìπ Self video: NO MIRROR (true orientation) (userId: ${user.userId})`);
          console.log(`üîá Self video muted to prevent echo (userId: ${user.userId})`);
        } else {
          video.muted = false;
          video.volume = 1.0;
          console.log(`üìπ Remote video: NO MIRROR (true orientation) (userId: ${user.userId})`);
          console.log(`üîä Remote video audio enabled (userId: ${user.userId})`);
        }

        videoContainer.appendChild(video);

        const pfpOverlay = document.createElement('div');
        pfpOverlay.id = `pfp-${user.userId}`;
        pfpOverlay.className = 'pfp-overlay';
        pfpOverlay.appendChild(createProfilePicture(user.pfpUrl, user.username));
        videoContainer.appendChild(pfpOverlay);

        tile.appendChild(videoContainer);

        const label = document.createElement('div');
        label.className = 'absolute bottom-3 sm:bottom-4 left-3 sm:left-4 z-10';
        label.innerHTML = `<div class="${isSelf ? 'bg-primary/80' : 'bg-black/60'} backdrop-blur-md px-2 sm:px-3 py-1 sm:py-1.5 rounded-full border ${isSelf ? 'border-primary/20' : 'border-white/10'} flex items-center gap-1.5 sm:gap-2">
    <span class="text-white text-xs sm:text-sm font-semibold">${isSelf ? 'You' : user.username}</span>
    <span class="text-base sm:text-lg">üòä</span>
  </div>`;
        tile.appendChild(label);

        const speaking = document.createElement('div');
        speaking.id = `speaking-${user.userId}`;
        speaking.className = 'absolute top-3 sm:top-4 right-3 sm:right-4 bg-primary px-1.5 sm:px-2 py-0.5 rounded text-[9px] sm:text-[10px] font-bold text-white uppercase hidden z-10';
        speaking.textContent = 'SPEAKING';
        tile.appendChild(speaking);

        const micOff = document.createElement('div');
        micOff.id = `mic-${user.userId}`;
        micOff.className = 'absolute top-3 sm:top-4 right-3 sm:right-4 bg-accent-red p-1 sm:p-1.5 rounded-full text-white shadow-lg hidden z-10';
        micOff.innerHTML = '<span class="material-symbols-outlined text-[14px] sm:text-[16px]">mic_off</span>';
        tile.appendChild(micOff);

        if (isSelf) {
          const overlay = document.createElement('div');
          overlay.className = 'absolute inset-0 bg-primary/5 pointer-events-none';
          tile.appendChild(overlay);
        }

        renderedParticipants.add(user.userId);
        console.log(`‚úÖ Tile created for ${user.username} (${user.userId})`);
        console.log(`   Mirror effect: ${isSelf ? 'YES (self view)' : 'NO (remote view)'}`);
        console.log(`üìä Rendered participants now:`, Array.from(renderedParticipants));
        return tile;
      }


      // Add after createPC function to monitor connection quality
      function monitorConnectionQuality(userId, pc) {
        const monitorInterval = setInterval(async () => {
          if (!pc || pc.connectionState === 'closed') {
            clearInterval(monitorInterval);
            return;
          }

          try {
            const stats = await pc.getStats();
            let connectionInfo = {
              candidateType: 'unknown',
              bytesReceived: 0,
              bytesSent: 0,
              packetsLost: 0
            };

            stats.forEach(report => {
              if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                const localCandidate = stats.get(report.localCandidateId);
                if (localCandidate) {
                  connectionInfo.candidateType = localCandidate.candidateType;
                }
              }

              if (report.type === 'inbound-rtp' && report.kind === 'audio') {
                connectionInfo.bytesReceived = report.bytesReceived || 0;
                connectionInfo.packetsLost = report.packetsLost || 0;
              }

              if (report.type === 'outbound-rtp' && report.kind === 'audio') {
                connectionInfo.bytesSent = report.bytesSent || 0;
              }
            });

            // Only log significant changes or issues
            if (connectionInfo.packetsLost > 10) {
              console.warn(`‚ö†Ô∏è [Quality] Packet loss detected for ${userId}: ${connectionInfo.packetsLost} packets`);
            }

            // Update connection stats
            const connStats = connectionStats.get(userId);
            if (connStats) {
              connStats.lastQualityCheck = Date.now();
              connStats.connectionType = connectionInfo.candidateType;
            }

          } catch (e) {
            console.warn(`‚ö†Ô∏è Failed to get stats for ${userId}:`, e.message);
          }
        }, 5000); // Check every 5 seconds

        // Store interval for cleanup
        if (!connectionStats.has(userId)) {
          connectionStats.set(userId, {});
        }
        connectionStats.get(userId).monitorInterval = monitorInterval;
      }

      function setupAudioDetection(userId, stream) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          const analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          source.connect(analyser);
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          let isSpeaking = false, lastSpeakTime = 0;
          let stopped = false;

          function detect() {
            if (stopped || audioContext.state === 'closed') {
              console.log(`üîá Audio detection stopped for ${userId}`);
              return;
            }

            const speaking = document.getElementById(`speaking-${userId}`);
            const tile = document.getElementById(`participant-${userId}`);

            if (!speaking || !tile) {
              stopped = true;
              if (audioContext.state !== 'closed') {
                audioContext.close().catch(e => console.warn('Failed to close audio context:', e));
              }
              return;
            }

            analyser.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const now = Date.now();

            if (avg > 30) {
              if (!isSpeaking) {
                isSpeaking = true;
                speaking.classList.remove('hidden');
                tile.classList.add('active-speaker');
                if (socketInstance && userId === currentUser.userId) {
                  socketInstance.emit('speaking_state', { callId: callData.callId, speaking: true });
                }
              }
              lastSpeakTime = now;
            } else if (isSpeaking && now - lastSpeakTime > 300) {
              isSpeaking = false;
              speaking.classList.add('hidden');
              tile.classList.remove('active-speaker');
              if (socketInstance && userId === currentUser.userId) {
                socketInstance.emit('speaking_state', { callId: callData.callId, speaking: false });
              }
            }
            requestAnimationFrame(detect);
          }
          detect();

          // CRITICAL FIX: Store object with context and stop function
          audioContexts.set(userId, {
            context: audioContext,
            stop: () => { stopped = true; }
          });
        } catch (e) {
          console.error('Audio detection error:', e);
        }
      }

      async function initLocalMedia() {
        const MAX_RETRIES = 3;
        let attempt = 0;

        while (attempt < MAX_RETRIES) {
          try {
            attempt++;
            console.log(`üé• [Attempt ${attempt}/${MAX_RETRIES}] Requesting media (${callData.callType})...`);

            const constraints = {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
              },
              video: callData.callType === 'video' ? {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user'
              } : false
            };

            let hasVideo = false;
            let hasAudio = false;

            try {
              localStream = await navigator.mediaDevices.getUserMedia(constraints);
              hasVideo = localStream.getVideoTracks().length > 0;
              hasAudio = localStream.getAudioTracks().length > 0;
              console.log(`‚úÖ [Attempt ${attempt}] SUCCESS: video=${hasVideo}, audio=${hasAudio}`);
              break;
            } catch (videoError) {
              console.warn(`‚ö†Ô∏è [Attempt ${attempt}] Video failed: ${videoError.name}`);

              try {
                const audioOnlyConstraints = {
                  audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
                  video: false
                };
                localStream = await navigator.mediaDevices.getUserMedia(audioOnlyConstraints);
                hasAudio = localStream.getAudioTracks().length > 0;
                console.log(`‚úÖ [Attempt ${attempt}] Audio-only SUCCESS: audio=${hasAudio}`);

                if (attempt === 1) {
                  toast('Camera not available, using audio only', 'warning');
                }
                break;
              } catch (audioError) {
                console.error(`‚ùå [Attempt ${attempt}] Both failed: ${audioError.name}`);

                if (attempt === MAX_RETRIES) {
                  localStream = new MediaStream();
                  toast('No media devices available. You can still join the call.', 'error');
                } else {
                  await new Promise(resolve => setTimeout(resolve, 500));
                  continue;
                }
              }
            }

            // ‚úÖ FIX: Set states AFTER actual media acquisition
            isVideoEnabled = hasVideo;
            isAudioEnabled = hasAudio;

            console.log(`üìä ========================================`);
            console.log(`üìä MEDIA STATE SYNCHRONIZED`);
            console.log(`üìä ========================================`);
            console.log(`   Expected video: ${callData.callType === 'video'}`);
            console.log(`   Actual video tracks: ${localStream.getVideoTracks().length}`);
            console.log(`   isVideoEnabled: ${isVideoEnabled}`);
            console.log(`   Expected audio: true`);
            console.log(`   Actual audio tracks: ${localStream.getAudioTracks().length}`);
            console.log(`   isAudioEnabled: ${isAudioEnabled}`);
            console.log(`üìä ========================================\n`);

            if (hasAudio) {
              const audioTrack = localStream.getAudioTracks()[0];
              if (audioTrack) {
                setupAudioDetection(currentUser.userId, localStream);
                console.log(`üé§ Audio detection setup for ${currentUser.username}`);
              }
            }

            const callIcon = document.getElementById('callIcon');
            if (callIcon) callIcon.textContent = isVideoEnabled ? 'videocam' : 'graphic_eq';

            console.log(`‚úÖ initLocalMedia() complete - stream ready`);
            return localStream;

          } catch (e) {
            console.error(`‚ùå [Attempt ${attempt}] Critical error:`, e);
            if (attempt === MAX_RETRIES) {
              localStream = new MediaStream();
              isVideoEnabled = false;
              isAudioEnabled = false;
              toast('Unable to access media devices.', 'error');
              return localStream;
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }

        return localStream;
      }


      async function setupLocalVideo() {
        const waitForElement = (id, maxWait = 5000) => {
          return new Promise((resolve, reject) => {
            const startTime = Date.now();
            const checkElement = () => {
              const element = document.getElementById(id);
              if (element) {
                resolve(element);
              } else if (Date.now() - startTime > maxWait) {
                reject(new Error(`Element ${id} not found after ${maxWait}ms`));
              } else {
                requestAnimationFrame(checkElement);
              }
            };
            checkElement();
          });
        };

        try {
          console.log(`üîß ========================================`);
          console.log(`üîß SETUP LOCAL VIDEO`);
          console.log(`üîß ========================================`);
          console.log(`   User: ${currentUser.username}`);
          console.log(`   isVideoEnabled: ${isVideoEnabled}`);
          console.log(`   Video tracks: ${localStream.getVideoTracks().length}`);

          const localTile = document.getElementById(`participant-${currentUser.userId}`);
          if (!localTile) {
            console.warn(`‚ö†Ô∏è No tile for ${currentUser.username} yet - will be created when user_joined_call fires`);
            return;
          }

          const localVid = await waitForElement(`video-${currentUser.userId}`);
          const localPfp = await waitForElement(`pfp-${currentUser.userId}`);

          console.log(`‚úÖ Found video elements for ${currentUser.username}`);

          if (!localStream) {
            console.error(`‚ùå No localStream available`);
            return;
          }

          localVid.srcObject = localStream;
          localVid.muted = true;
          localVid.volume = 0;
          console.log(`‚ÑπÔ∏è Video transform already set: ${localVid.style.transform}`);
          console.log(`‚úÖ Local stream attached to video element`);

          // ‚úÖ FIX: Gate UI updates on actual media readiness
          if (isVideoEnabled && localStream.getVideoTracks().length > 0) {
            console.log(`üìπ Waiting for local video to be ready...`);

            await new Promise((resolve) => {
              const checkReady = () => {
                if (localVid.readyState >= 2) {
                  console.log(`üìπ Local video ready: ${localVid.videoWidth}x${localVid.videoHeight}`);
                  resolve();
                } else {
                  localVid.addEventListener('loadedmetadata', () => {
                    console.log(`üìπ Metadata loaded: ${localVid.videoWidth}x${localVid.videoHeight}`);
                    resolve();
                  }, { once: true });
                }
              };
              checkReady();
            });

            try {
              await localVid.play();
              console.log(`‚ñ∂Ô∏è Local video playback started`);
              updateVideoVisibility(currentUser.userId, true, true);
              updateVideoButton(); // ‚úÖ FIX: Update icon AFTER video confirmed playing
              console.log(`‚úÖ Video icon synchronized: ON`);
            } catch (e) {
              console.error('‚ùå Local video play failed:', e);
              isVideoEnabled = false; // ‚úÖ FIX: Rollback state on failure
              updateVideoVisibility(currentUser.userId, false, false);
              updateVideoButton();
              console.log(`‚úÖ Video icon synchronized: OFF (playback failed)`);
            }
          } else {
            console.log(`üìπ Video disabled or no video track for ${currentUser.username}`);
            updateVideoVisibility(currentUser.userId, false, false);
            updateVideoButton(); // ‚úÖ FIX: Update icon AFTER visibility set
            console.log(`‚úÖ Video icon synchronized: OFF`);
          }

          updateMicButton();

          console.log(`üîß ========================================`);
          console.log(`üîß SETUP COMPLETE`);
          console.log(`üîß ========================================`);
          console.log(`   Video element ready: ${localVid.readyState >= 2}`);
          console.log(`   Video playing: ${!localVid.paused}`);
          console.log(`   isVideoEnabled: ${isVideoEnabled}`);
          console.log(`   Icon state: ${document.getElementById('videoBtn')?.querySelector('.material-symbols-outlined')?.textContent}`);
          console.log(`üîß ========================================\n`);

        } catch (error) {
          console.error(`‚ùå setupLocalVideo() failed:`, error);
          console.log(`‚ö†Ô∏è Will retry when tile becomes available`);
        }
      }



      function updateVideoButton() {
        const btn = document.getElementById('videoBtn');
        const icon = btn?.querySelector('.material-symbols-outlined');

        if (!btn || !icon) return;

        if (isVideoEnabled) {
          btn.classList.add('bg-primary', 'text-white');
          btn.classList.remove('bg-slate-200', 'dark:bg-background-dark');
          icon.textContent = 'videocam';
        } else {
          btn.classList.remove('bg-primary', 'text-white');
          btn.classList.add('bg-slate-200', 'dark:bg-background-dark');
          icon.textContent = 'videocam_off';
        }
        console.log(`‚úÖ Video button updated: ${isVideoEnabled ? 'ON' : 'OFF'}`);
      }




      function updateMicButton() {
        const micBtn = document.getElementById('micBtn');
        const micIcon = micBtn?.querySelector('.material-symbols-outlined');

        if (!micBtn || !micIcon) return;

        if (isAudioEnabled) {
          micBtn.classList.add('bg-primary', 'text-white');
          micBtn.classList.remove('bg-accent-red');
          micIcon.textContent = 'mic';
        } else {
          micBtn.classList.remove('bg-primary');
          micBtn.classList.add('bg-accent-red', 'text-white');
          micIcon.textContent = 'mic_off';
        }
        console.log(`‚úÖ Mic button updated: ${isAudioEnabled ? 'ON' : 'OFF'}`);
      }



      function createPC(userId) {
        console.log(`üîó Creating PC for ${userId}`);

        // CRITICAL FIX: Check for existing PC and close it
        const existingPC = peerConnections.get(userId);
        if (existingPC) {
          console.warn(`‚ö†Ô∏è PC already exists for ${userId}, closing old one`);
          existingPC.close();
          peerConnections.delete(userId);
        }

        if (!localStream) {
          console.error(`‚ùå CRITICAL: localStream is null when creating PC for ${userId}!`);
          throw new Error('Cannot create PeerConnection without localStream');
        }

        console.log(`‚úÖ localStream validated: ${localStream.getTracks().length} tracks`);

        const pc = new RTCPeerConnection({
          ...PEER_CONNECTION_CONFIG,
          iceServers: ICE_SERVERS
        });

        connectionStats.set(userId, {
          startTime: Date.now(),
          iceState: 'new',
          connectionState: 'new',
          candidatesReceived: 0,
          candidatesSent: 0,
          iceRestartCount: 0,
          lastIceCandidateTime: 0
        });

        const tracks = localStream.getTracks();
        console.log(`üìä Adding ${tracks.length} tracks to PC for ${userId}:`);

        tracks.forEach(track => {
          pc.addTrack(track, localStream);
          console.log(`   ‚ûï ${track.kind} track (id=${track.id.substring(0, 8)}..., enabled=${track.enabled})`);
        });

        // CRITICAL: Add ontrack handler to receive remote media
        pc.ontrack = (event) => {
          console.log(`üéµ ========================================`);
          console.log(`üéµ [TRACK] Received ${event.track.kind} track`);
          console.log(`üéµ ========================================`);
          console.log(`   From: ${userId}`);
          console.log(`   Track ID: ${event.track.id.substring(0, 8)}...`);
          console.log(`   Track state: enabled=${event.track.enabled}, readyState=${event.track.readyState}, muted=${event.track.muted}`);
          console.log(`   Streams: ${event.streams.length}`);

          if (event.streams && event.streams.length > 0) {
            const remoteStream = event.streams[0];
            console.log(`   Remote stream: ${remoteStream.id.substring(0, 8)}... with ${remoteStream.getTracks().length} tracks`);

            const remoteVideo = document.getElementById(`video-${userId}`);

            if (remoteVideo) {
              // ‚úÖ CRITICAL: Always update srcObject when new tracks arrive
              const needsUpdate = !remoteVideo.srcObject || remoteVideo.srcObject.id !== remoteStream.id;

              if (needsUpdate) {
                console.log(`üì∫ Setting/updating srcObject for ${userId}`);
                remoteVideo.srcObject = remoteStream;
                remoteVideo.muted = false;
                remoteVideo.volume = 1.0;

                // Wait for metadata and play
                remoteVideo.onloadedmetadata = async () => {
                  console.log(`üì∫ Metadata loaded for ${userId}: ${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`);
                  try {
                    await remoteVideo.play();
                    console.log(`‚ñ∂Ô∏è Remote video playing for ${userId}`);

                    // ‚úÖ Update visibility if this is a video track
                    if (event.track.kind === 'video' && event.track.enabled) {
                      console.log(`üìπ Remote video track enabled for ${userId}, updating visibility`);
                      updateVideoVisibility(userId, true, true);
                    }
                  } catch (playError) {
                    console.error(`‚ùå Failed to play remote video for ${userId}:`, playError);
                  }
                };

                // If metadata already loaded, play immediately
                if (remoteVideo.readyState >= 2) {
                  console.log(`üì∫ Metadata already loaded for ${userId}, playing now`);
                  remoteVideo.play().catch(e => {
                    console.error(`‚ùå Play failed for ${userId}:`, e);
                  });

                  if (event.track.kind === 'video' && event.track.enabled) {
                    updateVideoVisibility(userId, true, true);
                  }
                }
              } else {
                console.log(`‚ÑπÔ∏è Remote video for ${userId} already has correct srcObject`);

                // ‚úÖ Still update visibility for new video tracks
                if (event.track.kind === 'video' && event.track.enabled) {
                  console.log(`üìπ New video track added to existing stream, updating visibility`);
                  updateVideoVisibility(userId, true, true);
                }
              }

              // Setup audio detection for remote streams
              if (event.track.kind === 'audio') {
                console.log(`üé§ Setting up audio detection for remote user ${userId}`);
                setupAudioDetection(userId, remoteStream);
              }

            } else {
              console.error(`‚ùå Video element not found for ${userId}`);
            }
          } else {
            console.warn(`‚ö†Ô∏è No streams in track event for ${userId}`);
          }

          // Track ended handler
          event.track.onended = () => {
            console.log(`üîá Track ended for ${userId}: ${event.track.kind}`);
          };

          // Track mute/unmute handlers
          event.track.onmute = () => {
            console.log(`üîá Track muted for ${userId}: ${event.track.kind}`);
          };

          event.track.onunmute = () => {
            console.log(`üîä Track unmuted for ${userId}: ${event.track.kind}`);

            // ‚úÖ Handle video unmute event (dynamic video addition)
            if (event.track.kind === 'video') {
              console.log(`üìπ Video track unmuted for ${userId}, updating visibility`);
              updateVideoVisibility(userId, true, true);
            }
          };

          console.log(`üéµ ========================================\n`);
        };

        // CRITICAL: ICE candidate handler with rate limiting
        let lastCandidateEmit = 0;
        const CANDIDATE_EMIT_THROTTLE = 50; // 50ms between emits

        let hostCandidatesSent = 0;
        let srflxCandidatesSent = 0;
        const relayCandidateQueue = [];

        pc.onicecandidate = (e) => {
          if (e.candidate) {
            const stats = connectionStats.get(userId);
            if (stats) {
              stats.candidatesSent++;
              stats.lastIceCandidateTime = Date.now();
            }

            const candidateType = e.candidate.type || 'unknown';
            const candidateProtocol = e.candidate.protocol || 'unknown';

            console.log(`üßä [ICE] Generated ${candidateType} candidate for ${userId} (protocol: ${candidateProtocol})`);

            // ‚úÖ VERIFICATION: Should NEVER see relay in STUN-only mode
            if (candidateType === 'relay' && !useTurnFallback) {
              console.error(`‚ùå UNEXPECTED: Relay candidate generated in STUN-only mode!`);
              console.error(`   This should not happen - check ICE server config`);
              return; // Don't send relay candidates in STUN-only mode
            }

            // Send all candidates immediately (no delay needed - no relay to worry about)
            socketInstance.emit('ice_candidate', {
              callId: callData.callId,
              targetUserId: userId,
              candidate: e.candidate
            });

            console.log(`üì§ [ICE] Sent ${candidateType} candidate to ${userId}`);

          } else {
            console.log(`üßä [ICE] End of candidates for ${userId}`);
            console.log(`üìä [ICE] Total candidates sent: ${connectionStats.get(userId)?.candidatesSent || 0}`);

            socketInstance.emit('ice_candidate', {
              callId: callData.callId,
              targetUserId: userId,
              candidate: null
            });
          }
        };

        pc.oniceconnectionstatechange = () => {
          const state = pc.iceConnectionState;
          const stats = connectionStats.get(userId);
          if (stats) stats.iceState = state;

          console.log(`üßä [ICE] Connection state for ${userId}: ${state}`);

          if (state === 'connected' || state === 'completed') {
            console.log(`‚úÖ [ICE] Connected to ${userId}`);

            // CRITICAL: Mark call as fully connected when first peer connects
            if (!hasEstablishedConnection) {
              console.log('üìû ========================================');
              console.log('üìû FIRST PEER CONNECTION ESTABLISHED');
              console.log('üìû ========================================');
              console.log(`   Call state transition: ${callConnectionState} ‚Üí connected`);
              hasEstablishedConnection = true;
              callConnectionState = 'connected';
              broadcastCallStateToChat();
              console.log('üìû ========================================\n');
            }

            // Reset failure counter on success
            if (stats) stats.iceRestartCount = 0;

            pc.getStats().then(statsReport => {
              let selectedPairType = 'unknown';
              let selectedLocal = null;
              let selectedRemote = null;

              statsReport.forEach(report => {
                if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                  const localCandidate = statsReport.get(report.localCandidateId);
                  const remoteCandidate = statsReport.get(report.remoteCandidateId);

                  if (localCandidate && remoteCandidate) {
                    selectedLocal = localCandidate;
                    selectedRemote = remoteCandidate;

                    if (localCandidate.candidateType === 'relay' || remoteCandidate.candidateType === 'relay') {
                      selectedPairType = 'TURN_RELAY';
                      console.warn(`‚ö†Ô∏è [ICE] Connection using TURN RELAY (bandwidth cost incurred)`);
                    } else if (localCandidate.candidateType === 'srflx' || remoteCandidate.candidateType === 'srflx') {
                      selectedPairType = 'STUN_REFLEXIVE';
                      console.log(`‚úÖ [ICE] Connection using STUN (server-reflexive) - optimal`);
                    } else if (localCandidate.candidateType === 'host') {
                      selectedPairType = 'DIRECT_HOST';
                      console.log(`‚úÖ [ICE] Connection using direct HOST (LAN/same network)`);
                    }

                    console.log(`üìä [ICE] Selected pair details:`);
                    console.log(`   Local:  ${localCandidate.candidateType} ${localCandidate.protocol} ${localCandidate.address}:${localCandidate.port}`);
                    console.log(`   Remote: ${remoteCandidate.candidateType} ${remoteCandidate.protocol} ${remoteCandidate.address}:${remoteCandidate.port}`);

                    // ‚úÖ Confirm zero TURN usage
                    if (selectedPairType !== 'TURN_RELAY') {
                      console.log(`üí∞ [COST] Zero TURN bandwidth used - pure peer-to-peer`);
                      console.log(`   Cloudflare analytics should show 0 KB for this call`);
                    }

                    if (stats) {
                      stats.connectionType = selectedPairType;
                      stats.localCandidateType = localCandidate.candidateType;
                      stats.remoteCandidateType = remoteCandidate.candidateType;
                    }

                    socketInstance.emit('connection_established', {
                      callId: callData.callId,
                      connectionType: selectedPairType,
                      localType: localCandidate.candidateType,
                      remoteType: remoteCandidate.candidateType,
                      protocol: localCandidate.protocol
                    });
                  }
                }
              });

            });

          } else if (state === 'failed') {
            console.error(`‚ùå [ICE] Connection failed for ${userId}`);

            // ‚úÖ TURN FALLBACK LOGIC
            if (stats && stats.iceRestartCount < 1 && !useTurnFallback) {
              stats.iceRestartCount++;

              console.warn(`üîÑ [FALLBACK] Connection failed with STUN-only mode`);
              console.warn(`   Attempt ${stats.iceRestartCount}: Retrying with STUN only...`);

              setTimeout(() => {
                if (pc.connectionState !== 'closed') {
                  createOffer(userId);
                }
              }, 1000);

            } else if (stats && stats.iceRestartCount >= 1 && !useTurnFallback) {
              // Second failure - enable TURN fallback
              console.error(`‚ùå [FALLBACK] STUN-only failed after 2 attempts`);
              console.warn(`üîÑ Enabling TURN fallback for this call...`);
              console.warn(`   This indicates symmetric NAT or restrictive firewall`);

              useTurnFallback = true;

              // Notify user
              toast('Connection issues detected. Trying alternative route...', 'warning');

              // Refetch ICE servers with TURN included
              fetchIceServers().then(() => {
                console.log(`‚úÖ TURN servers loaded for fallback`);
                console.log(`   Attempting ICE restart with TURN...`);

                // Close old peer connection
                pc.close();
                peerConnections.delete(userId);

                // Recreate with TURN-enabled config
                setTimeout(() => {
                  createOffer(userId);
                }, 1500);
              });

            } else if (useTurnFallback && stats && stats.iceRestartCount >= 2) {
              // Even TURN failed
              console.error(`‚ùå [CRITICAL] Connection failed even with TURN fallback`);
              toast('Unable to establish connection. Please check your network.', 'error');
            }

          } else if (state === 'disconnected') {
            console.warn(`‚ö†Ô∏è [ICE] Disconnected from ${userId}`);

            // Don't immediately enable TURN on disconnect - might reconnect

          } else if (state === 'closed') {
            console.log(`üîí [ICE] Connection closed for ${userId}`);
          } else if (state === 'checking') {
            console.log(`üîç [ICE] Checking connectivity for ${userId}...`);

            pc.getStats().then(statsReport => {
              const checkingPairs = [];
              let hasRelayCandidates = false;

              statsReport.forEach(report => {
                if (report.type === 'candidate-pair' && report.state === 'in-progress') {
                  const localCand = statsReport.get(report.localCandidateId);
                  if (localCand) {
                    checkingPairs.push(`${localCand.candidateType}/${localCand.protocol}`);
                    if (localCand.candidateType === 'relay') hasRelayCandidates = true;
                  }
                }
              });

              if (checkingPairs.length > 0) {
                console.log(`   Checking pairs: ${checkingPairs.join(', ')}`);

                if (!hasRelayCandidates && !useTurnFallback) {
                  console.log(`   ‚úÖ STUN-only mode: No relay candidates in use`);
                }
              }
            });
          }
        };

        pc.onconnectionstatechange = () => {
          const state = pc.connectionState;
          const stats = connectionStats.get(userId);
          if (stats) stats.connectionState = state;

          console.log(`üîå [PC] Connection state for ${userId}: ${state}`);

          if (state === 'connected') {
            console.log(`‚úÖ [PC] Peer connection established with ${userId}`);

            socketInstance.emit('connection_state_update', {
              callId: callData.callId,
              state: 'connected',
              userId: userId
            });

          } else if (state === 'failed') {
            console.error(`‚ùå [PC] Connection failed with ${userId}`);

            // ‚úÖ Detailed failure diagnostics
            pc.getStats().then(statsReport => {
              console.error(`üìä [DIAGNOSTIC] Connection failure stats:`);

              let hadRelayCandidates = false;
              let hadSrflxCandidates = false;

              statsReport.forEach(report => {
                if (report.type === 'local-candidate') {
                  if (report.candidateType === 'relay') hadRelayCandidates = true;
                  if (report.candidateType === 'srflx') hadSrflxCandidates = true;
                }
              });

              console.error(`   STUN candidates generated: ${hadSrflxCandidates ? 'YES' : 'NO'}`);
              console.error(`   TURN candidates generated: ${hadRelayCandidates ? 'YES' : 'NO'}`);

              if (!hadSrflxCandidates && !hadRelayCandidates) {
                console.error(`   ‚ùå NO reflexive or relay candidates - ICE servers unreachable`);
              } else if (!hadSrflxCandidates && hadRelayCandidates) {
                console.error(`   ‚ùå STUN failed but TURN available - likely symmetric NAT`);
              }
            });

            socketInstance.emit('connection_state_update', {
              callId: callData.callId,
              state: 'failed',
              userId: userId
            });
          }
        };

        monitorConnectionQuality(userId, pc);

        peerConnections.set(userId, pc);
        console.log(`‚úÖ PeerConnection created for ${userId} with all handlers`);
        return pc;
      }


      async function createOffer(userId) {
        // CRITICAL: Check if already making offer
        if (makingOffer.get(userId)) {
          console.warn(`‚ö†Ô∏è Already making offer to ${userId}, skipping`);
          return;
        }

        try {
          makingOffer.set(userId, true);

          console.log(`üì§ Creating offer for ${userId}`);

          // Small delay to ensure remote peer has fully joined
          await new Promise(resolve => setTimeout(resolve, 500));

          const pc = createPC(userId);

          // Validate local stream
          if (!localStream || localStream.getTracks().length === 0) {
            console.error(`‚ùå No local stream available when creating offer for ${userId}`);
            return;
          }

          console.log(`üìä Local stream for offer: ${localStream.getTracks().map(t => `${t.kind}(${t.enabled})`).join(', ')}`);

          const offer = await pc.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          });

          await pc.setLocalDescription(offer);

          console.log(`‚úÖ Offer created and set as local description for ${userId}`);
          console.log(`   Offer type: ${offer.type}`);
          console.log(`   Offer SDP length: ${offer.sdp?.length || 0} bytes`);
          console.log(`   PC state: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);

          socketInstance.emit('webrtc_offer', {
            callId: callData.callId,
            targetUserId: userId,
            offer
          });

          console.log(`üì§ Offer sent to ${userId} via socket`);

        } catch (e) {
          console.error(`‚ùå Offer creation error for ${userId}:`, e);
          console.error(`   Error name: ${e.name}`);
          console.error(`   Error message: ${e.message}`);
        } finally {
          makingOffer.set(userId, false);
        }
      }

      async function handleOffer(fromUserId, offer) {
        // CRITICAL: Prevent duplicate offer processing with mutex
        if (negotiationMutex.has(fromUserId)) {
          console.warn(`‚ö†Ô∏è Already processing offer from ${fromUserId}, ignoring duplicate`);
          return;
        }

        // Create mutex promise
        const mutexPromise = (async () => {
          try {
            console.log(`üì• [OFFER] Received offer from ${fromUserId}`);
            console.log(`   Offer type: ${offer.type}, SDP length: ${offer.sdp?.length || 0}`);

            // Validate localStream
            if (!localStream) {
              console.error(`‚ùå CRITICAL: No localStream when handling offer from ${fromUserId}`);
              return;
            }

            console.log(`‚úÖ LocalStream validated: ${localStream.getTracks().length} tracks`);

            let pc = peerConnections.get(fromUserId);

            // CRITICAL: Check for signaling state collision
            const offerCollision = pc &&
              (pc.signalingState !== 'stable' && pc.signalingState !== 'have-local-offer');

            // Determine polite/impolite based on user ID comparison
            const polite = currentUser.userId < fromUserId;

            console.log(`   Polite: ${polite}, Offer collision: ${offerCollision}`);

            // Impolite peer ignores colliding offers
            if (offerCollision && !polite) {
              console.log(`   üö´ Impolite peer ignoring colliding offer from ${fromUserId}`);
              return;
            }

            // If PC exists and we have a collision, polite peer uses rollback
            if (offerCollision && polite) {
              console.log(`   üîÑ Polite peer performing rollback for ${fromUserId}`);
              await pc.setLocalDescription({ type: 'rollback' });
              console.log(`   ‚úÖ Rollback complete`);
            }

            // Create new PC if needed or if closed
            if (!pc || pc.connectionState === 'closed') {
              console.log(`üîß Creating new PeerConnection for ${fromUserId}`);
              pc = createPC(fromUserId);
            }

            console.log(`üîß Setting remote description (offer) for ${fromUserId}`);
            console.log(`   PC state before: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);

            // CRITICAL: Use Promise.all to queue operations properly
            await Promise.all([
              pc.setRemoteDescription(new RTCSessionDescription(offer)),
              // Queue ICE candidate processing after setRemoteDescription
              new Promise(resolve => setTimeout(resolve, 0))
            ]);

            console.log(`‚úÖ Remote description set successfully`);
            console.log(`   PC state after: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);

            // Inside handleOffer function, replace the pending candidates section:

            // Process pending ICE candidates AFTER remote description is set
            if (pendingIceCandidates.has(fromUserId)) {
              const cands = pendingIceCandidates.get(fromUserId);
              console.log(`üßä Adding ${cands.length} pending ICE candidates for ${fromUserId}`);

              for (const item of cands) {
                try {
                  const c = item.candidate;

                  // Validate before adding
                  if (!c.candidate || typeof c.candidate !== 'string') {
                    console.warn(`‚ö†Ô∏è Skipping invalid queued candidate`);
                    continue;
                  }

                  if (c.sdpMid === null && c.sdpMLineIndex === null) {
                    console.warn(`‚ö†Ô∏è Skipping queued candidate with null sdpMid/sdpMLineIndex`);
                    continue;
                  }

                  await pc.addIceCandidate(new RTCIceCandidate(c));
                  console.log(`‚úÖ Added pending ICE candidate`);
                } catch (e) {
                  console.warn(`‚ö†Ô∏è Failed to add queued candidate:`, e.message);
                  // Continue with next candidate
                }
              }
              pendingIceCandidates.delete(fromUserId);
            }

            console.log(`üì§ Creating answer for ${fromUserId}...`);

            // Create answer
            const answer = await pc.createAnswer();
            console.log(`   Answer created: type=${answer.type}, SDP length=${answer.sdp?.length || 0}`);

            await pc.setLocalDescription(answer);
            console.log(`‚úÖ Answer set as local description`);
            console.log(`   PC state: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);

            console.log(`üì§ Sending answer to ${fromUserId} via socket`);
            socketInstance.emit('webrtc_answer', {
              callId: callData.callId,
              targetUserId: fromUserId,
              answer
            });
            console.log(`‚úÖ Answer emitted successfully`);

          } catch (e) {
            console.error(`‚ùå Handle offer error for ${fromUserId}:`, e);
            console.error(`   Error name: ${e.name}`);
            console.error(`   Error message: ${e.message}`);
          } finally {
            // Remove mutex after 100ms to allow for any in-flight duplicates to be caught
            setTimeout(() => {
              negotiationMutex.delete(fromUserId);
            }, 100);
          }
        })();

        negotiationMutex.set(fromUserId, mutexPromise);
        await mutexPromise;
      }

      async function handleAnswer(fromUserId, answer) {
        try {
          console.log(`üì• [ANSWER] Received answer from ${fromUserId}`);
          console.log(`   Answer type: ${answer.type}, SDP length: ${answer.sdp?.length || 0}`);

          const pc = peerConnections.get(fromUserId);

          if (!pc) {
            console.error(`‚ùå No PC found for ${fromUserId} when handling answer`);
            return;
          }

          console.log(`üìä PC state before handling answer: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);

          // CRITICAL: Only accept answer if we're in the right state
          if (pc.signalingState !== 'have-local-offer') {
            console.warn(`‚ö†Ô∏è Ignoring answer from ${fromUserId} - wrong state: ${pc.signalingState}`);
            return;
          }

          console.log(`üîß Setting remote description (answer) for ${fromUserId}`);
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
          console.log(`‚úÖ Answer set as remote description`);
          console.log(`   PC state after: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);

          // Inside handleAnswer function, replace the pending candidates section:

          // Process pending ICE candidates
          if (pendingIceCandidates.has(fromUserId)) {
            const cands = pendingIceCandidates.get(fromUserId);
            console.log(`üßä Adding ${cands.length} pending ICE candidates for ${fromUserId}`);

            for (const item of cands) {
              try {
                const c = item.candidate;

                // Validate before adding
                if (!c.candidate || typeof c.candidate !== 'string') {
                  console.warn(`‚ö†Ô∏è Skipping invalid queued candidate`);
                  continue;
                }

                if (c.sdpMid === null && c.sdpMLineIndex === null) {
                  console.warn(`‚ö†Ô∏è Skipping queued candidate with null sdpMid/sdpMLineIndex`);
                  continue;
                }

                await pc.addIceCandidate(new RTCIceCandidate(c));
                console.log(`‚úÖ Added pending ICE candidate`);
              } catch (e) {
                console.warn(`‚ö†Ô∏è Failed to add queued candidate:`, e.message);
                // Continue with next candidate
              }
            }
            pendingIceCandidates.delete(fromUserId);
          }

          console.log(`‚úÖ Answer handling complete for ${fromUserId}`);

        } catch (e) {
          console.error(`‚ùå Handle answer error for ${fromUserId}:`, e);
          console.error(`   Error name: ${e.name}`);
          console.error(`   Error message: ${e.message}`);
        }
      }

      // Replace handleIceCandidate function
      async function handleIceCandidate(fromUserId, candidate) {
        try {
          if (!candidate) {
            console.log(`üßä [ICE] Received end-of-candidates from ${fromUserId}`);
            return;
          }

          // CRITICAL FIX: Validate candidate structure before queuing/adding
          if (!candidate.candidate || typeof candidate.candidate !== 'string') {
            console.warn(`‚ö†Ô∏è [ICE] Invalid candidate structure from ${fromUserId}:`, candidate);
            return;
          }

          // Additional validation for required fields
          if (candidate.sdpMid === null && candidate.sdpMLineIndex === null) {
            console.warn(`‚ö†Ô∏è [ICE] Candidate missing both sdpMid and sdpMLineIndex from ${fromUserId}, skipping`);
            return;
          }

          const pc = peerConnections.get(fromUserId);

          // Queue candidates if no PC yet OR if remote description not set
          if (!pc || !pc.remoteDescription) {
            if (!pendingIceCandidates.has(fromUserId)) {
              pendingIceCandidates.set(fromUserId, []);
            }

            const queue = pendingIceCandidates.get(fromUserId);
            queue.push({
              candidate: candidate,
              timestamp: Date.now()
            });

            console.log(`üßä [ICE] Queued candidate from ${fromUserId} (pending: ${queue.length})`);

            // Auto-cleanup old candidates after 30 seconds
            setTimeout(() => {
              const currentQueue = pendingIceCandidates.get(fromUserId);
              if (currentQueue) {
                const filtered = currentQueue.filter(item => Date.now() - item.timestamp < 30000);
                if (filtered.length !== currentQueue.length) {
                  console.log(`üßπ [ICE] Cleaned ${currentQueue.length - filtered.length} old candidates for ${fromUserId}`);
                  pendingIceCandidates.set(fromUserId, filtered);
                }
              }
            }, 30000);

            return;
          }

          // Add candidate if PC is ready
          try {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            const stats = connectionStats.get(fromUserId);
            if (stats) stats.candidatesReceived++;

            const candidateType = candidate.type || candidate.candidate?.split(' ')[7] || 'unknown';
            console.log(`üßä [ICE] Added ${candidateType} candidate from ${fromUserId} (total: ${stats?.candidatesReceived || 0})`);
          } catch (addError) {
            console.warn(`‚ö†Ô∏è [ICE] Failed to add candidate from ${fromUserId}:`, addError.message);
            // Don't throw - continue processing other candidates
          }

        } catch (e) {
          console.warn(`‚ö†Ô∏è [ICE] Candidate processing error for ${fromUserId}:`, e.message);
        }
      }

      function toggleMic() {
        if (localStream) {
          const track = localStream.getAudioTracks()[0];
          if (track) {
            track.enabled = !track.enabled;
            isAudioEnabled = track.enabled;
            const btn = document.getElementById('micBtn');
            const icon = btn.querySelector('.material-symbols-outlined');
            const mic = document.getElementById(`mic-${currentUser.userId}`);

            console.log(`üé§ Mic toggled: ${isAudioEnabled ? 'ON' : 'OFF'}`);

            if (isAudioEnabled) {
              btn.classList.add('bg-primary', 'text-white');
              btn.classList.remove('bg-accent-red');
              icon.textContent = 'mic';
              if (mic) mic.classList.add('hidden');
            } else {
              btn.classList.remove('bg-primary');
              btn.classList.add('bg-accent-red', 'text-white');
              icon.textContent = 'mic_off';
              if (mic) mic.classList.remove('hidden');
            }

            socketInstance.emit('audio_state_changed', { callId: callData.callId, enabled: isAudioEnabled });
          }
        }
      }

      async function toggleVideo() {
        if (isTogglingVideo) {
          console.log('‚ö†Ô∏è Video toggle already in progress, ignoring');
          return;
        }

        isTogglingVideo = true;

        console.log(`üìπ ========================================`);
        console.log(`üìπ VIDEO TOGGLE REQUESTED`);
        console.log(`üìπ ========================================`);
        console.log(`   Call type: ${callData.callType}`);
        console.log(`   Current isVideoEnabled: ${isVideoEnabled}`);
        console.log(`   Video tracks before: ${localStream.getVideoTracks().length}`);
        console.log(`   Active peer connections: ${peerConnections.size}`);

        if (!localStream) {
          console.error('‚ùå No localStream available');
          isTogglingVideo = false;
          return;
        }

        let track = localStream.getVideoTracks()[0];
        let wasTrackAdded = false;

        // ‚úÖ FIX: Handle missing video track (audio call or failed camera)
        if (!track) {
          console.log(`üìπ No video track exists - requesting camera access...`);

          try {
            const videoStream = await navigator.mediaDevices.getUserMedia({
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user'
              }
            });

            track = videoStream.getVideoTracks()[0];

            if (!track) {
              console.error('‚ùå Camera permission granted but no track received');
              toast('Failed to access camera', 'error');
              isTogglingVideo = false;
              return;
            }

            // Add track to local stream
            localStream.addTrack(track);
            console.log(`‚úÖ Video track added to localStream (id: ${track.id.substring(0, 8)}...)`);

            // ‚úÖ CRITICAL: Add track to ALL existing peer connections
            const renegotiationPromises = [];

            peerConnections.forEach((pc, userId) => {
              try {
                console.log(`üì§ Adding video track to peer connection with ${userId}`);

                // Add the track to the peer connection
                const sender = pc.addTrack(track, localStream);
                console.log(`‚úÖ Video track added to PC for ${userId}`);

                // ‚úÖ CRITICAL: Create new offer to renegotiate (same as video call initiation)
                const renegotiationPromise = (async () => {
                  try {
                    console.log(`üîÑ Creating renegotiation offer for ${userId}...`);

                    const offer = await pc.createOffer({
                      offerToReceiveAudio: true,
                      offerToReceiveVideo: true
                    });

                    await pc.setLocalDescription(offer);
                    console.log(`‚úÖ Renegotiation offer created for ${userId}`);

                    socketInstance.emit('webrtc_offer', {
                      callId: callData.callId,
                      targetUserId: userId,
                      offer
                    });

                    console.log(`üì§ Renegotiation offer sent to ${userId}`);
                  } catch (e) {
                    console.error(`‚ùå Renegotiation failed for ${userId}:`, e);
                  }
                })();

                renegotiationPromises.push(renegotiationPromise);

              } catch (e) {
                console.error(`‚ùå Failed to add track to PC ${userId}:`, e);
              }
            });

            // Wait for all renegotiations to complete
            await Promise.all(renegotiationPromises);
            console.log(`‚úÖ All peer connections renegotiated with video track`);

            // Attach to local video element
            const localVid = document.getElementById(`video-${currentUser.userId}`);
            if (localVid) {
              if (!localVid.srcObject) {
                localVid.srcObject = localStream;
                console.log(`‚úÖ Local stream attached to video element`);
              } else {
                // srcObject already set, just ensure video track is there
                console.log(`‚ÑπÔ∏è Video element already has srcObject, track added to stream`);
              }

              // Wait for video to be ready
              await new Promise((resolve) => {
                if (localVid.readyState >= 2) {
                  resolve();
                } else {
                  localVid.addEventListener('loadedmetadata', resolve, { once: true });
                }
              });

              try {
                await localVid.play();
                console.log(`‚ñ∂Ô∏è Local video playback started`);
              } catch (playError) {
                console.warn(`‚ö†Ô∏è Local video play warning:`, playError);
              }
            }

            wasTrackAdded = true;
            toast('Camera enabled', 'success');

          } catch (e) {
            console.error('‚ùå Failed to get video track:', e);

            if (e.name === 'NotAllowedError') {
              toast('Camera permission denied', 'error');
            } else if (e.name === 'NotFoundError') {
              toast('No camera found', 'error');
            } else {
              toast('Failed to access camera', 'error');
            }

            isTogglingVideo = false;
            return;
          }
        }

        // ‚úÖ Now we have a track - toggle it
        const newState = !track.enabled;
        track.enabled = newState;
        isVideoEnabled = newState;

        console.log(`üìπ Video track toggled: ${isVideoEnabled ? 'ON' : 'OFF'}`);
        console.log(`   Track ID: ${track.id.substring(0, 8)}...`);
        console.log(`   Track enabled: ${track.enabled}`);
        console.log(`   Track readyState: ${track.readyState}`);
        console.log(`   Track muted: ${track.muted}`);

        // Update local video element visibility
        const localVid = document.getElementById(`video-${currentUser.userId}`);
        if (localVid && localVid.srcObject) {
          console.log(`üìπ Updating local video element visibility`);
          updateVideoVisibility(currentUser.userId, isVideoEnabled, true);
        }

        // Update button state
        updateVideoButton();
        console.log(`‚úÖ Video button updated: ${isVideoEnabled ? 'ON' : 'OFF'}`);

        // ‚úÖ Emit to server (will broadcast to others)
        socketInstance.emit('video_state_changed', {
          callId: callData.callId,
          enabled: isVideoEnabled
        });
        console.log(`üì§ Emitted video_state_changed to server: ${isVideoEnabled}`);

        console.log(`üìπ ========================================`);
        console.log(`üìπ VIDEO TOGGLE COMPLETE`);
        console.log(`üìπ ========================================`);
        console.log(`   Final isVideoEnabled: ${isVideoEnabled}`);
        console.log(`   Video tracks in localStream: ${localStream.getVideoTracks().length}`);
        console.log(`   Was new track added: ${wasTrackAdded}`);
        console.log(`   Icon text: ${document.getElementById('videoBtn')?.querySelector('.material-symbols-outlined')?.textContent}`);
        console.log(`üìπ ========================================\n`);

        setTimeout(() => {
          isTogglingVideo = false;
          console.log(`üîì Video toggle unlocked`);
        }, 200);
      }

      function updateDuration() {
        const roomStr = localStorage.getItem('currentRoom');
        if (!roomStr) {
          console.warn('‚ö†Ô∏è No room data - cannot sync timer');
          return;
        }

        try {
          const roomData = JSON.parse(roomStr);

          if (!roomData.expiresAt) {
            console.error('‚ùå No expiresAt in room data');
            return;
          }

          // Use stored expiresAt if available, otherwise use from localStorage
          const expiresAt = roomExpiresAt || roomData.expiresAt;

          // CRITICAL FIX: Use server-adjusted time
          const clientNow = Date.now();
          const serverNow = clientNow + serverClockOffset; // Adjust for clock skew
          const remaining = Math.max(0, expiresAt - serverNow);

          const totalSeconds = Math.floor(remaining / 1000);
          const h = Math.floor(totalSeconds / 3600);
          const m = Math.floor((totalSeconds % 3600) / 60);
          const s = totalSeconds % 60;

          const el = document.getElementById('callDuration');
          if (el) {
            el.textContent = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
          }

          // Log every 10 seconds for debugging
          if (totalSeconds % 10 === 0) {
            console.log(`‚è∞ Call timer: ${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')} remaining`);
            console.log(`   Server expiresAt: ${new Date(expiresAt).toISOString()}`);
            console.log(`   Client now: ${new Date(clientNow).toISOString()}`);
            console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
            console.log(`   Clock offset: ${(serverClockOffset / 1000).toFixed(1)}s`);
          }

          if (remaining === 0) {
            console.log('‚è∞ Room expired during call - ending call');
            if (durationInterval) clearInterval(durationInterval);
            toast('Room has expired', 'warning');
            leaveCall();
          }
        } catch (e) {
          console.error('‚ùå Timer sync error:', e);
        }
      }

      function leaveCall() {
        if (isInitializing) return;
        isInitializing = true;
        audioContexts.forEach(ac => {
          try {
            if (ac.stop) ac.stop();
            if (ac.context && ac.context.state !== 'closed') {
              ac.context.close().catch(e => console.warn('Failed to close audio context:', e));
            }
          } catch (e) {
            console.warn('Failed to cleanup audio context:', e);
          }
        });
        audioContexts.clear();
        if (localStream) localStream.getTracks().forEach(t => t.stop());
        peerConnections.forEach(pc => pc.close());
        peerConnections.clear();
        if (socketInstance && socketInstance.connected) socketInstance.emit('leave_call', { callId: callData.callId });
        if (durationInterval) clearInterval(durationInterval);
        localStorage.removeItem('activeCall');
        setTimeout(() => { window.location.href = '/chat.html'; }, 500);
      }


      // ============================================
      // CALL STATE BROADCASTING
      // ============================================
      function broadcastCallStateToChat() {
        try {
          const activeCallData = JSON.parse(localStorage.getItem('activeCall') || '{}');
          activeCallData.connectionState = callConnectionState;
          localStorage.setItem('activeCall', JSON.stringify(activeCallData));

          // Trigger storage event for other windows/tabs
          localStorage.setItem('callStateChanged', Date.now().toString());

          console.log(`üì° Broadcasted call state: ${callConnectionState}`);
        } catch (e) {
          console.error('‚ùå Failed to broadcast call state:', e);
        }
      }


      // Add this helper function before initCall()
      let joinCallRetryCount = 0;
      const MAX_JOIN_RETRIES = 3;

      async function attemptJoinCall(callId, retryDelay = 1000) {
        return new Promise((resolve, reject) => {
          console.log(`üîÑ Attempting to join call (attempt ${joinCallRetryCount + 1}/${MAX_JOIN_RETRIES})`);

          socketInstance.emit('join_call', { callId });

          // Set timeout for response
          const timeout = setTimeout(() => {
            joinCallRetryCount++;

            if (joinCallRetryCount < MAX_JOIN_RETRIES) {
              console.warn(`‚ö†Ô∏è Join call timeout, retrying in ${retryDelay}ms...`);
              setTimeout(() => {
                attemptJoinCall(callId, retryDelay * 1.5).then(resolve).catch(reject);
              }, retryDelay);
            } else {
              reject(new Error('Failed to join call after maximum retries'));
            }
          }, 5000); // 5 second timeout per attempt

          // Listen for successful join (one-time)
          const handleJoined = (data) => {
            clearTimeout(timeout);
            joinCallRetryCount = 0; // Reset on success
            console.log(`‚úÖ Join call succeeded on attempt ${joinCallRetryCount + 1}`);
            socketInstance.off('call_joined', handleJoined);
            socketInstance.off('error', handleError);
            resolve(data);
          };

          const handleError = (errorData) => {
            clearTimeout(timeout);
            socketInstance.off('call_joined', handleJoined);
            socketInstance.off('error', handleError);
            reject(new Error(errorData.message || 'Join call failed'));
          };

          socketInstance.once('call_joined', handleJoined);
          socketInstance.once('error', handleError);
        });
      }


      async function initCall() {

        const returningToBackground = sessionStorage.getItem('returningToBackgroundCall') === 'true';

        if (returningToBackground) {
          console.log('üîÑ ========================================');
          console.log('üîÑ RETURNING TO BACKGROUND CALL');
          console.log('üîÑ ========================================');

          sessionStorage.removeItem('returningToBackgroundCall');

          // Call is already active, we're just returning to the UI
          console.log('‚ÑπÔ∏è Call connections should already be active');
          console.log('‚ÑπÔ∏è Reconnecting to existing call state...');

          // The rest of initCall will handle reconnection
        }

        if (isInitializing) return;
        isInitializing = true;
        console.log('=== INIT CALL ===');

        try {
          await _Auth.requireAuth();
          await fetchIceServers();

          const callStr = localStorage.getItem('activeCall');
          if (!callStr) { toast('No active call', 'error'); setTimeout(() => window.location.href = '/chat.html', 1500); return; }

          callData = JSON.parse(callStr);
          console.log(`üìû Call: ${callData.callId} (${callData.callType})`);

          const firebaseUser = firebase.auth().currentUser;
          if (!firebaseUser) { window.location.href = '/login.html'; return; }

          const userData = await _API.get('/api/users/me');
          currentUser = { userId: userData._id, username: userData.username, pfpUrl: userData.pfpUrl };
          console.log(`üë§ Current user: ${currentUser.username} (${currentUser.userId})`);

          const title = document.getElementById('callTitle');
          if (title) title.textContent = `${callData.callType === 'video' ? 'Video' : 'Audio'} Call`;

          const token = await firebaseUser.getIdToken();
          socketInstance = io(window.location.origin, {
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            auth: { token }
          });

          socketInstance.on('connect', () => {
            console.log(`üîå Connected: ${socketInstance.id}`);
            socketInstance.emit('authenticate', { token, userId: currentUser.userId });
          });

          // Inside initCall() function, replace the 'authenticated' handler:



          socketInstance.on('room_expired', (data) => {
            console.error('üí• ========================================');
            console.error('üí• ROOM_EXPIRED EVENT RECEIVED FROM SERVER');
            console.error('üí• ========================================');
            console.error(`   roomId: ${data.roomId}`);
            console.error(`   message: ${data.message}`);
            console.error(`   Server says room expired at: ${new Date().toISOString()}`);

            if (roomExpiresAt) {
              const serverExpiry = new Date(roomExpiresAt).toISOString();
              const clientNow = new Date().toISOString();
              const serverNow = new Date(Date.now() + serverClockOffset).toISOString();
              console.error(`   expiresAt was: ${serverExpiry}`);
              console.error(`   Client time now: ${clientNow}`);
              console.error(`   Server time now (adjusted): ${serverNow}`);
            }

            console.error('üí• ========================================\n');

            if (durationInterval) clearInterval(durationInterval);
            toast(data.message || 'Room has expired', 'warning');

            // Clean up and redirect
            leaveCall();
          });

          socketInstance.on('room_expiring_soon', (data) => {
            console.warn('‚ö†Ô∏è ========================================');
            console.warn('‚ö†Ô∏è ROOM EXPIRING SOON');
            console.warn('‚ö†Ô∏è ========================================');
            console.warn(`   Expires in: ${data.expiresIn / 1000} seconds`);
            console.warn(`   expiresAt: ${new Date(data.expiresAt).toISOString()}`);

            const clientNow = Date.now();
            const serverNow = clientNow + serverClockOffset;
            const remaining = data.expiresAt - serverNow;

            console.warn(`   Client now: ${new Date(clientNow).toISOString()}`);
            console.warn(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
            console.warn(`   Remaining (adjusted): ${(remaining / 1000).toFixed(1)}s`);
            console.warn('‚ö†Ô∏è ========================================\n');

            toast(`Room expiring soon!`, 'warning');
          });

          socketInstance.on('authenticated', async () => {
            console.log('‚úÖ Authenticated');

            // CRITICAL: Request room data from server to get clock sync
            const roomStr = localStorage.getItem('currentRoom');
            if (roomStr) {
              try {
                const roomData = JSON.parse(roomStr);
                console.log('üì¶ Requesting fresh room data for clock sync...');

                // Emit a request for fresh room data (you'll need to add this handler on server)
                socketInstance.emit('request_room_sync', { roomId: roomData.roomId });

              } catch (e) {
                console.error('‚ùå Failed to parse room data:', e);
              }
            }

            // CRITICAL FIX: Prevent duplicate join attempts
            if (isJoiningCall) {
              console.warn(`‚ö†Ô∏è Already joining call, ignoring duplicate authenticated event`);
              return;
            }

            if (!hasJoinedCall) {
              isJoiningCall = true;
              hasJoinedCall = true;

              try {
                console.log(`üìû Attempting to join call ${callData.callId}...`);
                await attemptJoinCall(callData.callId);
                console.log(`‚úÖ Successfully joined call ${callData.callId}`);
              } catch (error) {
                console.error('‚ùå Failed to join call:', error);
                toast('Failed to join call. Returning to chat...', 'error');
                setTimeout(() => {
                  window.location.href = '/chat.html';
                }, 2000);
              } finally {
                isJoiningCall = false;
              }
            }
          });


          socketInstance.on('room_sync_data', (data) => {
            console.log('‚è∞ ========================================');
            console.log('‚è∞ ROOM SYNC DATA RECEIVED');
            console.log('‚è∞ ========================================');

            const clientNow = Date.now();

            if (!data.serverTime) {
              console.warn('‚ö†Ô∏è No serverTime in sync data, assuming no clock skew');
              data.serverTime = clientNow;
            }

            // Calculate clock offset
            serverClockOffset = data.serverTime - clientNow;

            console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
            console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
            console.log(`   ‚è∞ CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);

            if (Math.abs(serverClockOffset) > 5000) {
              console.warn(`‚ö†Ô∏è WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
              console.warn(`   Timer will be adjusted to compensate`);
            }

            if (data.expiresAt) {
              roomExpiresAt = data.expiresAt;

              // Calculate time remaining using server-adjusted time
              const serverNow = clientNow + serverClockOffset;
              const timeRemaining = data.expiresAt - serverNow;

              console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
              console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
              console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);

              // Update localStorage with synced data
              const roomStr = localStorage.getItem('currentRoom');
              if (roomStr) {
                try {
                  const roomData = JSON.parse(roomStr);
                  roomData.expiresAt = data.expiresAt;
                  localStorage.setItem('currentRoom', JSON.stringify(roomData));
                  console.log('‚úÖ Updated localStorage with server expiry time');
                } catch (e) {
                  console.error('‚ùå Failed to update localStorage:', e);
                }
              }
            }

            console.log('‚è∞ ========================================\n');

            // Force timer update with new data
            updateDuration();
          });


          socketInstance.on('webrtc_offer', (d) => {
            console.log(`üîî [SOCKET] webrtc_offer event received from ${d.fromUserId}`);
            handleOffer(d.fromUserId, d.offer);
          });

          socketInstance.on('webrtc_answer', (d) => {
            console.log(`üîî [SOCKET] webrtc_answer event received from ${d.fromUserId}`);
            handleAnswer(d.fromUserId, d.answer);
          });

          socketInstance.on('ice_candidate', (d) => {
            console.log(`üîî [SOCKET] ice_candidate event received from ${d.fromUserId}`);
            handleIceCandidate(d.fromUserId, d.candidate);
          });


          socketInstance.on('call_joined', async (data) => {
            console.log(`‚úÖ ========================================`);
            console.log(`‚úÖ CALL_JOINED EVENT RECEIVED`);
            console.log(`‚úÖ ========================================`);
            console.log(`üìä Participants: ${data.participants.length}`);

            // CRITICAL: Update connection state
            console.log(`üìû Call state transition: ${callConnectionState} ‚Üí connecting`);
            callConnectionState = 'connecting';
            broadcastCallStateToChat();


            // Log all participants
            data.participants.forEach((p, i) => {
              console.log(`   [${i}] ${p.username} (${p.userId}) video:${p.videoEnabled} audio:${p.audioEnabled}`);
            });

            if (!data.participants || data.participants.length === 0) {
              console.error('‚ùå Received call_joined with 0 participants!');
              toast('Call state error. Please try again.', 'error');
              setTimeout(() => {
                window.location.href = '/chat.html';
              }, 2000);
              return;
            }

            const subtitle = document.getElementById('callSubtitle');
            if (subtitle) subtitle.textContent = `${data.participants.length} participant${data.participants.length > 1 ? 's' : ''}`;

            console.log(`üé¨ Initializing local media...`);
            try {
              await initLocalMedia();
              console.log(`‚úÖ Local media initialized successfully`);
            } catch (mediaError) {
              console.error(`‚ùå Media initialization failed:`, mediaError);
              toast('Failed to initialize media.', 'error');
            }

            if (!localStream) {
              console.error(`‚ùå CRITICAL: localStream is still null!`);
              localStream = new MediaStream();
            }

            console.log(`üìä LocalStream: ${localStream.getTracks().length} tracks`);
            localStream.getTracks().forEach((track, i) => {
              console.log(`   [${i}] ${track.kind} (${track.id.substring(0, 8)}...) enabled:${track.enabled}`);
            });

            const grid = document.getElementById('participantGrid');
            if (!grid) {
              console.error('‚ùå Grid element not found!');
              return;
            }

            const fragment = document.createDocumentFragment();

            console.log(`üßπ Clearing grid and tracking`);
            grid.innerHTML = '';
            renderedParticipants.clear();

            console.log(`üìã Rendering ${data.participants.length} tiles`);

            const sortedParticipants = [...data.participants].sort((a, b) =>
              a.userId.localeCompare(b.userId)
            );

            let selfTileRendered = false;

            sortedParticipants.forEach((p, index) => {
              const isSelf = p.userId === currentUser.userId;
              const videoState = p.videoEnabled !== undefined ? p.videoEnabled : (callData.callType === 'video');
              const audioState = p.audioEnabled !== undefined ? p.audioEnabled : true;

              console.log(`[${index}] Rendering ${p.username} (${p.userId}) isSelf=${isSelf} video=${videoState} audio=${audioState}`);

              const tile = createParticipantTile(p, isSelf);
              if (tile) {
                fragment.appendChild(tile);
                console.log(`‚úÖ [${index}] Tile created for ${p.username}`);

                if (isSelf) selfTileRendered = true;

                if (audioState === false) {
                  const micIndicator = tile.querySelector(`#mic-${p.userId}`);
                  if (micIndicator) {
                    micIndicator.classList.remove('hidden');
                    console.log(`   üîá Mic indicator shown for ${p.username}`);
                  }
                }

                if (!isSelf && videoState === false) {
                  const vid = tile.querySelector(`#video-${p.userId}`);
                  const pfp = tile.querySelector(`#pfp-${p.userId}`);
                  if (vid && pfp) {
                    vid.classList.add('hidden');
                    pfp.classList.remove('hidden');
                    console.log(`   üìπ Video hidden for ${p.username}`);
                  }
                }
              }
            });

            grid.appendChild(fragment);

            console.log(`üé® Grid complete: ${grid.children.length} tiles`);
            console.log(`üìä Rendered participants:`, Array.from(renderedParticipants));

            if (selfTileRendered) {
              console.log(`üé¨ Setting up local video...`);
              await setupLocalVideo();
            } else {
              console.warn(`‚ö†Ô∏è Self tile not rendered!`);
            }

            const remoteParticipants = sortedParticipants.filter(p => p.userId !== currentUser.userId);

            console.log(`üîó Processing ${remoteParticipants.length} remote participants for WebRTC...`);

            for (let i = 0; i < remoteParticipants.length; i++) {
              const p = remoteParticipants[i];
              const shouldInitiateOffer = currentUser.userId < p.userId;

              console.log(`üîó [${i}] ${p.username} (${p.userId}): shouldInitiate=${shouldInitiateOffer}`);

              if (shouldInitiateOffer) {
                const delay = 1000 + (i * 500);
                console.log(`   ‚è±Ô∏è Will create offer in ${delay}ms`);
                setTimeout(() => {
                  console.log(`üì§ [${i}] Creating offer to ${p.username}`);
                  createOffer(p.userId);
                }, delay);
              } else {
                console.log(`   ‚è≥ Will wait for offer from ${p.username}`);
              }
            }

            console.log('‚è∞ Starting synced timer with room expiry and clock compensation');
            console.log(`   Clock offset: ${(serverClockOffset / 1000).toFixed(1)}s`);

            durationInterval = setInterval(updateDuration, 1000);
            updateDuration(); // Update immediately

            isInitializing = false;
            console.log('‚úÖ ========================================');
            console.log('‚úÖ INIT COMPLETE');
            console.log('‚úÖ ========================================\n');
          });

          // Replace the entire user_joined_call handler
          socketInstance.on('user_joined_call', (data) => {
            const videoState = data.user.videoEnabled !== undefined ? data.user.videoEnabled : (callData.callType === 'video');
            const audioState = data.user.audioEnabled !== undefined ? data.user.audioEnabled : true;

            console.log(`üëã User joined event: ${data.user.username} (${data.user.userId}) video:${videoState} audio:${audioState}`);

            // CRITICAL FIX: Check if this is a duplicate event for already-rendered participant
            if (renderedParticipants.has(data.user.userId)) {
              console.warn(`‚ö†Ô∏è Participant ${data.user.username} already rendered, ignoring duplicate user_joined_call`);
              return;
            }

            const grid = document.getElementById('participantGrid');
            const existingTile = document.getElementById(`participant-${data.user.userId}`);

            if (existingTile) {
              console.warn(`‚ö†Ô∏è Tile already exists in DOM for ${data.user.username}, removing old tile`);
              existingTile.remove();
              renderedParticipants.delete(data.user.userId);
            }

            console.log(`‚ûï Adding NEW participant ${data.user.username}`);

            if (grid) {
              const isSelf = data.user.userId === currentUser.userId;
              const tile = createParticipantTile(data.user, isSelf);

              if (tile) {
                grid.appendChild(tile);

                const micIndicator = document.getElementById(`mic-${data.user.userId}`);
                if (micIndicator && audioState === false) {
                  micIndicator.classList.remove('hidden');
                }

                // CRITICAL FIX: If this is our own tile, setup local video NOW
                if (isSelf) {
                  console.log(`‚úÖ Self tile created via user_joined_call - setting up local video...`);
                  setupLocalVideo().catch(err => {
                    console.error('‚ùå Failed to setup local video for self:', err);
                  });
                } else {
                  // For remote users, initiate connection with delay to avoid race
                  const shouldInitiateOffer = currentUser.userId < data.user.userId;
                  if (shouldInitiateOffer) {
                    setTimeout(() => {
                      console.log(`üì§ Creating offer to late joiner ${data.user.username}`);
                      createOffer(data.user.userId);
                    }, 2000); // Increased delay to 2s
                  }
                }

                console.log(`‚úÖ Tile rendered for ${data.user.username}, tracking set updated`);
              }
            }
          });

          socketInstance.on('user_left_call', (data) => {
            console.log(`üëã User left: ${data.userId}`);

            // Remove tile
            const tile = document.getElementById(`participant-${data.userId}`);
            if (tile) tile.remove();
            renderedParticipants.delete(data.userId);

            // Clean up peer connection
            const pc = peerConnections.get(data.userId);
            if (pc) {
              pc.close();
              peerConnections.delete(data.userId);
            }

            // CRITICAL FIX: Clean up audio context properly
            const ac = audioContexts.get(data.userId);
            if (ac) {
              if (ac.stop) ac.stop(); // Stop detection first
              if (ac.context && ac.context.state !== 'closed') {
                ac.context.close().catch(e => console.warn('Failed to close audio context:', e));
              }
              audioContexts.delete(data.userId);
            }

            // Clean up connection stats and monitoring
            const stats = connectionStats.get(data.userId);
            if (stats && stats.monitorInterval) {
              clearInterval(stats.monitorInterval);
            }
            connectionStats.delete(data.userId);

            // Clean up pending candidates
            pendingIceCandidates.delete(data.userId);

            // Clean up negotiation mutex
            negotiationMutex.delete(data.userId);
            makingOffer.delete(data.userId);

            console.log(`‚úÖ Fully cleaned up resources for ${data.userId}`);
          });

          socketInstance.on('webrtc_offer', (d) => handleOffer(d.fromUserId, d.offer));
          socketInstance.on('webrtc_answer', (d) => handleAnswer(d.fromUserId, d.answer));
          socketInstance.on('ice_candidate', (d) => handleIceCandidate(d.fromUserId, d.candidate));

          socketInstance.on('speaking_state', (d) => {
            const s = document.getElementById(`speaking-${d.userId}`);
            const t = document.getElementById(`participant-${d.userId}`);
            if (s && t) {
              if (d.speaking) { s.classList.remove('hidden'); t.classList.add('active-speaker'); }
              else { s.classList.add('hidden'); t.classList.remove('active-speaker'); }
            }
          });

          socketInstance.on('audio_state_changed', (data) => {
            console.log(`üé§ Received audio_state_changed: userId=${data.userId}, enabled=${data.enabled}`);

            const micIndicator = document.getElementById(`mic-${data.userId}`);
            if (micIndicator) {
              if (data.enabled) {
                micIndicator.classList.add('hidden');
              } else {
                micIndicator.classList.remove('hidden');
              }
            }
          });

          socketInstance.on('video_state_changed', (data) => {
            console.log(`üìπ ========================================`);
            console.log(`üìπ RECEIVED: video_state_changed`);
            console.log(`üìπ ========================================`);
            console.log(`   From userId: ${data.userId}`);
            console.log(`   New state: ${data.enabled ? 'ON' : 'OFF'}`);
            console.log(`   My userId: ${currentUser.userId}`);

            // Sanity check - should NEVER receive own state back
            if (data.userId === currentUser.userId) {
              console.error(`‚ùå CRITICAL: Received own video state from server!`);
              console.error(`   This should not happen - server should exclude sender`);
              console.error(`   Ignoring to prevent state desync`);
              console.log(`üìπ ========================================\n`);
              return;
            }

            // ‚úÖ Update remote user's video visibility
            console.log(`üìπ Updating remote user ${data.userId} video visibility: ${data.enabled}`);

            // ‚úÖ CRITICAL: Check if video element has video tracks
            const remoteVideo = document.getElementById(`video-${data.userId}`);
            if (remoteVideo && remoteVideo.srcObject) {
              const videoTracks = remoteVideo.srcObject.getVideoTracks();
              console.log(`   Remote video element has ${videoTracks.length} video track(s)`);

              if (videoTracks.length === 0 && data.enabled) {
                console.warn(`‚ö†Ô∏è Remote wants to show video but no video tracks in stream yet`);
                console.warn(`   Waiting for ontrack event to deliver video track...`);
                // Don't update visibility yet - wait for track to arrive
                console.log(`üìπ ========================================\n`);
                return;
              }
            }

            updateVideoVisibility(data.userId, data.enabled, true);

            console.log(`‚úÖ Remote video state updated successfully`);
            console.log(`üìπ ========================================\n`);
          });

          socketInstance.on('call_ended', () => { toast('Call ended', 'warning'); leaveCall(); });

          const mic = document.getElementById('micBtn');
          const vid = document.getElementById('videoBtn');
          const leave = document.getElementById('leaveCallBtn');
          if (mic) mic.addEventListener('click', toggleMic);
          if (vid) vid.addEventListener('click', toggleVideo);
          if (leave) leave.addEventListener('click', leaveCall, { passive: true });

          // Setup back button handler for background call
          setupCallBackButtonHandler();

          // Setup cleanup handler
          setupCallCleanup();

          console.log('‚úÖ Call page event handlers initialized');

        } catch (e) {
          console.error('‚ùå Init error:', e);
          toast('Failed to initialize call', 'error');
          isInitializing = false;
          setTimeout(() => window.location.href = '/chat.html', 2000);
        }
      }

      console.log('‚úÖ Page loaded - starting initialization');
      initCall();
    })();
  </script>
</body>

</html>
