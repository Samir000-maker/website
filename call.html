<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Call - MoodLog</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#33bfcc",
                        "background-light": "#f2f2f3",
                        "background-dark": "#1c1e22",
                        "surface-dark": "#272A2E",
                        "accent-red": "#ef4444",
                    },
                    fontFamily: {
                        "display": ["Manrope", "sans-serif"]
                    },
                    borderRadius: {
                        "DEFAULT": "0.5rem",
                        "lg": "1rem",
                        "xl": "1.5rem",
                        "full": "9999px"
                    },
                },
            },
        }
    </script>
    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }
        .active-speaker {
            box-shadow: 0 0 0 3px #33bfcc;
        }
        body {
            font-family: 'Manrope', sans-serif;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .video-tile {
            position: relative;
            background: #1c1e22;
        }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-900 dark:text-white min-h-screen flex flex-col font-display">
    <!-- Top Navigation Bar -->
    <header class="w-full border-b border-slate-200 dark:border-slate-800 px-6 py-4 flex items-center justify-between bg-background-light dark:bg-background-dark">
        <div class="flex items-center gap-4">
            <div class="bg-primary/20 p-2 rounded-lg">
                <span class="material-symbols-outlined text-primary">graphic_eq</span>
            </div>
            <div>
                <h1 class="text-lg font-bold tracking-tight" id="callTitle">Mindful Space Call</h1>
                <p class="text-xs text-slate-500 dark:text-slate-400" id="callSubtitle">Connecting...</p>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-2 bg-slate-200 dark:bg-surface-dark px-4 py-2 rounded-xl border border-slate-300 dark:border-slate-700">
                <span class="relative flex h-2 w-2">
                    <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-primary opacity-75"></span>
                    <span class="relative inline-flex rounded-full h-2 w-2 bg-primary"></span>
                </span>
                <span class="text-sm font-bold font-mono" id="callDuration">00:00:00</span>
            </div>
            <button class="p-2 hover:bg-slate-200 dark:hover:bg-surface-dark rounded-lg transition-colors">
                <span class="material-symbols-outlined">settings</span>
            </button>
            <button class="p-2 hover:bg-slate-200 dark:hover:bg-surface-dark rounded-lg transition-colors">
                <span class="material-symbols-outlined">info</span>
            </button>
        </div>
    </header>

    <!-- Main Content: Participant Grid -->
    <main class="flex-1 overflow-y-auto p-6 md:p-12">
        <div class="max-w-6xl mx-auto">
            <div id="participantGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                <!-- Participant tiles will be dynamically generated here -->
            </div>
        </div>
    </main>

    <!-- Bottom Persistent Control Bar -->
    <footer class="w-full p-6 flex justify-center sticky bottom-0 bg-gradient-to-t from-background-light dark:from-background-dark via-background-light/95 dark:via-background-dark/95 to-transparent">
        <div class="bg-white dark:bg-surface-dark shadow-2xl rounded-2xl border border-slate-200 dark:border-slate-700 p-2 flex items-center gap-2">
            <!-- Standard Controls -->
            <div class="flex items-center gap-1 px-2 border-r border-slate-200 dark:border-slate-700">
                <button id="micBtn" class="w-12 h-12 flex items-center justify-center rounded-xl bg-primary text-white hover:opacity-90 transition-all active:scale-95">
                    <span class="material-symbols-outlined">mic</span>
                </button>
                <button id="videoBtn" class="w-12 h-12 flex items-center justify-center rounded-xl text-slate-500 hover:bg-slate-100 dark:hover:bg-slate-700 transition-all">
                    <span class="material-symbols-outlined">videocam_off</span>
                </button>
                <button id="screenShareBtn" class="w-12 h-12 flex items-center justify-center rounded-xl text-slate-500 hover:bg-slate-100 dark:hover:bg-slate-700 transition-all">
                    <span class="material-symbols-outlined">screen_share</span>
                </button>
            </div>
            <!-- Mood Specific Control -->
            <div class="flex items-center gap-2 px-4">
                <button id="moodBtn" class="flex items-center gap-2 px-4 h-12 rounded-xl bg-slate-100 dark:bg-background-dark text-slate-700 dark:text-white border border-slate-200 dark:border-slate-700 hover:border-primary transition-all">
                    <span class="text-xl" id="currentMoodEmoji">ðŸ˜Š</span>
                    <span class="text-sm font-bold">Update Mood</span>
                </button>
            </div>
            <!-- Leave Button -->
            <div class="pl-2">
                <button id="leaveCallBtn" class="flex items-center gap-2 px-6 h-12 rounded-xl bg-accent-red text-white hover:brightness-110 shadow-lg shadow-accent-red/20 transition-all active:scale-95">
                    <span class="material-symbols-outlined font-bold">call_end</span>
                    <span class="font-bold text-sm">Leave Call</span>
                </button>
            </div>
        </div>
    </footer>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };

      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>

    <!-- Socket.IO -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>

    <!-- App -->
    <script src="app.js"></script>

    <script>
    (async () => {
      const MoodApp = window.MoodApp || {};
      const _Auth = MoodApp.Auth;
      const _API = MoodApp.API;
      const _Toast = MoodApp.Toast;

      const toast = (m, t='success') => { 
        if (_Toast && typeof _Toast[t] === 'function') return _Toast[t](m); 
        console[t==='error'?'error':'log'](m); 
      };

      // Enhanced WebRTC Configuration with proper STUN usage
      const ICE_SERVERS = {
        iceServers: [
          { 
            urls: [
              'stun:stun.cloudflare.com:3478',
              'stun:stun.cloudflare.com:53'
            ]
          }
        ],
        iceCandidatePoolSize: 10,
        iceTransportPolicy: 'all', // Use all candidates (relay and direct)
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      };

      // State management
      let localStream = null;
      let peerConnections = new Map(); // userId -> RTCPeerConnection
      let socketInstance = null;
      let callData = null;
      let currentUser = null;
      let isAudioEnabled = true;
      let isVideoEnabled = false;
      let callStartTime = null;
      let durationInterval = null;
      let isInitializing = false;
      let hasJoinedCall = false;

      // Helper function to create profile picture element
      function createProfilePictureElement(pfpUrl, username, size = 'w-24 h-24') {
        const initial = username ? username.charAt(0).toUpperCase() : 'U';
        const container = document.createElement('div');
        container.className = `${size} rounded-full overflow-hidden bg-slate-100 dark:bg-slate-800 border-4 border-primary/30 flex-shrink-0`;
        
        if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
          const img = document.createElement('img');
          img.src = pfpUrl;
          img.alt = username;
          img.className = 'h-full w-full object-cover';
          img.onerror = function() {
            this.onerror = null;
            container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-2xl">${initial}</div>`;
          };
          container.appendChild(img);
        } else {
          container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-2xl">${initial}</div>`;
        }
        
        return container;
      }

      // Create participant tile
      function createParticipantTile(user, isSelf = false) {
        const tile = document.createElement('div');
        tile.id = `participant-${user.userId}`;
        tile.className = `video-tile relative group bg-slate-100 dark:bg-surface-dark rounded-xl p-6 flex flex-col items-center justify-center text-center border transition-all duration-300 ${isSelf ? 'border-2 border-dashed border-primary/40 bg-primary/10 dark:bg-primary/5' : 'border-transparent hover:border-slate-300 dark:hover:border-slate-600'}`;
        
        // Video container
        const videoContainer = document.createElement('div');
        videoContainer.className = 'relative mb-4';
        
        // Video element (hidden by default until video is enabled)
        const videoElement = document.createElement('video');
        videoElement.id = `video-${user.userId}`;
        videoElement.className = 'w-24 h-24 rounded-full object-cover hidden';
        videoElement.autoplay = true;
        videoElement.playsInline = true;
        if (isSelf) {
          videoElement.muted = true;
        }
        
        // Profile picture (shown when video is off)
        const pfpElement = createProfilePictureElement(user.pfpUrl, user.username, 'w-24 h-24');
        pfpElement.id = `pfp-${user.userId}`;
        
        videoContainer.appendChild(videoElement);
        videoContainer.appendChild(pfpElement);
        
        // Mood emoji badge
        const moodBadge = document.createElement('div');
        moodBadge.className = 'absolute -bottom-1 -right-1 bg-white dark:bg-background-dark p-1.5 rounded-full shadow-lg border border-slate-200 dark:border-slate-700';
        moodBadge.innerHTML = '<span class="text-xl leading-none">ðŸ˜Š</span>';
        videoContainer.appendChild(moodBadge);
        
        // Mic status indicator
        const micIndicator = document.createElement('div');
        micIndicator.id = `mic-${user.userId}`;
        micIndicator.className = 'absolute top-0 right-0 bg-accent-red p-1 rounded-full text-white hidden';
        micIndicator.innerHTML = '<span class="material-symbols-outlined text-[14px] font-bold">mic_off</span>';
        videoContainer.appendChild(micIndicator);
        
        tile.appendChild(videoContainer);
        
        // User info
        const userInfo = document.createElement('div');
        const username = document.createElement('p');
        username.className = 'text-slate-900 dark:text-white text-base font-bold';
        username.textContent = isSelf ? 'You' : (user.username || 'User');
        
        const status = document.createElement('p');
        status.id = `status-${user.userId}`;
        status.className = 'text-slate-500 dark:text-slate-400 text-sm';
        status.textContent = 'Connecting...';
        
        userInfo.appendChild(username);
        userInfo.appendChild(status);
        tile.appendChild(userInfo);
        
        return tile;
      }

      // Initialize local media with better constraints
      async function initializeLocalMedia() {
        try {
          console.log('ðŸŽ¤ Requesting local media...', callData.callType);
          
          const constraints = {
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            },
            video: callData.callType === 'video' ? {
              width: { ideal: 640 },
              height: { ideal: 480 },
              frameRate: { ideal: 30 }
            } : false
          };
          
          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          console.log('âœ… Local media initialized:', localStream.getTracks().map(t => t.kind));
          
          // Update video state
          isVideoEnabled = callData.callType === 'video';
          isAudioEnabled = true;
          
          // Add local video if video call
          if (isVideoEnabled) {
            const localVideo = document.getElementById(`video-${currentUser.userId}`);
            const localPfp = document.getElementById(`pfp-${currentUser.userId}`);
            if (localVideo && localStream) {
              localVideo.srcObject = localStream;
              await localVideo.play().catch(e => console.warn('Video play warning:', e));
              localVideo.classList.remove('hidden');
              if (localPfp) localPfp.classList.add('hidden');
            }
          }
          
          return localStream;
        } catch (error) {
          console.error('âŒ Failed to get local media:', error);
          toast('Failed to access camera/microphone. Please check permissions.', 'error');
          throw error;
        }
      }

      // Create peer connection with enhanced configuration
      function createPeerConnection(userId) {
        console.log('ðŸ”— Creating peer connection for:', userId);
        
        const pc = new RTCPeerConnection(ICE_SERVERS);
        
        // Add local tracks
        if (localStream) {
          localStream.getTracks().forEach(track => {
            const sender = pc.addTrack(track, localStream);
            console.log('ðŸ“¤ Added local track:', track.kind, 'to', userId);
          });
        }
        
        // Handle incoming tracks
        pc.ontrack = (event) => {
          console.log('ðŸ“¹ Received remote track from:', userId, event.track.kind, 'readyState:', event.track.readyState);
          const remoteVideo = document.getElementById(`video-${userId}`);
          const remotePfp = document.getElementById(`pfp-${userId}`);
          
          if (remoteVideo) {
            if (!remoteVideo.srcObject) {
              remoteVideo.srcObject = new MediaStream();
            }
            remoteVideo.srcObject.addTrack(event.track);
            
            // Auto-play remote video
            remoteVideo.play().catch(e => console.warn('Remote video play warning:', e));
            
            // Show video if it's a video track and has frames
            if (event.track.kind === 'video') {
              event.track.onunmute = () => {
                console.log('ðŸ“¹ Video track unmuted for:', userId);
                remoteVideo.classList.remove('hidden');
                if (remotePfp) remotePfp.classList.add('hidden');
              };
            }
          }
        };
        
        // Handle ICE candidates - IMPORTANT: Send all candidates immediately
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            console.log('ðŸ§Š Sending ICE candidate to:', userId, event.candidate.type);
            socketInstance.emit('ice_candidate', {
              callId: callData.callId,
              targetUserId: userId,
              candidate: event.candidate
            });
          } else {
            console.log('ðŸ§Š ICE gathering completed for:', userId);
          }
        };
        
        // Monitor ICE gathering state
        pc.onicegatheringstatechange = () => {
          console.log(`ðŸ§Š ICE gathering state for ${userId}:`, pc.iceGatheringState);
        };
        
        // Handle connection state changes with better logging
        pc.onconnectionstatechange = () => {
          console.log(`ðŸ”Œ Connection state with ${userId}:`, pc.connectionState);
          const statusEl = document.getElementById(`status-${userId}`);
          if (statusEl) {
            switch (pc.connectionState) {
              case 'connected':
                statusEl.textContent = 'Connected';
                statusEl.className = 'text-primary text-xs font-semibold uppercase tracking-wider';
                break;
              case 'connecting':
                statusEl.textContent = 'Connecting...';
                statusEl.className = 'text-yellow-500 text-sm';
                break;
              case 'disconnected':
                statusEl.textContent = 'Reconnecting...';
                statusEl.className = 'text-yellow-500 text-sm';
                break;
              case 'failed':
                console.error('âŒ Connection failed with:', userId);
                statusEl.textContent = 'Connection failed';
                statusEl.className = 'text-red-500 text-sm';
                // Attempt to reconnect
                setTimeout(() => {
                  if (pc.connectionState === 'failed') {
                    console.log('ðŸ”„ Attempting to restart ICE for:', userId);
                    pc.restartIce();
                  }
                }, 1000);
                break;
              case 'closed':
                statusEl.textContent = 'Disconnected';
                statusEl.className = 'text-slate-500 text-sm';
                break;
            }
          }
        };
        
        // Monitor ICE connection state
        pc.oniceconnectionstatechange = () => {
          console.log(`ðŸ§Š ICE connection state with ${userId}:`, pc.iceConnectionState);
          if (pc.iceConnectionState === 'failed') {
            console.error('âŒ ICE connection failed with:', userId);
            console.log('ðŸ’¡ Attempting ICE restart...');
            pc.restartIce();
          }
        };
        
        peerConnections.set(userId, pc);
        return pc;
      }

      // Create and send offer
      async function createOffer(userId) {
        try {
          console.log('ðŸ“¤ Creating offer for:', userId);
          const pc = createPeerConnection(userId);
          
          const offer = await pc.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: callData.callType === 'video'
          });
          
          await pc.setLocalDescription(offer);
          console.log('ðŸ“¤ Sending offer to:', userId);
          
          socketInstance.emit('webrtc_offer', {
            callId: callData.callId,
            targetUserId: userId,
            offer: offer
          });
        } catch (error) {
          console.error('âŒ Error creating offer for', userId, ':', error);
        }
      }

      // Handle incoming offer
      async function handleOffer(fromUserId, offer) {
        try {
          console.log('ðŸ“¥ Received offer from:', fromUserId);
          const pc = createPeerConnection(fromUserId);
          
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          console.log('âœ… Set remote description from:', fromUserId);
          
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          
          console.log('ðŸ“¤ Sending answer to:', fromUserId);
          socketInstance.emit('webrtc_answer', {
            callId: callData.callId,
            targetUserId: fromUserId,
            answer: answer
          });
        } catch (error) {
          console.error('âŒ Error handling offer from', fromUserId, ':', error);
        }
      }

      // Handle incoming answer
      async function handleAnswer(fromUserId, answer) {
        try {
          console.log('ðŸ“¥ Received answer from:', fromUserId);
          const pc = peerConnections.get(fromUserId);
          if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
            console.log('âœ… Set remote description (answer) from:', fromUserId);
          } else {
            console.warn('âš ï¸ No peer connection found for:', fromUserId);
          }
        } catch (error) {
          console.error('âŒ Error handling answer from', fromUserId, ':', error);
        }
      }

      // Handle ICE candidate
      async function handleIceCandidate(fromUserId, candidate) {
        try {
          const pc = peerConnections.get(fromUserId);
          if (pc && pc.remoteDescription) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            console.log('ðŸ§Š Added ICE candidate from:', fromUserId, candidate.type);
          } else {
            console.warn('âš ï¸ Cannot add ICE candidate - no peer connection or remote description for:', fromUserId);
          }
        } catch (error) {
          console.error('âŒ Error adding ICE candidate from', fromUserId, ':', error);
        }
      }

      // Toggle microphone
      function toggleMicrophone() {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            isAudioEnabled = audioTrack.enabled;
            
            const micBtn = document.getElementById('micBtn');
            const micIcon = micBtn.querySelector('.material-symbols-outlined');
            const micIndicator = document.getElementById(`mic-${currentUser.userId}`);
            
            if (isAudioEnabled) {
              micBtn.classList.add('bg-primary', 'text-white');
              micBtn.classList.remove('bg-accent-red');
              micIcon.textContent = 'mic';
              if (micIndicator) micIndicator.classList.add('hidden');
            } else {
              micBtn.classList.remove('bg-primary', 'text-white');
              micBtn.classList.add('bg-accent-red', 'text-white');
              micIcon.textContent = 'mic_off';
              if (micIndicator) micIndicator.classList.remove('hidden');
            }
            
            // Notify other participants
            socketInstance.emit('audio_state_changed', {
              callId: callData.callId,
              enabled: isAudioEnabled
            });
          }
        }
      }

      // Toggle video
      async function toggleVideo() {
        if (callData.callType === 'audio') {
          toast('Video not available in audio-only call', 'warning');
          return;
        }
        
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            isVideoEnabled = videoTrack.enabled;
            
            const videoBtn = document.getElementById('videoBtn');
            const videoIcon = videoBtn.querySelector('.material-symbols-outlined');
            const localVideo = document.getElementById(`video-${currentUser.userId}`);
            const localPfp = document.getElementById(`pfp-${currentUser.userId}`);
            
            if (isVideoEnabled) {
              videoBtn.classList.remove('text-slate-500');
              videoBtn.classList.add('bg-primary', 'text-white');
              videoIcon.textContent = 'videocam';
              if (localVideo) localVideo.classList.remove('hidden');
              if (localPfp) localPfp.classList.add('hidden');
            } else {
              videoBtn.classList.add('text-slate-500');
              videoBtn.classList.remove('bg-primary', 'text-white');
              videoIcon.textContent = 'videocam_off';
              if (localVideo) localVideo.classList.add('hidden');
              if (localPfp) localPfp.classList.remove('hidden');
            }
            
            // Notify other participants
            socketInstance.emit('video_state_changed', {
              callId: callData.callId,
              enabled: isVideoEnabled
            });
          }
        }
      }

      // Update call duration
      function updateCallDuration() {
        if (!callStartTime) return;
        
        const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
        const hours = Math.floor(elapsed / 3600);
        const minutes = Math.floor((elapsed % 3600) / 60);
        const seconds = elapsed % 60;
        
        const durationEl = document.getElementById('callDuration');
        if (durationEl) {
          durationEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
      }

      // Leave call
      function leaveCall() {
        if (isInitializing) {
          console.log('âš ï¸ Still initializing, preventing duplicate leave');
          return;
        }
        
        console.log('ðŸ“µ Leaving call...');
        isInitializing = true;
        
        // Stop local stream
        if (localStream) {
          localStream.getTracks().forEach(track => {
            track.stop();
            console.log('ðŸ›‘ Stopped track:', track.kind);
          });
        }
        
        // Close all peer connections
        peerConnections.forEach((pc, userId) => {
          console.log('ðŸ”Œ Closing connection to:', userId);
          pc.close();
        });
        peerConnections.clear();
        
        // Notify server
        if (socketInstance && socketInstance.connected) {
          socketInstance.emit('leave_call', {
            callId: callData.callId
          });
        }
        
        // Clear duration interval
        if (durationInterval) {
          clearInterval(durationInterval);
        }
        
        // Clear call data
        localStorage.removeItem('activeCall');
        
        // Return to chat
        setTimeout(() => {
          window.location.href = '/chat.html';
        }, 500);
      }

      // Initialize call
      async function initializeCall() {
        if (isInitializing) {
          console.log('âš ï¸ Already initializing call');
          return;
        }
        
        isInitializing = true;
        
        try {
          // Require auth
          await _Auth.requireAuth();
          
          // Get call data
          const callDataStr = localStorage.getItem('activeCall');
          if (!callDataStr) {
            toast('No active call found', 'error');
            setTimeout(() => window.location.href = '/chat.html', 1500);
            return;
          }
          
          callData = JSON.parse(callDataStr);
          console.log('ðŸ“ž Call data:', callData);
          
          // Get current user
          const firebaseUser = firebase.auth().currentUser;
          if (!firebaseUser) {
            window.location.href = '/login.html';
            return;
          }
          
          const userData = await _API.get('/api/users/me');
          currentUser = {
            userId: userData._id,
            username: userData.username,
            pfpUrl: userData.pfpUrl
          };
          
          console.log('âœ… Current user:', currentUser);
          
          // Update UI
          const callTitle = document.getElementById('callTitle');
          const callSubtitle = document.getElementById('callSubtitle');
          if (callTitle) callTitle.textContent = `${callData.callType === 'video' ? 'Video' : 'Audio'} Call`;
          if (callSubtitle) callSubtitle.textContent = 'Initializing...';
          
          // Initialize socket
          const idToken = await firebaseUser.getIdToken();
          const socketUrl = 'https://website-hdem.onrender.com';
          socketInstance = io(socketUrl, {
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            auth: { token: idToken }
          });
          
          // Socket event handlers
          socketInstance.on('connect', () => {
            console.log('ðŸ”Œ Socket connected:', socketInstance.id);
            socketInstance.emit('authenticate', {
              token: idToken,
              userId: currentUser.userId
            });
          });
          
          socketInstance.on('authenticated', async () => {
            console.log('âœ… Socket authenticated');
            
            if (!hasJoinedCall) {
              hasJoinedCall = true;
              // Join call room
              socketInstance.emit('join_call', {
                callId: callData.callId
              });
            }
          });
          
          socketInstance.on('call_joined', async (data) => {
            console.log('âœ… Joined call:', data);
            
            if (callSubtitle) callSubtitle.textContent = `${data.participants.length} participant${data.participants.length > 1 ? 's' : ''}`;
            
            // Initialize local media FIRST
            await initializeLocalMedia();
            
            // Create participant tiles
            const participantGrid = document.getElementById('participantGrid');
            if (participantGrid) {
              participantGrid.innerHTML = '';
              
              data.participants.forEach(participant => {
                const isSelf = participant.userId === currentUser.userId;
                const tile = createParticipantTile(participant, isSelf);
                participantGrid.appendChild(tile);
                
                // Initiate WebRTC connection with other participants (if not self)
                if (!isSelf) {
                  // Small delay to ensure both sides are ready
                  setTimeout(() => createOffer(participant.userId), 500);
                }
              });
            }
            
            // Start call duration timer
            callStartTime = Date.now();
            durationInterval = setInterval(updateCallDuration, 1000);
            
            isInitializing = false;
          });
          
          socketInstance.on('user_joined_call', (data) => {
            console.log('ðŸ‘‹ User joined call:', data.user);
            
            // Add new participant tile
            const participantGrid = document.getElementById('participantGrid');
            if (participantGrid && !document.getElementById(`participant-${data.user.userId}`)) {
              const tile = createParticipantTile(data.user, false);
              participantGrid.appendChild(tile);
              
              // Initiate WebRTC connection
              setTimeout(() => createOffer(data.user.userId), 500);
            }
          });
          
          socketInstance.on('user_left_call', (data) => {
            console.log('ðŸ‘‹ User left call:', data.userId);
            
            // Remove participant tile
            const tile = document.getElementById(`participant-${data.userId}`);
            if (tile) tile.remove();
            
            // Close peer connection
            const pc = peerConnections.get(data.userId);
            if (pc) {
              pc.close();
              peerConnections.delete(data.userId);
            }
          });
          
          socketInstance.on('webrtc_offer', (data) => {
            handleOffer(data.fromUserId, data.offer);
          });
          
          socketInstance.on('webrtc_answer', (data) => {
            handleAnswer(data.fromUserId, data.answer);
          });
          
          socketInstance.on('ice_candidate', (data) => {
            handleIceCandidate(data.fromUserId, data.candidate);
          });
          
          socketInstance.on('audio_state_changed', (data) => {
            const micIndicator = document.getElementById(`mic-${data.userId}`);
            if (micIndicator) {
              if (data.enabled) {
                micIndicator.classList.add('hidden');
              } else {
                micIndicator.classList.remove('hidden');
              }
            }
          });
          
          socketInstance.on('video_state_changed', (data) => {
            const video = document.getElementById(`video-${data.userId}`);
            const pfp = document.getElementById(`pfp-${data.userId}`);
            if (video && pfp) {
              if (data.enabled) {
                video.classList.remove('hidden');
                pfp.classList.add('hidden');
              } else {
                video.classList.add('hidden');
                pfp.classList.remove('hidden');
              }
            }
          });
          
          socketInstance.on('call_ended', () => {
            console.log('ðŸ“µ Call ended by host');
            toast('Call ended', 'warning');
            leaveCall();
          });
          
          // Set up control buttons
          const micBtn = document.getElementById('micBtn');
          const videoBtn = document.getElementById('videoBtn');
          const leaveCallBtn = document.getElementById('leaveCallBtn');
          
          if (micBtn) micBtn.addEventListener('click', toggleMicrophone);
          if (videoBtn) videoBtn.addEventListener('click', toggleVideo);
          if (leaveCallBtn) leaveCallBtn.addEventListener('click', leaveCall);
          
          // Handle page unload
          window.addEventListener('beforeunload', (e) => {
            leaveCall();
          });
          
        } catch (error) {
          console.error('âŒ Call initialization error:', error);
          toast('Failed to initialize call', 'error');
          isInitializing = false;
          setTimeout(() => window.location.href = '/chat.html', 2000);
        }
      }

      // Start initialization
      initializeCall();
      
    })();
    </script>
</body>
</html>
