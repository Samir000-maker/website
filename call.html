<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Active Call - MoodLog</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#33bfcc",
                        "background-light": "#f2f2f3",
                        "background-dark": "#121417",
                        "surface-dark": "#1e2124",
                        "accent-red": "#ef4444",
                    },
                    fontFamily: {
                        "display": ["Manrope", "sans-serif"]
                    }
                },
            },
        }
    </script>
    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }
        
        .active-speaker {
            box-shadow: 0 0 0 3px #33bfcc, 0 0 15px rgba(51, 191, 204, 0.4) !important;
            border-color: #33bfcc !important;
        }
        
        body {
            font-family: 'Manrope', sans-serif;
            overscroll-behavior: none;
        }
        
        .video-tile {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            max-width: 400px;
            background: #000;
            overflow: hidden;
            border-radius: 1rem;
        }
        
        .video-container {
            position: absolute;
            inset: 0;
        }
        
        video {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .pfp-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        
        .participant-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 400px));
            justify-content: center;
            gap: 1rem;
            width: 100%;
            padding: 1rem;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        @media (min-width: 1024px) {
            .participant-grid {
                grid-template-columns: repeat(auto-fit, minmax(300px, 400px));
            }
        }
        
        @media (max-width: 640px) {
            .participant-grid {
                grid-template-columns: 1fr;
                padding: 0.75rem;
            }
            .video-tile {
                max-width: 100%;
            }
        }
        
        
        #chatContainer {
    animation: slideInFromBottom 0.3s ease-out;
}

@keyframes slideInFromBottom {
    from {
        transform: translateY(100%);
    }
    to {
        transform: translateY(0);
    }
}

#miniCallIndicator {
    animation: slideInFromRight 0.3s ease-out;
}

@keyframes slideInFromRight {
    from {
        opacity: 0;
        transform: translateX(100px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes bounce-slow {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

.animate-bounce-slow {
    animation: bounce-slow 2s ease-in-out infinite;
}
        
        
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-900 dark:text-white min-h-screen flex flex-col font-display">
    <header class="w-full border-b border-slate-200 dark:border-slate-800 px-4 sm:px-6 py-3 sm:py-4 flex items-center justify-between bg-background-light dark:bg-background-dark z-10">
        <div class="flex items-center gap-3 sm:gap-4 flex-1 min-w-0">
            <div class="bg-primary/20 p-1.5 sm:p-2 rounded-lg flex-shrink-0">
                <span class="material-symbols-outlined text-primary text-lg sm:text-2xl" id="callIcon">videocam</span>
            </div>
            <div class="min-w-0">
                <h1 class="text-sm sm:text-lg font-bold tracking-tight truncate" id="callTitle">Video Call</h1>
                <p class="text-[10px] sm:text-xs text-slate-500 dark:text-slate-400 truncate" id="callSubtitle">Connecting...</p>
            </div>
        </div>
        <div class="flex items-center gap-2 sm:gap-3 flex-shrink-0">
            <div class="flex items-center gap-1.5 sm:gap-2 bg-slate-200 dark:bg-surface-dark px-2 sm:px-4 py-1.5 sm:py-2 rounded-lg sm:rounded-xl border border-slate-300 dark:border-slate-700">
                <span class="relative flex h-2 w-2">
                    <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-primary opacity-75"></span>
                    <span class="relative inline-flex rounded-full h-2 w-2 bg-primary"></span>
                </span>
                <span class="text-[10px] sm:text-sm font-bold font-mono" id="callDuration">00:00:00</span>
            </div>
        </div>
    </header>

    <main class="flex-1 overflow-y-auto">
        <div id="participantGrid" class="participant-grid"></div>
    </main>

    <footer class="w-full px-3 sm:px-6 py-3 sm:py-4 flex justify-center sticky bottom-0 z-20">
        <div class="bg-white/95 dark:bg-surface-dark/95 backdrop-blur-lg shadow-2xl rounded-xl sm:rounded-2xl border border-slate-200 dark:border-slate-800 p-2 sm:p-2.5 flex items-center gap-1 sm:gap-2">
            <div class="flex items-center gap-1 sm:gap-2 px-1 sm:px-2 border-r border-slate-200 dark:border-slate-800">
                <button id="micBtn" class="w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-primary text-white hover:brightness-110 transition-all active:scale-95">
                    <span class="material-symbols-outlined text-lg sm:text-2xl">mic</span>
                </button>
                <button id="videoBtn" class="w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-slate-200 dark:bg-background-dark text-slate-700 dark:text-white hover:bg-slate-300 dark:hover:bg-slate-800 transition-all">
                    <span class="material-symbols-outlined text-lg sm:text-2xl">videocam_off</span>
                </button>
            </div>
            
            <div class="hidden sm:flex items-center gap-2 px-2">
                <button id="moodBtn" class="flex items-center gap-1.5 sm:gap-2 px-3 sm:px-4 h-10 sm:h-12 rounded-lg sm:rounded-xl bg-slate-100 dark:bg-background-dark text-slate-700 dark:text-white border border-slate-200 dark:border-slate-700 hover:border-primary transition-all text-xs sm:text-sm">
                    <span class="text-base sm:text-xl">üòä</span>
                    <span class="font-bold hidden md:inline">Update Mood</span>
                </button>
            </div>
            
            <div class="pl-1 sm:pl-2 border-l border-slate-200 dark:border-slate-800">
                <button id="leaveCallBtn" class="flex items-center gap-1.5 sm:gap-2 px-4 sm:px-6 h-10 sm:h-12 rounded-lg sm:rounded-xl bg-accent-red text-white hover:brightness-110 transition-all active:scale-95">
                    <span class="material-symbols-outlined font-bold text-lg sm:text-2xl">call_end</span>
                    <span class="font-bold text-xs sm:text-sm">Leave</span>
                </button>
            </div>
        </div>
    </footer>
    
<div id="chatOverlayContainer" class="hidden fixed inset-0 z-[9999] bg-white">
    <iframe id="chatOverlayIframe" class="w-full h-full border-none"></iframe>
</div>

<!-- Mini Call Indicator -->
<!-- <button id="miniCallIndicator" class="hidden fixed bottom-20 right-4 z-[10000] bg-green-600 hover:bg-green-700 active:bg-green-800 text-white rounded-full p-4 shadow-2xl transition-all hover:scale-110 active:scale-95">
    <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-2xl">call</span>
        <span class="text-sm font-bold">Back to Call</span>
    </div>
</button> -->

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };
      if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="app.js"></script>



    <script>
    (async () => {
      const MoodApp = window.MoodApp || {};
      const _Auth = MoodApp.Auth;
      const _API = MoodApp.API;
      const _Toast = MoodApp.Toast;
      const toast = (m, t='success') => { 
        if (_Toast && typeof _Toast[t] === 'function') return _Toast[t](m); 
        console[t==='error'?'error':'log'](m); 
      };



let videoStateChangeTimeout = null;
let isTogglingVideo = false;
let isJoiningCall = false;
let lastVideoToggleTime = 0;
const VIDEO_TOGGLE_DEBOUNCE = 500; // ms
let negotiationMutex = new Map(); // userId -> Promise to prevent duplicate offer handling
let makingOffer = new Map();
        
let ICE_SERVERS = null;
let useTurnFallback = false; // Global flag for TURN fallback

async function fetchIceServers() {
  try {
    // ‚úÖ Request STUN-only by default, TURN only if fallback enabled
    const endpoint = useTurnFallback 
      ? '/api/ice-servers?includeTurn=true' 
      : '/api/ice-servers';
    
    console.log(`üì° Fetching ICE servers: ${useTurnFallback ? 'TURN fallback mode' : 'STUN-only mode'}`);
    
    const response = await _API.get(endpoint);
    
    const stunServers = response.iceServers.filter(server => 
      server.urls.some(url => url.startsWith('stun:'))
    );
    
    const turnServers = response.iceServers.filter(server => 
      server.urls.some(url => url.startsWith('turn:') || url.startsWith('turns:'))
    );
    
    ICE_SERVERS = response.iceServers;
    
    console.log(`‚úÖ ICE servers loaded:`);
    console.log(`   - ${stunServers.length} STUN server group(s)`);
    console.log(`   - ${turnServers.length} TURN server group(s)`);
    
    if (turnServers.length === 0) {
      console.log(`   üí∞ Zero TURN usage - pure peer-to-peer mode`);
      console.log(`   üìä Cloudflare analytics should show 0 KB`);
    } else {
      console.warn(`   ‚ö†Ô∏è TURN enabled (fallback mode after connection failure)`);
    }
    
    return ICE_SERVERS;
  } catch (error) {
    console.error('‚ùå ICE servers failed:', error);
    ICE_SERVERS = [{ urls: ['stun:stun.cloudflare.com:3478', 'stun:stun.l.google.com:19302'] }];
    return ICE_SERVERS;
  }
}


      const PEER_CONNECTION_CONFIG = { 
  iceCandidatePoolSize: 10,
  iceTransportPolicy: 'all', // MUST be 'all' to try STUN first, NOT 'relay'
  bundlePolicy: 'max-bundle', 
  rtcpMuxPolicy: 'require',
  // Enable ICE restart for failed connections
  iceRestart: false
};
      let localStream = null, peerConnections = new Map(), audioContexts = new Map(), socketInstance = null;
      let callData = null, currentUser = null, isAudioEnabled = true, isVideoEnabled = false;
      let durationInterval = null, isInitializing = false, hasJoinedCall = false;
      let pendingIceCandidates = new Map(), connectionStats = new Map();
      let renderedParticipants = new Set(); // CRITICAL FIX: Track rendered participants
      let isNavigatingToChat = false;
      let isInChatView = false;
      
      function setupCallBackButtonHandler() {
  console.log('üîô Setting up call page back button handler');
  
  // Set initial state
  history.pushState({ view: 'call' }, 'Call', window.location.href);
  
  
  // Listen for messages from chat iframe
window.addEventListener('message', (event) => {
  console.log('üì® ========================================');
  console.log('üì® MESSAGE RECEIVED FROM IFRAME');
  console.log('üì® ========================================');
  console.log(`   action: ${event.data?.action}`);
  
  if (event.data && event.data.action === 'hideChat') {
    console.log('üí¨ Hiding chat overlay as requested by iframe');
    hideChat();
    history.pushState({ view: 'call' }, 'Call', window.location.href);
  }
  
  console.log('üì® ========================================\n');
});

console.log('‚úÖ Message listener added for iframe communication');
  
  window.addEventListener('popstate', (event) => {
  console.log('‚¨ÖÔ∏è ========================================');
  console.log('‚¨ÖÔ∏è BACK BUTTON PRESSED');
  console.log('‚¨ÖÔ∏è ========================================');
  
  const chatOverlay = document.getElementById('chatOverlayContainer');
  const isShowingChat = chatOverlay && !chatOverlay.classList.contains('hidden');
  
  console.log(`   Currently showing: ${isShowingChat ? 'chat overlay' : 'call UI'}`);
  
  if (isShowingChat) {
    // Hide chat, show call
    console.log('üìû Hiding chat, showing call');
    hideChat();
    history.pushState({ view: 'call' }, 'Call', window.location.href);
  } else {
    // CRITICAL: Navigate to chat.html as standalone page
    // Call will remain active in background
    console.log('üîÑ Navigating to chat.html (call remains active)');
    console.log(`   Active peer connections: ${peerConnections.size}`);
    console.log(`   Local stream tracks: ${localStream.getTracks().length}`);
    
    // Mark that we're navigating to chat (not closing)
    sessionStorage.setItem('navigatingFromCall', 'true');
    
    // Navigate to chat page
    window.location.href = '/chat.html';
  }
  
  console.log('‚¨ÖÔ∏è ========================================\n');
});
}

function showChat() {
  console.log('üí¨ ========================================');
  console.log('üí¨ SHOWING CHAT OVERLAY');
  console.log('üí¨ ========================================');
  
  // Hide call UI elements
  const header = document.querySelector('header');
  const main = document.querySelector('main');
  const footer = document.querySelector('footer');
  
  if (header) header.style.display = 'none';
  if (main) main.style.display = 'none';
  if (footer) footer.style.display = 'none';
  
  // Show chat overlay
  const chatOverlay = document.getElementById('chatOverlayContainer');
  const chatIframe = document.getElementById('chatOverlayIframe');
  const miniIndicator = document.getElementById('miniCallIndicator');
  
  if (chatOverlay) {
    chatOverlay.classList.remove('hidden');
    
    // Load chat page in iframe
    if (chatIframe) {
      chatIframe.src = '/chat.html';
      console.log('‚úÖ Chat iframe loaded');
    }
  }
  
  // Show mini indicator
  if (miniIndicator) {
    miniIndicator.classList.remove('hidden');
    miniIndicator.onclick = () => {
      console.log('üîô Mini indicator clicked');
      hideChat();
      history.pushState({ view: 'call' }, 'Call', window.location.href);
    };
  }
  
  console.log('‚úÖ Chat overlay shown - call remains active');
  console.log(`   PeerConnections: ${peerConnections.size}`);
  console.log(`   LocalStream: ${localStream?.getTracks().length} tracks`);
  console.log('üí¨ ========================================\n');
}

function hideChat() {
  console.log('üìû ========================================');
  console.log('üìû HIDING CHAT OVERLAY');
  console.log('üìû ========================================');
  
  // Hide chat overlay
  const chatOverlay = document.getElementById('chatOverlayContainer');
  const miniIndicator = document.getElementById('miniCallIndicator');
  
  if (chatOverlay) chatOverlay.classList.add('hidden');
  if (miniIndicator) miniIndicator.classList.add('hidden');
  
  // CRITICAL: Also hide the floating button that might be in the parent window
  try {
    if (window.parent && window.parent !== window) {
      const parentFloatingBtn = window.parent.document.getElementById('floatingReturnToCall');
      if (parentFloatingBtn) {
        parentFloatingBtn.classList.add('hidden');
        console.log('‚úÖ Parent floating button hidden');
      }
    }
  } catch (e) {
    console.warn('‚ö†Ô∏è Could not access parent window:', e);
  }
  
  // Show call UI elements
  const header = document.querySelector('header');
  const main = document.querySelector('main');
  const footer = document.querySelector('footer');
  
  if (header) header.style.display = '';
  if (main) main.style.display = '';
  if (footer) footer.style.display = '';
  
  console.log('‚úÖ Call UI restored - connections still active');
  console.log(`   PeerConnections: ${peerConnections.size}`);
  console.log(`   LocalStream: ${localStream?.getTracks().length} tracks`);
  console.log('üìû ========================================\n');
}

function showChatView() {
  console.log('üí¨ ========================================');
  console.log('üí¨ SHOWING CHAT VIEW');
  console.log('üí¨ ========================================');
  
  isInChatView = true;
  
  // CRITICAL: Navigate to actual chat page while keeping call alive
  // Save that we have background call
  sessionStorage.setItem('hasBackgroundCall', 'true');
  
  console.log('‚úÖ Navigating to chat with background call');
  console.log(`   PeerConnections: ${peerConnections.size} (will remain connected)`);
  console.log(`   LocalStream: ${localStream?.getTracks().length} tracks (will remain active)`);
  
  // Navigate to chat page
  window.location.href = '/chat.html';
  
  console.log('üí¨ ========================================\n');
}


function showCallView() {
  console.log('üìû ========================================');
  console.log('üìû SHOWING CALL VIEW');
  console.log('üìû ========================================');
  
  isInChatView = false;
  
  // Get all main elements
  const header = document.querySelector('header');
  const main = document.querySelector('main');
  const footer = document.querySelector('footer');
  const miniIndicator = document.getElementById('miniCallIndicator');
  
  // Show call UI
  if (header) header.style.display = '';
  if (main) main.style.display = '';
  if (footer) footer.style.display = '';
  
  // Hide mini indicator
  if (miniIndicator) miniIndicator.classList.add('hidden');
  
  // Clear session flags
  sessionStorage.removeItem('hasBackgroundCall');
  
  console.log('‚úÖ Call view restored');
  console.log(`   PeerConnections active: ${peerConnections.size}`);
  console.log(`   LocalStream active: ${localStream?.getTracks().length} tracks`);
  console.log('üìû ========================================\n');
}

function returnToCallView() {
  console.log('üîô ========================================');
  console.log('üîô RETURNING TO CALL VIEW (MAXIMIZING)');
  console.log('üîô ========================================');
  
  // CRITICAL: Mark that we're no longer navigating
  isNavigatingToChat = false;
  
  // Hide chat container
  const chatContainer = document.getElementById('chatContainer');
  const miniIndicator = document.getElementById('miniCallIndicator');
  
  if (chatContainer) chatContainer.classList.add('hidden');
  if (miniIndicator) miniIndicator.classList.add('hidden');
  
  // Show call UI elements
  const header = document.querySelector('header');
  const main = document.querySelector('main');
  const footer = document.querySelector('footer');
  
  if (header) header.style.display = '';
  if (main) main.style.display = '';
  if (footer) footer.style.display = '';
  
  // Clear session flags
  sessionStorage.removeItem('returningFromCall');
  sessionStorage.removeItem('backgroundCallMode');
  
  console.log('‚úÖ Call maximized - UI restored');
  console.log(`   PeerConnections still active: ${peerConnections.size}`);
  console.log(`   LocalStream still active: ${localStream?.getTracks().length || 0} tracks`);
  console.log('üîô ========================================\n');
}

function returnToCallView() {
  console.log('üîô Returning to call view');
  
  const chatContainer = document.getElementById('chatContainer');
  const miniIndicator = document.getElementById('miniCallIndicator');
  
  if (chatContainer) chatContainer.classList.add('hidden');
  if (miniIndicator) miniIndicator.classList.add('hidden');
  
  document.body.style.overflow = '';
  
  // Clear session flags
  sessionStorage.removeItem('returningFromCall');
  sessionStorage.removeItem('backgroundCallMode');
  
  console.log('‚úÖ Returned to call view');
}

function updateMiniCallIndicator() {
  const miniAvatar = document.getElementById('miniCallAvatar');
  
  if (miniAvatar && currentUser) {
    miniAvatar.innerHTML = '';
    const initial = currentUser.username?.charAt(0).toUpperCase() || 'U';
    miniAvatar.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-lg">${initial}</div>`;
  }
  
  // Update duration periodically
  setInterval(() => {
    const miniDuration = document.getElementById('miniCallDuration');
    const mainDuration = document.getElementById('callDuration');
    
    if (miniDuration && mainDuration) {
      miniDuration.textContent = mainDuration.textContent;
    }
  }, 1000);
}

// Fallback: Create iframe overlay for chat
function showChatOverlay() {
  console.log('üé® Creating chat overlay on call page');
  
  // Create overlay container
  const overlay = document.createElement('div');
  overlay.id = 'chatOverlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 9999;
    background: white;
  `;
  
  // Create iframe
  const iframe = document.createElement('iframe');
  iframe.src = '/chat.html';
  iframe.style.cssText = `
    width: 100%;
    height: 100%;
    border: none;
  `;
  
  // Create close button
  const closeBtn = document.createElement('button');
  closeBtn.innerHTML = '‚Üê Back to Call';
  closeBtn.style.cssText = `
    position: absolute;
    top: 1rem;
    left: 1rem;
    z-index: 10000;
    background: #367d7d;
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    border: none;
    font-weight: 600;
    cursor: pointer;
  `;
  
  closeBtn.onclick = () => {
    console.log('üîô Returning to call from overlay');
    document.body.removeChild(overlay);
    isNavigatingToChat = false;
  };
  
  overlay.appendChild(closeBtn);
  overlay.appendChild(iframe);
  document.body.appendChild(overlay);
  
  isNavigatingToChat = true;
  
  console.log('‚úÖ Chat overlay created');
}

function setupCallCleanup() {
}

      function createProfilePicture(pfpUrl, username) {
        const initial = username ? username.charAt(0).toUpperCase() : 'U';
        const div = document.createElement('div');
        div.className = 'w-16 h-16 sm:w-20 sm:h-20 rounded-full overflow-hidden bg-slate-100 dark:bg-slate-800 border-2 border-primary/30';
        if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
          const img = document.createElement('img');
          img.src = pfpUrl;
          img.alt = username;
          img.className = 'w-full h-full object-cover';
          img.onerror = () => { div.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-xl sm:text-2xl">${initial}</div>`; };
          div.appendChild(img);
        } else {
          div.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-xl sm:text-2xl">${initial}</div>`;
        }
        return div;
      }
      
      
function updateVideoVisibility(userId, enabled, trackReady) {
  console.log(`üìπ ========================================`);
  console.log(`üìπ updateVideoVisibility(${userId})`);
  console.log(`üìπ ========================================`);
  console.log(`   enabled: ${enabled}`);
  console.log(`   trackReady: ${trackReady}`);
  
  const videoEl = document.getElementById(`video-${userId}`);
  const pfpContainer = document.getElementById(`pfp-${userId}`);
  
  if (!videoEl || !pfpContainer) {
    console.warn(`‚ö†Ô∏è Video elements not found for ${userId}`);
    console.log(`   videoEl: ${!!videoEl}, pfpContainer: ${!!pfpContainer}`);
    console.log(`üìπ ========================================\n`);
    return;
  }
  
  const hasVideoTrack = videoEl.srcObject?.getVideoTracks().length > 0;
  const videoTrackEnabled = videoEl.srcObject?.getVideoTracks()[0]?.enabled || false;
  
  console.log(`   hasVideoTrack: ${hasVideoTrack}`);
  console.log(`   videoTrackEnabled: ${videoTrackEnabled}`);
  
  const shouldShowVideo = enabled && (trackReady || hasVideoTrack) && videoTrackEnabled;
  
  console.log(`   shouldShowVideo: ${shouldShowVideo}`);
  
  if (videoEl.srcObject) {
    console.log(`   srcObject video tracks: ${videoEl.srcObject.getVideoTracks().length}`);
  } else {
    console.log(`   srcObject: null`);
  }
  
  if (shouldShowVideo) {
    videoEl.classList.remove('hidden');
    pfpContainer.classList.add('hidden');
    console.log(`   ‚úÖ Video VISIBLE, profile picture HIDDEN`);
  } else {
    videoEl.classList.add('hidden');
    pfpContainer.classList.remove('hidden');
    console.log(`   ‚úÖ Video HIDDEN, profile picture SHOWN`);
  }
  
  console.log(`üìπ ========================================\n`);
}
      

function createParticipantTile(user, isSelf = false) {
  console.log(`üé® Creating tile for ${user.username} (userId: ${user.userId}, isSelf: ${isSelf})`);
  
  // CRITICAL: Check if tile already exists in DOM
  const existingTile = document.getElementById(`participant-${user.userId}`);
  if (existingTile) {
    console.warn(`‚ö†Ô∏è Tile for ${user.userId} already exists in DOM! Removing old tile.`);
    existingTile.remove();
    renderedParticipants.delete(user.userId);
  }
  
  // Double-check tracking set
  if (renderedParticipants.has(user.userId)) {
    console.warn(`‚ö†Ô∏è Tile for ${user.userId} in tracking set but not in DOM! Clearing.`);
    renderedParticipants.delete(user.userId);
  }
  
  const tile = document.createElement('div');
  tile.id = `participant-${user.userId}`;
  tile.className = `video-tile ${isSelf ? 'border-2 border-dashed border-primary/30' : 'border border-white/5'}`;
  
  const videoContainer = document.createElement('div');
  videoContainer.className = 'video-container';
  
  const video = document.createElement('video');
  video.id = `video-${user.userId}`;
  video.className = 'hidden';
  video.autoplay = true;
  video.playsInline = true;
  video.setAttribute('playsinline', '');
  video.setAttribute('webkit-playsinline', '');
  
video.style.transform = 'scaleX(1)';  // Normal orientation for everyone

if (isSelf) {
  video.muted = true;
  video.volume = 0;
  console.log(`üìπ Self video: NO MIRROR (true orientation) (userId: ${user.userId})`);
  console.log(`üîá Self video muted to prevent echo (userId: ${user.userId})`);
} else {
  video.muted = false;
  video.volume = 1.0;
  console.log(`üìπ Remote video: NO MIRROR (true orientation) (userId: ${user.userId})`);
  console.log(`üîä Remote video audio enabled (userId: ${user.userId})`);
}
  
  videoContainer.appendChild(video);
  
  const pfpOverlay = document.createElement('div');
  pfpOverlay.id = `pfp-${user.userId}`;
  pfpOverlay.className = 'pfp-overlay';
  pfpOverlay.appendChild(createProfilePicture(user.pfpUrl, user.username));
  videoContainer.appendChild(pfpOverlay);
  
  tile.appendChild(videoContainer);
  
  const label = document.createElement('div');
  label.className = 'absolute bottom-3 sm:bottom-4 left-3 sm:left-4 z-10';
  label.innerHTML = `<div class="${isSelf ? 'bg-primary/80' : 'bg-black/60'} backdrop-blur-md px-2 sm:px-3 py-1 sm:py-1.5 rounded-full border ${isSelf ? 'border-primary/20' : 'border-white/10'} flex items-center gap-1.5 sm:gap-2">
    <span class="text-white text-xs sm:text-sm font-semibold">${isSelf ? 'You' : user.username}</span>
    <span class="text-base sm:text-lg">üòä</span>
  </div>`;
  tile.appendChild(label);
  
  const speaking = document.createElement('div');
  speaking.id = `speaking-${user.userId}`;
  speaking.className = 'absolute top-3 sm:top-4 right-3 sm:right-4 bg-primary px-1.5 sm:px-2 py-0.5 rounded text-[9px] sm:text-[10px] font-bold text-white uppercase hidden z-10';
  speaking.textContent = 'SPEAKING';
  tile.appendChild(speaking);
  
  const micOff = document.createElement('div');
  micOff.id = `mic-${user.userId}`;
  micOff.className = 'absolute top-3 sm:top-4 right-3 sm:right-4 bg-accent-red p-1 sm:p-1.5 rounded-full text-white shadow-lg hidden z-10';
  micOff.innerHTML = '<span class="material-symbols-outlined text-[14px] sm:text-[16px]">mic_off</span>';
  tile.appendChild(micOff);
  
  if (isSelf) {
    const overlay = document.createElement('div');
    overlay.className = 'absolute inset-0 bg-primary/5 pointer-events-none';
    tile.appendChild(overlay);
  }
  
  renderedParticipants.add(user.userId);
  console.log(`‚úÖ Tile created for ${user.username} (${user.userId})`);
  console.log(`   Mirror effect: ${isSelf ? 'YES (self view)' : 'NO (remote view)'}`);
  console.log(`üìä Rendered participants now:`, Array.from(renderedParticipants));
  return tile;
}


// Add after createPC function to monitor connection quality
function monitorConnectionQuality(userId, pc) {
  const monitorInterval = setInterval(async () => {
    if (!pc || pc.connectionState === 'closed') {
      clearInterval(monitorInterval);
      return;
    }
    
    try {
      const stats = await pc.getStats();
      let connectionInfo = {
        candidateType: 'unknown',
        bytesReceived: 0,
        bytesSent: 0,
        packetsLost: 0
      };
      
      stats.forEach(report => {
        if (report.type === 'candidate-pair' && report.state === 'succeeded') {
          const localCandidate = stats.get(report.localCandidateId);
          if (localCandidate) {
            connectionInfo.candidateType = localCandidate.candidateType;
          }
        }
        
        if (report.type === 'inbound-rtp' && report.kind === 'audio') {
          connectionInfo.bytesReceived = report.bytesReceived || 0;
          connectionInfo.packetsLost = report.packetsLost || 0;
        }
        
        if (report.type === 'outbound-rtp' && report.kind === 'audio') {
          connectionInfo.bytesSent = report.bytesSent || 0;
        }
      });
      
      // Only log significant changes or issues
      if (connectionInfo.packetsLost > 10) {
        console.warn(`‚ö†Ô∏è [Quality] Packet loss detected for ${userId}: ${connectionInfo.packetsLost} packets`);
      }
      
      // Update connection stats
      const connStats = connectionStats.get(userId);
      if (connStats) {
        connStats.lastQualityCheck = Date.now();
        connStats.connectionType = connectionInfo.candidateType;
      }
      
    } catch (e) {
      console.warn(`‚ö†Ô∏è Failed to get stats for ${userId}:`, e.message);
    }
  }, 5000); // Check every 5 seconds
  
  // Store interval for cleanup
  if (!connectionStats.has(userId)) {
    connectionStats.set(userId, {});
  }
  connectionStats.get(userId).monitorInterval = monitorInterval;
}

      function setupAudioDetection(userId, stream) {
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioContext.createMediaStreamSource(stream);
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 256;
    source.connect(analyser);
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    let isSpeaking = false, lastSpeakTime = 0;
    let stopped = false;
    
    function detect() {
      if (stopped || audioContext.state === 'closed') {
        console.log(`üîá Audio detection stopped for ${userId}`);
        return;
      }
      
      const speaking = document.getElementById(`speaking-${userId}`);
      const tile = document.getElementById(`participant-${userId}`);
      
      if (!speaking || !tile) { 
        stopped = true;
        if (audioContext.state !== 'closed') {
          audioContext.close().catch(e => console.warn('Failed to close audio context:', e));
        }
        return; 
      }
      
      analyser.getByteFrequencyData(dataArray);
      const avg = dataArray.reduce((a,b)=>a+b) / dataArray.length;
      const now = Date.now();
      
      if (avg > 30) {
        if (!isSpeaking) {
          isSpeaking = true;
          speaking.classList.remove('hidden');
          tile.classList.add('active-speaker');
          if (socketInstance && userId === currentUser.userId) {
            socketInstance.emit('speaking_state', { callId: callData.callId, speaking: true });
          }
        }
        lastSpeakTime = now;
      } else if (isSpeaking && now - lastSpeakTime > 300) {
        isSpeaking = false;
        speaking.classList.add('hidden');
        tile.classList.remove('active-speaker');
        if (socketInstance && userId === currentUser.userId) {
          socketInstance.emit('speaking_state', { callId: callData.callId, speaking: false });
        }
      }
      requestAnimationFrame(detect);
    }
    detect();
    
    // CRITICAL FIX: Store object with context and stop function
    audioContexts.set(userId, { 
      context: audioContext, 
      stop: () => { stopped = true; } 
    });
  } catch (e) { 
    console.error('Audio detection error:', e); 
  }
}

async function initLocalMedia() {
  const MAX_RETRIES = 3;
  let attempt = 0;
  
  while (attempt < MAX_RETRIES) {
    try {
      attempt++;
      console.log(`üé• [Attempt ${attempt}/${MAX_RETRIES}] Requesting media (${callData.callType})...`);
      
      const constraints = {
        audio: { 
          echoCancellation: true, 
          noiseSuppression: true, 
          autoGainControl: true 
        },
        video: callData.callType === 'video' ? { 
          width: {ideal:640}, 
          height: {ideal:480},
          facingMode: 'user'
        } : false
      };
      
      let hasVideo = false;
      let hasAudio = false;
      
      try {
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        hasVideo = localStream.getVideoTracks().length > 0;
        hasAudio = localStream.getAudioTracks().length > 0;
        console.log(`‚úÖ [Attempt ${attempt}] SUCCESS: video=${hasVideo}, audio=${hasAudio}`);
        break;
      } catch (videoError) {
        console.warn(`‚ö†Ô∏è [Attempt ${attempt}] Video failed: ${videoError.name}`);
        
        try {
          const audioOnlyConstraints = {
            audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
            video: false
          };
          localStream = await navigator.mediaDevices.getUserMedia(audioOnlyConstraints);
          hasAudio = localStream.getAudioTracks().length > 0;
          console.log(`‚úÖ [Attempt ${attempt}] Audio-only SUCCESS: audio=${hasAudio}`);
          
          if (attempt === 1) {
            toast('Camera not available, using audio only', 'warning');
          }
          break;
        } catch (audioError) {
          console.error(`‚ùå [Attempt ${attempt}] Both failed: ${audioError.name}`);
          
          if (attempt === MAX_RETRIES) {
            localStream = new MediaStream();
            toast('No media devices available. You can still join the call.', 'error');
          } else {
            await new Promise(resolve => setTimeout(resolve, 500));
            continue;
          }
        }
      }
      
      // ‚úÖ FIX: Set states AFTER actual media acquisition
      isVideoEnabled = hasVideo;
      isAudioEnabled = hasAudio;
      
      console.log(`üìä ========================================`);
      console.log(`üìä MEDIA STATE SYNCHRONIZED`);
      console.log(`üìä ========================================`);
      console.log(`   Expected video: ${callData.callType === 'video'}`);
      console.log(`   Actual video tracks: ${localStream.getVideoTracks().length}`);
      console.log(`   isVideoEnabled: ${isVideoEnabled}`);
      console.log(`   Expected audio: true`);
      console.log(`   Actual audio tracks: ${localStream.getAudioTracks().length}`);
      console.log(`   isAudioEnabled: ${isAudioEnabled}`);
      console.log(`üìä ========================================\n`);
      
      if (hasAudio) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          setupAudioDetection(currentUser.userId, localStream);
          console.log(`üé§ Audio detection setup for ${currentUser.username}`);
        }
      }
      
      const callIcon = document.getElementById('callIcon');
      if (callIcon) callIcon.textContent = isVideoEnabled ? 'videocam' : 'graphic_eq';
      
      console.log(`‚úÖ initLocalMedia() complete - stream ready`);
      return localStream;
      
    } catch (e) {
      console.error(`‚ùå [Attempt ${attempt}] Critical error:`, e);
      if (attempt === MAX_RETRIES) {
        localStream = new MediaStream();
        isVideoEnabled = false;
        isAudioEnabled = false;
        toast('Unable to access media devices.', 'error');
        return localStream;
      }
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  return localStream;
}


async function setupLocalVideo() {
  const waitForElement = (id, maxWait = 5000) => {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      const checkElement = () => {
        const element = document.getElementById(id);
        if (element) {
          resolve(element);
        } else if (Date.now() - startTime > maxWait) {
          reject(new Error(`Element ${id} not found after ${maxWait}ms`));
        } else {
          requestAnimationFrame(checkElement);
        }
      };
      checkElement();
    });
  };

  try {
    console.log(`üîß ========================================`);
    console.log(`üîß SETUP LOCAL VIDEO`);
    console.log(`üîß ========================================`);
    console.log(`   User: ${currentUser.username}`);
    console.log(`   isVideoEnabled: ${isVideoEnabled}`);
    console.log(`   Video tracks: ${localStream.getVideoTracks().length}`);
    
    const localTile = document.getElementById(`participant-${currentUser.userId}`);
    if (!localTile) {
      console.warn(`‚ö†Ô∏è No tile for ${currentUser.username} yet - will be created when user_joined_call fires`);
      return;
    }
    
    const localVid = await waitForElement(`video-${currentUser.userId}`);
    const localPfp = await waitForElement(`pfp-${currentUser.userId}`);
    
    console.log(`‚úÖ Found video elements for ${currentUser.username}`);
    
    if (!localStream) {
      console.error(`‚ùå No localStream available`);
      return;
    }
    
    localVid.srcObject = localStream;
    localVid.muted = true;
    localVid.volume = 0;
    console.log(`‚ÑπÔ∏è Video transform already set: ${localVid.style.transform}`);
    console.log(`‚úÖ Local stream attached to video element`);
    
    // ‚úÖ FIX: Gate UI updates on actual media readiness
    if (isVideoEnabled && localStream.getVideoTracks().length > 0) {
      console.log(`üìπ Waiting for local video to be ready...`);
      
      await new Promise((resolve) => {
        const checkReady = () => {
          if (localVid.readyState >= 2) {
            console.log(`üìπ Local video ready: ${localVid.videoWidth}x${localVid.videoHeight}`);
            resolve();
          } else {
            localVid.addEventListener('loadedmetadata', () => {
              console.log(`üìπ Metadata loaded: ${localVid.videoWidth}x${localVid.videoHeight}`);
              resolve();
            }, { once: true });
          }
        };
        checkReady();
      });
      
      try {
        await localVid.play();
        console.log(`‚ñ∂Ô∏è Local video playback started`);
        updateVideoVisibility(currentUser.userId, true, true);
        updateVideoButton(); // ‚úÖ FIX: Update icon AFTER video confirmed playing
        console.log(`‚úÖ Video icon synchronized: ON`);
      } catch (e) {
        console.error('‚ùå Local video play failed:', e);
        isVideoEnabled = false; // ‚úÖ FIX: Rollback state on failure
        updateVideoVisibility(currentUser.userId, false, false);
        updateVideoButton();
        console.log(`‚úÖ Video icon synchronized: OFF (playback failed)`);
      }
    } else {
      console.log(`üìπ Video disabled or no video track for ${currentUser.username}`);
      updateVideoVisibility(currentUser.userId, false, false);
      updateVideoButton(); // ‚úÖ FIX: Update icon AFTER visibility set
      console.log(`‚úÖ Video icon synchronized: OFF`);
    }
    
    updateMicButton();
    
    console.log(`üîß ========================================`);
    console.log(`üîß SETUP COMPLETE`);
    console.log(`üîß ========================================`);
    console.log(`   Video element ready: ${localVid.readyState >= 2}`);
    console.log(`   Video playing: ${!localVid.paused}`);
    console.log(`   isVideoEnabled: ${isVideoEnabled}`);
    console.log(`   Icon state: ${document.getElementById('videoBtn')?.querySelector('.material-symbols-outlined')?.textContent}`);
    console.log(`üîß ========================================\n`);
    
  } catch (error) {
    console.error(`‚ùå setupLocalVideo() failed:`, error);
    console.log(`‚ö†Ô∏è Will retry when tile becomes available`);
  }
}



function updateVideoButton() {
  const btn = document.getElementById('videoBtn');
  const icon = btn?.querySelector('.material-symbols-outlined');
  
  if (!btn || !icon) return;
  
  if (isVideoEnabled) {
    btn.classList.add('bg-primary', 'text-white');
    btn.classList.remove('bg-slate-200', 'dark:bg-background-dark');
    icon.textContent = 'videocam';
  } else {
    btn.classList.remove('bg-primary', 'text-white');
    btn.classList.add('bg-slate-200', 'dark:bg-background-dark');
    icon.textContent = 'videocam_off';
  }
  console.log(`‚úÖ Video button updated: ${isVideoEnabled ? 'ON' : 'OFF'}`);
}




function updateMicButton() {
  const micBtn = document.getElementById('micBtn');
  const micIcon = micBtn?.querySelector('.material-symbols-outlined');
  
  if (!micBtn || !micIcon) return;
  
  if (isAudioEnabled) {
    micBtn.classList.add('bg-primary', 'text-white');
    micBtn.classList.remove('bg-accent-red');
    micIcon.textContent = 'mic';
  } else {
    micBtn.classList.remove('bg-primary');
    micBtn.classList.add('bg-accent-red', 'text-white');
    micIcon.textContent = 'mic_off';
  }
  console.log(`‚úÖ Mic button updated: ${isAudioEnabled ? 'ON' : 'OFF'}`);
}



function createPC(userId) {
  console.log(`üîó Creating PC for ${userId}`);
  
  // CRITICAL FIX: Check for existing PC and close it
  const existingPC = peerConnections.get(userId);
  if (existingPC) {
    console.warn(`‚ö†Ô∏è PC already exists for ${userId}, closing old one`);
    existingPC.close();
    peerConnections.delete(userId);
  }
  
  if (!localStream) {
    console.error(`‚ùå CRITICAL: localStream is null when creating PC for ${userId}!`);
    throw new Error('Cannot create PeerConnection without localStream');
  }
  
  console.log(`‚úÖ localStream validated: ${localStream.getTracks().length} tracks`);
  
  const pc = new RTCPeerConnection({ 
    ...PEER_CONNECTION_CONFIG, 
    iceServers: ICE_SERVERS 
  });
  
  connectionStats.set(userId, { 
    startTime: Date.now(), 
    iceState: 'new', 
    connectionState: 'new', 
    candidatesReceived: 0, 
    candidatesSent: 0,
    iceRestartCount: 0,
    lastIceCandidateTime: 0
  });
  
const tracks = localStream.getTracks();
console.log(`üìä Adding ${tracks.length} tracks to PC for ${userId}:`);

tracks.forEach(track => {
  const sender = pc.addTrack(track, localStream);
  console.log(`   ‚ûï ${track.kind} track (id=${track.id.substring(0, 8)}..., enabled=${track.enabled})`);
  
  // CRITICAL: Store sender for future track replacement
  if (!window.trackSenders) window.trackSenders = new Map();
  if (!window.trackSenders.has(userId)) window.trackSenders.set(userId, new Map());
  window.trackSenders.get(userId).set(track.kind, sender);
});
  
pc.ontrack = (event) => {
  console.log(`üéµ ========================================`);
  console.log(`üéµ [TRACK] Received ${event.track.kind} track`);
  console.log(`üéµ ========================================`);
  console.log(`   From: ${userId}`);
  console.log(`   Track ID: ${event.track.id.substring(0, 8)}...`);
  console.log(`   Track state: enabled=${event.track.enabled}, readyState=${event.track.readyState}, muted=${event.track.muted}`);
  console.log(`   Streams: ${event.streams.length}`);
  
  if (event.streams && event.streams.length > 0) {
    const remoteStream = event.streams[0];
    console.log(`   Remote stream: ${remoteStream.id.substring(0, 8)}... with ${remoteStream.getTracks().length} tracks`);
    
    const remoteVideo = document.getElementById(`video-${userId}`);
    
    if (remoteVideo) {
      const existingStream = remoteVideo.srcObject;
      const needsUpdate = !existingStream || 
                         existingStream.id !== remoteStream.id ||
                         existingStream.getTracks().length !== remoteStream.getTracks().length;
      
      if (needsUpdate) {
        console.log(`üì∫ Setting/updating srcObject for ${userId}`);
        console.log(`   Old stream: ${existingStream?.id || 'none'} with ${existingStream?.getTracks().length || 0} tracks`);
        console.log(`   New stream: ${remoteStream.id} with ${remoteStream.getTracks().length} tracks`);
        
        remoteVideo.srcObject = remoteStream;
        
        remoteVideo.muted = false;
        remoteVideo.volume = 1.0;
        
        if (event.track.kind === 'audio') {
          if (!audioContexts.has(userId)) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioContexts.set(userId, audioCtx);
          }
          
          const audioCtx = audioContexts.get(userId);
          
          if (audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => {
              console.log(`üîä AudioContext resumed for ${userId}`);
            }).catch(err => {
              console.error(`‚ùå Failed to resume AudioContext for ${userId}:`, err);
            });
          }
        }
        
        const attemptPlayback = async (retryCount = 0) => {
          try {
            remoteVideo.muted = false;
            remoteVideo.volume = 1.0;
            
            await remoteVideo.play();
            console.log(`‚ñ∂Ô∏è Remote video playing for ${userId} (attempt ${retryCount + 1})`);
            
            const hasVideoTrack = remoteStream.getVideoTracks().length > 0;
            const videoTrackEnabled = hasVideoTrack && remoteStream.getVideoTracks()[0].enabled;
            
            console.log(`üìä Stream analysis for ${userId}:`);
            console.log(`   Video tracks: ${remoteStream.getVideoTracks().length}`);
            console.log(`   Audio tracks: ${remoteStream.getAudioTracks().length}`);
            console.log(`   Video enabled: ${videoTrackEnabled}`);
            
            if (hasVideoTrack && videoTrackEnabled) {
              console.log(`üìπ Video track present and enabled for ${userId}, showing video`);
              updateVideoVisibility(userId, true, true);
            } else {
              console.log(`üìπ No video or disabled for ${userId}, showing profile picture`);
              updateVideoVisibility(userId, false, false);
            }
            
            const unmuteInterval = setInterval(() => {
              if (remoteVideo.muted) {
                console.log(`üîä Re-unmuting remote video for ${userId}`);
                remoteVideo.muted = false;
                remoteVideo.volume = 1.0;
              }
            }, 1000);
            
            if (!window.unmuteIntervals) window.unmuteIntervals = new Map();
            window.unmuteIntervals.set(userId, unmuteInterval);
            
          } catch (playError) {
            console.error(`‚ùå Play attempt ${retryCount + 1} failed for ${userId}:`, playError);
            
            if (playError.name === 'NotAllowedError' && retryCount < 2) {
              console.log(`‚ö†Ô∏è Autoplay blocked, waiting for user interaction...`);
              
              const overlay = document.createElement('div');
              overlay.id = `unmute-overlay-${userId}`;
              overlay.className = 'absolute inset-0 flex items-center justify-center bg-black/80 z-50 cursor-pointer';
              overlay.innerHTML = `
                <div class="text-center text-white p-4">
                  <span class="material-symbols-outlined text-6xl mb-2">volume_up</span>
                  <p class="font-bold">Tap to enable audio</p>
                </div>
              `;
              
              overlay.onclick = async () => {
                console.log(`üñ±Ô∏è User interaction for ${userId} audio`);
                overlay.remove();
                await attemptPlayback(retryCount + 1);
              };
              
              const tile = document.getElementById(`participant-${userId}`);
              if (tile) {
                tile.appendChild(overlay);
                console.log(`‚úÖ Click-to-unmute overlay added for ${userId}`);
              }
              
            } else if (retryCount < 2) {
              setTimeout(() => attemptPlayback(retryCount + 1), 500);
            }
          }
        };
        
        remoteVideo.onloadedmetadata = () => {
          console.log(`üì∫ Metadata loaded for ${userId}: ${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`);
          attemptPlayback(0);
        };
        
        if (remoteVideo.readyState >= 2) {
          console.log(`üì∫ Metadata already loaded for ${userId}, playing now`);
          attemptPlayback(0);
        }
        
      } else {
        console.log(`‚ÑπÔ∏è Remote video for ${userId} already has correct srcObject`);
        
        const hasVideoTrack = remoteStream.getVideoTracks().length > 0;
        const videoTrackEnabled = hasVideoTrack && remoteStream.getVideoTracks()[0].enabled;
        
        if (event.track.kind === 'video' && videoTrackEnabled) {
          console.log(`üìπ New video track added to existing stream, updating visibility`);
          updateVideoVisibility(userId, true, true);
        } else if (event.track.kind === 'video' && !videoTrackEnabled) {
          console.log(`üìπ Video track added but disabled, hiding video`);
          updateVideoVisibility(userId, false, false);
        }
      }
      
      if (event.track.kind === 'audio') {
        console.log(`üé§ Setting up audio detection for remote user ${userId}`);
        setupAudioDetection(userId, remoteStream);
      }
      
    } else {
      console.error(`‚ùå Video element not found for ${userId}`);
    }
  } else {
    console.warn(`‚ö†Ô∏è No streams in track event for ${userId}`);
  }
  
  event.track.onended = () => {
    console.log(`üîá Track ended for ${userId}: ${event.track.kind}`);
    
    if (window.unmuteIntervals && window.unmuteIntervals.has(userId)) {
      clearInterval(window.unmuteIntervals.get(userId));
      window.unmuteIntervals.delete(userId);
    }
  };
  
  event.track.onmute = () => {
    console.log(`üîá Track muted for ${userId}: ${event.track.kind}`);
  };
  
  event.track.onunmute = () => {
    console.log(`üîä Track unmuted for ${userId}: ${event.track.kind}`);
    
    if (event.track.kind === 'video') {
      console.log(`üìπ Video track unmuted for ${userId}, updating visibility`);
      const remoteVideo = document.getElementById(`video-${userId}`);
      if (remoteVideo && remoteVideo.srcObject) {
        const hasVideoTrack = remoteVideo.srcObject.getVideoTracks().length > 0;
        const videoTrackEnabled = hasVideoTrack && remoteVideo.srcObject.getVideoTracks()[0].enabled;
        if (videoTrackEnabled) {
          updateVideoVisibility(userId, true, true);
        }
      }
    }
  };
  
  console.log(`üéµ ========================================\n`);
};


pc.onremovetrack = (event) => {
    console.log(`üîá ========================================`);
    console.log(`üîá [TRACK REMOVED] from ${userId}`);
    console.log(`üîá ========================================`);
    console.log(`   Track kind: ${event.track.kind}`);
    console.log(`   Track ID: ${event.track.id.substring(0, 8)}...`);
    
    const remoteVideo = document.getElementById(`video-${userId}`);
    if (remoteVideo && remoteVideo.srcObject) {
      const remainingVideoTracks = remoteVideo.srcObject.getVideoTracks().length;
      const remainingAudioTracks = remoteVideo.srcObject.getAudioTracks().length;
      
      console.log(`   Remaining tracks: ${remainingVideoTracks} video, ${remainingAudioTracks} audio`);
      
      if (event.track.kind === 'video' && remainingVideoTracks === 0) {
        console.log(`üìπ No video tracks remaining for ${userId}, hiding video`);
        updateVideoVisibility(userId, false, false);
      }
    }
    
    console.log(`üîá ========================================\n`);
  };
  
  // CRITICAL: ICE candidate handler with rate limiting
  let lastCandidateEmit = 0;
  const CANDIDATE_EMIT_THROTTLE = 50; // 50ms between emits
  
  let hostCandidatesSent = 0;
let srflxCandidatesSent = 0;
const relayCandidateQueue = [];

pc.onicecandidate = (e) => {
  if (e.candidate) {
    const stats = connectionStats.get(userId);
    if (stats) {
      stats.candidatesSent++;
      stats.lastIceCandidateTime = Date.now();
    }
    
    const candidateType = e.candidate.type || 'unknown';
    const candidateProtocol = e.candidate.protocol || 'unknown';
    
    console.log(`üßä [ICE] Generated ${candidateType} candidate for ${userId} (protocol: ${candidateProtocol})`);
    
    // ‚úÖ VERIFICATION: Should NEVER see relay in STUN-only mode
    if (candidateType === 'relay' && !useTurnFallback) {
      console.error(`‚ùå UNEXPECTED: Relay candidate generated in STUN-only mode!`);
      console.error(`   This should not happen - check ICE server config`);
      return; // Don't send relay candidates in STUN-only mode
    }
    
    // Send all candidates immediately (no delay needed - no relay to worry about)
    socketInstance.emit('ice_candidate', { 
      callId: callData.callId, 
      targetUserId: userId, 
      candidate: e.candidate 
    });
    
    console.log(`üì§ [ICE] Sent ${candidateType} candidate to ${userId}`);
    
  } else {
    console.log(`üßä [ICE] End of candidates for ${userId}`);
    console.log(`üìä [ICE] Total candidates sent: ${connectionStats.get(userId)?.candidatesSent || 0}`);
    
    socketInstance.emit('ice_candidate', { 
      callId: callData.callId, 
      targetUserId: userId, 
      candidate: null 
    });
  }
};
  
pc.oniceconnectionstatechange = () => {
  const state = pc.iceConnectionState;
  const stats = connectionStats.get(userId);
  if (stats) stats.iceState = state;
  
  console.log(`üßä [ICE] Connection state for ${userId}: ${state}`);
  
  if (state === 'connected' || state === 'completed') {
    console.log(`‚úÖ [ICE] Connected to ${userId}`);
    
    // Reset failure counter on success
    if (stats) stats.iceRestartCount = 0;
    
    pc.getStats().then(statsReport => {
      let selectedPairType = 'unknown';
      let selectedLocal = null;
      let selectedRemote = null;
      
      statsReport.forEach(report => {
        if (report.type === 'candidate-pair' && report.state === 'succeeded') {
          const localCandidate = statsReport.get(report.localCandidateId);
          const remoteCandidate = statsReport.get(report.remoteCandidateId);
          
          if (localCandidate && remoteCandidate) {
            selectedLocal = localCandidate;
            selectedRemote = remoteCandidate;
            
            if (localCandidate.candidateType === 'relay' || remoteCandidate.candidateType === 'relay') {
              selectedPairType = 'TURN_RELAY';
              console.warn(`‚ö†Ô∏è [ICE] Connection using TURN RELAY (bandwidth cost incurred)`);
            } else if (localCandidate.candidateType === 'srflx' || remoteCandidate.candidateType === 'srflx') {
              selectedPairType = 'STUN_REFLEXIVE';
              console.log(`‚úÖ [ICE] Connection using STUN (server-reflexive) - optimal`);
            } else if (localCandidate.candidateType === 'host') {
              selectedPairType = 'DIRECT_HOST';
              console.log(`‚úÖ [ICE] Connection using direct HOST (LAN/same network)`);
            }
            
            console.log(`üìä [ICE] Selected pair details:`);
            console.log(`   Local:  ${localCandidate.candidateType} ${localCandidate.protocol} ${localCandidate.address}:${localCandidate.port}`);
            console.log(`   Remote: ${remoteCandidate.candidateType} ${remoteCandidate.protocol} ${remoteCandidate.address}:${remoteCandidate.port}`);
            
            // ‚úÖ Confirm zero TURN usage
            if (selectedPairType !== 'TURN_RELAY') {
              console.log(`üí∞ [COST] Zero TURN bandwidth used - pure peer-to-peer`);
              console.log(`   Cloudflare analytics should show 0 KB for this call`);
            }
            
            if (stats) {
              stats.connectionType = selectedPairType;
              stats.localCandidateType = localCandidate.candidateType;
              stats.remoteCandidateType = remoteCandidate.candidateType;
            }
            
            socketInstance.emit('connection_established', {
              callId: callData.callId,
              connectionType: selectedPairType,
              localType: localCandidate.candidateType,
              remoteType: remoteCandidate.candidateType,
              protocol: localCandidate.protocol
            });
          }
        }
      });
      
    });
    
  } else if (state === 'failed') {
    console.error(`‚ùå [ICE] Connection failed for ${userId}`);
    
    // ‚úÖ TURN FALLBACK LOGIC
    if (stats && stats.iceRestartCount < 1 && !useTurnFallback) {
      stats.iceRestartCount++;
      
      console.warn(`üîÑ [FALLBACK] Connection failed with STUN-only mode`);
      console.warn(`   Attempt ${stats.iceRestartCount}: Retrying with STUN only...`);
      
      setTimeout(() => {
        if (pc.connectionState !== 'closed') {
          createOffer(userId);
        }
      }, 1000);
      
    } else if (stats && stats.iceRestartCount >= 1 && !useTurnFallback) {
      // Second failure - enable TURN fallback
      console.error(`‚ùå [FALLBACK] STUN-only failed after 2 attempts`);
      console.warn(`üîÑ Enabling TURN fallback for this call...`);
      console.warn(`   This indicates symmetric NAT or restrictive firewall`);
      
      useTurnFallback = true;
      
      // Notify user
      toast('Connection issues detected. Trying alternative route...', 'warning');
      
      // Refetch ICE servers with TURN included
      fetchIceServers().then(() => {
        console.log(`‚úÖ TURN servers loaded for fallback`);
        console.log(`   Attempting ICE restart with TURN...`);
        
        // Close old peer connection
        pc.close();
        peerConnections.delete(userId);
        
        // Recreate with TURN-enabled config
        setTimeout(() => {
          createOffer(userId);
        }, 1500);
      });
      
    } else if (useTurnFallback && stats && stats.iceRestartCount >= 2) {
      // Even TURN failed
      console.error(`‚ùå [CRITICAL] Connection failed even with TURN fallback`);
      toast('Unable to establish connection. Please check your network.', 'error');
    }
    
  } else if (state === 'disconnected') {
    console.warn(`‚ö†Ô∏è [ICE] Disconnected from ${userId}`);
    
    // Don't immediately enable TURN on disconnect - might reconnect
    
  } else if (state === 'closed') {
    console.log(`üîí [ICE] Connection closed for ${userId}`);
  } else if (state === 'checking') {
    console.log(`üîç [ICE] Checking connectivity for ${userId}...`);
    
    pc.getStats().then(statsReport => {
      const checkingPairs = [];
      let hasRelayCandidates = false;
      
      statsReport.forEach(report => {
        if (report.type === 'candidate-pair' && report.state === 'in-progress') {
          const localCand = statsReport.get(report.localCandidateId);
          if (localCand) {
            checkingPairs.push(`${localCand.candidateType}/${localCand.protocol}`);
            if (localCand.candidateType === 'relay') hasRelayCandidates = true;
          }
        }
      });
      
      if (checkingPairs.length > 0) {
        console.log(`   Checking pairs: ${checkingPairs.join(', ')}`);
        
        if (!hasRelayCandidates && !useTurnFallback) {
          console.log(`   ‚úÖ STUN-only mode: No relay candidates in use`);
        }
      }
    });
  }
};
  
pc.onconnectionstatechange = () => {
  const state = pc.connectionState;
  const stats = connectionStats.get(userId);
  if (stats) stats.connectionState = state;
  
  console.log(`üîå [PC] Connection state for ${userId}: ${state}`);
  
  if (state === 'connected') {
    console.log(`‚úÖ [PC] Peer connection established with ${userId}`);
    
    socketInstance.emit('connection_state_update', {
      callId: callData.callId,
      state: 'connected',
      userId: userId
    });
    
  } else if (state === 'failed') {
    console.error(`‚ùå [PC] Connection failed with ${userId}`);
    
    // ‚úÖ Detailed failure diagnostics
    pc.getStats().then(statsReport => {
      console.error(`üìä [DIAGNOSTIC] Connection failure stats:`);
      
      let hadRelayCandidates = false;
      let hadSrflxCandidates = false;
      
      statsReport.forEach(report => {
        if (report.type === 'local-candidate') {
          if (report.candidateType === 'relay') hadRelayCandidates = true;
          if (report.candidateType === 'srflx') hadSrflxCandidates = true;
        }
      });
      
      console.error(`   STUN candidates generated: ${hadSrflxCandidates ? 'YES' : 'NO'}`);
      console.error(`   TURN candidates generated: ${hadRelayCandidates ? 'YES' : 'NO'}`);
      
      if (!hadSrflxCandidates && !hadRelayCandidates) {
        console.error(`   ‚ùå NO reflexive or relay candidates - ICE servers unreachable`);
      } else if (!hadSrflxCandidates && hadRelayCandidates) {
        console.error(`   ‚ùå STUN failed but TURN available - likely symmetric NAT`);
      }
    });
    
    socketInstance.emit('connection_state_update', {
      callId: callData.callId,
      state: 'failed',
      userId: userId
    });
  }
};
  
  monitorConnectionQuality(userId, pc);
  
  peerConnections.set(userId, pc);
  console.log(`‚úÖ PeerConnection created for ${userId} with all handlers`);
  return pc;
}


async function createOffer(userId) {
  // ‚úÖ FIX D: Mutex with timeout to prevent deadlock
  const offerMutexKey = `offer_${userId}`;
  
  if (window.offerMutexes && window.offerMutexes.has(offerMutexKey)) {
    console.warn(`‚ö†Ô∏è Offer already in progress for ${userId}, waiting...`);
    
    try {
      await Promise.race([
        window.offerMutexes.get(offerMutexKey),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Mutex timeout')), 5000))
      ]);
    } catch (e) {
      console.error(`‚ùå Mutex timeout for ${userId}, proceeding anyway`);
    }
  }
  
  if (!window.offerMutexes) window.offerMutexes = new Map();
  
  let releaseMutex;
  const mutexPromise = new Promise(resolve => { releaseMutex = resolve; });
  window.offerMutexes.set(offerMutexKey, mutexPromise);
  
  try {
    console.log(`üì§ Creating offer for ${userId}`);
    
    // ‚úÖ FIX F: Remove artificial delay
    // await new Promise(resolve => setTimeout(resolve, 500)); // REMOVED
    
    // ‚úÖ FIX D: Check if PC exists and is in stable state
    let pc = peerConnections.get(userId);
    
    if (pc) {
      if (pc.connectionState === 'closed' || pc.connectionState === 'failed') {
        console.log(`üîÑ Existing PC for ${userId} is ${pc.connectionState}, recreating`);
        pc.close();
        peerConnections.delete(userId);
        pc = null;
      } else if (pc.signalingState !== 'stable') {
        console.warn(`‚ö†Ô∏è Existing PC for ${userId} in unstable state: ${pc.signalingState}`);
        
        // Determine if we should wait or proceed based on polite/impolite
        const polite = currentUser.userId < userId;
        
        if (!polite) {
          console.log(`üö´ Impolite peer - aborting offer to ${userId}`);
          return;
        }
        
        console.log(`üîÑ Polite peer - performing rollback before new offer`);
        try {
          await pc.setLocalDescription({ type: 'rollback' });
          console.log(`‚úÖ Rollback successful`);
        } catch (rollbackError) {
          console.error(`‚ùå Rollback failed:`, rollbackError);
          // Create new PC as fallback
          pc.close();
          peerConnections.delete(userId);
          pc = null;
        }
      }
    }
    
    // Create PC if needed
    if (!pc) {
      pc = createPC(userId);
    }
    
    // Validate local stream
    if (!localStream || localStream.getTracks().length === 0) {
      console.error(`‚ùå No local stream available when creating offer for ${userId}`);
      throw new Error('No local stream');
    }
    
    console.log(`üìä Local stream for offer: ${localStream.getTracks().map(t => `${t.kind}(${t.enabled})`).join(', ')}`);
    
    const offer = await pc.createOffer({ 
      offerToReceiveAudio: true, 
      offerToReceiveVideo: true,
      iceRestart: false  // Will be set to true for recovery
    });
    
    await pc.setLocalDescription(offer);
    
    console.log(`‚úÖ Offer created and set as local description for ${userId}`);
    console.log(`   Offer type: ${offer.type}`);
    console.log(`   Offer SDP length: ${offer.sdp?.length || 0} bytes`);
    console.log(`   PC state: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    socketInstance.emit('webrtc_offer', { 
      callId: callData.callId, 
      targetUserId: userId, 
      offer 
    });
    
    console.log(`üì§ Offer sent to ${userId} via socket`);
    
    // ‚úÖ FIX E: Set up connection failure recovery
    const connectionTimeout = setTimeout(() => {
      const currentPC = peerConnections.get(userId);
      if (currentPC && (currentPC.connectionState === 'new' || currentPC.connectionState === 'connecting')) {
        console.warn(`‚ö†Ô∏è Connection to ${userId} timed out after 10s, attempting ICE restart`);
        
        // ICE restart
        attemptIceRestart(userId);
      }
    }, 10000);
    
    // Store timeout for cleanup
    if (!window.connectionTimeouts) window.connectionTimeouts = new Map();
    window.connectionTimeouts.set(userId, connectionTimeout);
    
  } catch (e) { 
    console.error(`‚ùå Offer creation error for ${userId}:`, e);
    console.error(`   Error name: ${e.name}`);
    console.error(`   Error message: ${e.message}`);
    
    // ‚úÖ FIX E: Retry with ICE restart if first attempt fails
    if (!e.message.includes('No local stream')) {
      console.log(`üîÑ Retrying offer to ${userId} with ICE restart in 2s...`);
      setTimeout(() => attemptIceRestart(userId), 2000);
    }
    
  } finally {
    releaseMutex();
    window.offerMutexes.delete(offerMutexKey);
  }
}

// ‚úÖ NEW FUNCTION: ICE restart helper
async function attemptIceRestart(userId) {
  console.log(`üîÑ ========================================`);
  console.log(`üîÑ ATTEMPTING ICE RESTART`);
  console.log(`üîÑ ========================================`);
  console.log(`   Target: ${userId}`);
  
  const pc = peerConnections.get(userId);
  
  if (!pc) {
    console.log(`‚ùå No PC found for ${userId}, cannot restart ICE`);
    return;
  }
  
  if (pc.connectionState === 'connected') {
    console.log(`‚úÖ Connection already established, ICE restart not needed`);
    return;
  }
  
  try {
    const stats = connectionStats.get(userId);
    if (stats) {
      stats.iceRestartCount = (stats.iceRestartCount || 0) + 1;
      
      if (stats.iceRestartCount > 3) {
        console.error(`‚ùå Too many ICE restart attempts for ${userId} (${stats.iceRestartCount}), giving up`);
        pc.close();
        peerConnections.delete(userId);
        return;
      }
    }
    
    console.log(`üîÑ Creating new offer with iceRestart=true`);
    
    const offer = await pc.createOffer({ 
      offerToReceiveAudio: true, 
      offerToReceiveVideo: true,
      iceRestart: true  // ‚úÖ KEY: ICE restart
    });
    
    await pc.setLocalDescription(offer);
    
    socketInstance.emit('webrtc_offer', { 
      callId: callData.callId, 
      targetUserId: userId, 
      offer 
    });
    
    console.log(`‚úÖ ICE restart offer sent to ${userId}`);
    console.log(`üîÑ ========================================\n`);
    
  } catch (e) {
    console.error(`‚ùå ICE restart failed for ${userId}:`, e);
    console.log(`üîÑ ========================================\n`);
  }
}

async function handleOffer(fromUserId, offer, isRenegotiation = false) {
  if (negotiationMutex.has(fromUserId)) {
    console.warn(`‚ö†Ô∏è Already processing offer from ${fromUserId}, ignoring duplicate`);
    return;
  }
  
  const mutexPromise = (async () => {
    try {
      console.log(`üì• [OFFER] Received ${isRenegotiation ? 'RENEGOTIATION' : 'INITIAL'} offer from ${fromUserId}`);
      console.log(`   Offer type: ${offer.type}, SDP length: ${offer.sdp?.length || 0}`);
      console.log(`   SDP includes video: ${offer.sdp?.includes('m=video') || false}`);
      
      if (!localStream) {
        console.error(`‚ùå CRITICAL: No localStream when handling offer from ${fromUserId}`);
        return;
      }
      
      console.log(`‚úÖ LocalStream validated: ${localStream.getTracks().length} tracks`);
      
      let pc = peerConnections.get(fromUserId);
      
      const offerCollision = pc && 
        (pc.signalingState !== 'stable' && pc.signalingState !== 'have-local-offer');
      
      const polite = currentUser.userId < fromUserId;
      
      console.log(`   Polite: ${polite}, Offer collision: ${offerCollision}`);
      
      if (offerCollision && !polite) {
        console.log(`   üö´ Impolite peer ignoring colliding offer from ${fromUserId}`);
        return;
      }
      
      if (offerCollision && polite) {
        console.log(`   üîÑ Polite peer performing rollback for ${fromUserId}`);
        await pc.setLocalDescription({ type: 'rollback' });
        console.log(`   ‚úÖ Rollback complete`);
      }
      
      if (!pc || pc.connectionState === 'closed') {
        console.log(`üîß Creating new PeerConnection for ${fromUserId}`);
        pc = createPC(fromUserId);
      }
      
      console.log(`üîß Setting remote description (offer) for ${fromUserId}`);
      console.log(`   PC state before: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
      
      await Promise.all([
        pc.setRemoteDescription(new RTCSessionDescription(offer)),
        new Promise(resolve => setTimeout(resolve, 0))
      ]);
      
      // CRITICAL: Handle track changes during renegotiation
pc.onnegotiationneeded = async () => {
  if (pc.signalingState === 'stable') {
    console.log(`üîÑ Negotiation needed for ${fromUserId}, creating offer...`);
    try {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      
      socketInstance.emit('webrtc_offer', {
        callId: callData.callId,
        targetUserId: fromUserId,
        offer: pc.localDescription,
        renegotiation: true
      });
      
      console.log(`‚úÖ Renegotiation offer sent to ${fromUserId}`);
    } catch (err) {
      console.error(`‚ùå Negotiation failed for ${fromUserId}:`, err);
    }
  }
};
      
      console.log(`‚úÖ Remote description set successfully`);
      console.log(`   PC state after: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
      
      if (pendingIceCandidates.has(fromUserId)) {
        const cands = pendingIceCandidates.get(fromUserId);
        console.log(`üßä Adding ${cands.length} pending ICE candidates for ${fromUserId}`);
        
        for (const item of cands) {
          try {
            const c = item.candidate;
            
            if (!c.candidate || typeof c.candidate !== 'string') {
              console.warn(`‚ö†Ô∏è Skipping invalid queued candidate`);
              continue;
            }
            
            if (c.sdpMid === null && c.sdpMLineIndex === null) {
              console.warn(`‚ö†Ô∏è Skipping queued candidate with null sdpMid/sdpMLineIndex`);
              continue;
            }
            
            await pc.addIceCandidate(new RTCIceCandidate(c));
            console.log(`‚úÖ Added pending ICE candidate`);
          } catch (e) {
            console.warn(`‚ö†Ô∏è Failed to add queued candidate:`, e.message);
          }
        }
        pendingIceCandidates.delete(fromUserId);
      }
      
      console.log(`üì§ Creating answer for ${fromUserId}...`);
      
      const answer = await pc.createAnswer();
      console.log(`   Answer created: type=${answer.type}, SDP length=${answer.sdp?.length || 0}`);
      console.log(`   Answer SDP includes video: ${answer.sdp?.includes('m=video') || false}`);
      
      await pc.setLocalDescription(answer);
      console.log(`‚úÖ Answer set as local description`);
      console.log(`   PC state: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
      
      console.log(`üì§ Sending answer to ${fromUserId} via socket`);
      socketInstance.emit('webrtc_answer', { 
        callId: callData.callId, 
        targetUserId: fromUserId, 
        answer 
      });
      console.log(`‚úÖ Answer emitted successfully`);
      
    } catch (e) { 
      console.error(`‚ùå Handle offer error for ${fromUserId}:`, e);
      console.error(`   Error name: ${e.name}`);
      console.error(`   Error message: ${e.message}`);
    } finally {
      setTimeout(() => {
        negotiationMutex.delete(fromUserId);
      }, 100);
    }
  })();
  
  negotiationMutex.set(fromUserId, mutexPromise);
  await mutexPromise;
}

async function handleAnswer(fromUserId, answer) {
  try {
    console.log(`üì• [ANSWER] Received answer from ${fromUserId}`);
    console.log(`   Answer type: ${answer.type}, SDP length: ${answer.sdp?.length || 0}`);
    
    const pc = peerConnections.get(fromUserId);
    
    if (!pc) {
      console.error(`‚ùå No PC found for ${fromUserId} when handling answer`);
      return;
    }
    
    console.log(`üìä PC state before handling answer: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    // CRITICAL: Only accept answer if we're in the right state
    if (pc.signalingState !== 'have-local-offer') {
      console.warn(`‚ö†Ô∏è Ignoring answer from ${fromUserId} - wrong state: ${pc.signalingState}`);
      return;
    }
    
    console.log(`üîß Setting remote description (answer) for ${fromUserId}`);
    await pc.setRemoteDescription(new RTCSessionDescription(answer));
    console.log(`‚úÖ Answer set as remote description`);
    console.log(`   PC state after: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
   // Inside handleAnswer function, replace the pending candidates section:

// Process pending ICE candidates
if (pendingIceCandidates.has(fromUserId)) {
  const cands = pendingIceCandidates.get(fromUserId);
  console.log(`üßä Adding ${cands.length} pending ICE candidates for ${fromUserId}`);
  
  for (const item of cands) {
    try {
      const c = item.candidate;
      
      // Validate before adding
      if (!c.candidate || typeof c.candidate !== 'string') {
        console.warn(`‚ö†Ô∏è Skipping invalid queued candidate`);
        continue;
      }
      
      if (c.sdpMid === null && c.sdpMLineIndex === null) {
        console.warn(`‚ö†Ô∏è Skipping queued candidate with null sdpMid/sdpMLineIndex`);
        continue;
      }
      
      await pc.addIceCandidate(new RTCIceCandidate(c));
      console.log(`‚úÖ Added pending ICE candidate`);
    } catch (e) {
      console.warn(`‚ö†Ô∏è Failed to add queued candidate:`, e.message);
      // Continue with next candidate
    }
  }
  pendingIceCandidates.delete(fromUserId);
}
    
    console.log(`‚úÖ Answer handling complete for ${fromUserId}`);
    
  } catch (e) { 
    console.error(`‚ùå Handle answer error for ${fromUserId}:`, e);
    console.error(`   Error name: ${e.name}`);
    console.error(`   Error message: ${e.message}`);
  }
}

// ‚úÖ FIX H: Modified handleAnswer to acknowledge renegotiations
async function handleAnswer(fromUserId, answer, renegotiationId) {
  try {
    console.log(`üì• [ANSWER] Received answer from ${fromUserId}`);
    if (renegotiationId) {
      console.log(`   Renegotiation ID: ${renegotiationId}`);
    }
    console.log(`   Answer type: ${answer.type}, SDP length: ${answer.sdp?.length || 0}`);
    
    const pc = peerConnections.get(fromUserId);
    
    if (!pc) {
      console.error(`‚ùå No PC found for ${fromUserId} when handling answer`);
      return;
    }
    
    console.log(`üìä PC state before handling answer: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    if (pc.signalingState !== 'have-local-offer') {
      console.warn(`‚ö†Ô∏è Ignoring answer from ${fromUserId} - wrong state: ${pc.signalingState}`);
      return;
    }
    
    console.log(`üîß Setting remote description (answer) for ${fromUserId}`);
    await pc.setRemoteDescription(new RTCSessionDescription(answer));
    console.log(`‚úÖ Answer set as remote description`);
    console.log(`   PC state after: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    // Process pending ICE candidates
    if (pendingIceCandidates.has(fromUserId)) {
      const cands = pendingIceCandidates.get(fromUserId);
      console.log(`üßä Adding ${cands.length} pending ICE candidates for ${fromUserId}`);
      
      for (const item of cands) {
        try {
          const c = item.candidate;
          
          if (!c.candidate || typeof c.candidate !== 'string') {
            console.warn(`‚ö†Ô∏è Skipping invalid queued candidate`);
            continue;
          }
          
          if (c.sdpMid === null && c.sdpMLineIndex === null) {
            console.warn(`‚ö†Ô∏è Skipping queued candidate with null sdpMid/sdpMLineIndex`);
            continue;
          }
          
          await pc.addIceCandidate(new RTCIceCandidate(c));
          console.log(`‚úÖ Added pending ICE candidate`);
        } catch (e) {
          console.warn(`‚ö†Ô∏è Failed to add queued candidate:`, e.message);
        }
      }
      pendingIceCandidates.delete(fromUserId);
    }
    
    // ‚úÖ FIX H: Acknowledge renegotiation completion
    if (renegotiationId && window.pendingRenegotiations && window.pendingRenegotiations.has(renegotiationId)) {
      const pending = window.pendingRenegotiations.get(renegotiationId);
      clearTimeout(pending.timeout);
      pending.resolve();
      window.pendingRenegotiations.delete(renegotiationId);
      console.log(`‚úÖ Renegotiation ${renegotiationId} acknowledged`);
    }
    
    console.log(`‚úÖ Answer handling complete for ${fromUserId}`);
    
  } catch (e) { 
    console.error(`‚ùå Handle answer error for ${fromUserId}:`, e);
    console.error(`   Error name: ${e.name}`);
    console.error(`   Error message: ${e.message}`);
  }
}

// Replace handleIceCandidate function
async function handleIceCandidate(fromUserId, candidate) {
  try {
    if (!candidate) {
      console.log(`üßä [ICE] Received end-of-candidates from ${fromUserId}`);
      return;
    }
    
    // CRITICAL FIX: Validate candidate structure before queuing/adding
    if (!candidate.candidate || typeof candidate.candidate !== 'string') {
      console.warn(`‚ö†Ô∏è [ICE] Invalid candidate structure from ${fromUserId}:`, candidate);
      return;
    }
    
    // Additional validation for required fields
    if (candidate.sdpMid === null && candidate.sdpMLineIndex === null) {
      console.warn(`‚ö†Ô∏è [ICE] Candidate missing both sdpMid and sdpMLineIndex from ${fromUserId}, skipping`);
      return;
    }
    
    const pc = peerConnections.get(fromUserId);
    
    // Queue candidates if no PC yet OR if remote description not set
    if (!pc || !pc.remoteDescription) {
      if (!pendingIceCandidates.has(fromUserId)) {
        pendingIceCandidates.set(fromUserId, []);
      }
      
      const queue = pendingIceCandidates.get(fromUserId);
      queue.push({
        candidate: candidate,
        timestamp: Date.now()
      });
      
      console.log(`üßä [ICE] Queued candidate from ${fromUserId} (pending: ${queue.length})`);
      
      // Auto-cleanup old candidates after 30 seconds
      setTimeout(() => {
        const currentQueue = pendingIceCandidates.get(fromUserId);
        if (currentQueue) {
          const filtered = currentQueue.filter(item => Date.now() - item.timestamp < 30000);
          if (filtered.length !== currentQueue.length) {
            console.log(`üßπ [ICE] Cleaned ${currentQueue.length - filtered.length} old candidates for ${fromUserId}`);
            pendingIceCandidates.set(fromUserId, filtered);
          }
        }
      }, 30000);
      
      return;
    }
    
    // Add candidate if PC is ready
    try {
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
      const stats = connectionStats.get(fromUserId);
      if (stats) stats.candidatesReceived++;
      
      const candidateType = candidate.type || candidate.candidate?.split(' ')[7] || 'unknown';
      console.log(`üßä [ICE] Added ${candidateType} candidate from ${fromUserId} (total: ${stats?.candidatesReceived || 0})`);
    } catch (addError) {
      console.warn(`‚ö†Ô∏è [ICE] Failed to add candidate from ${fromUserId}:`, addError.message);
      // Don't throw - continue processing other candidates
    }
    
  } catch (e) { 
    console.warn(`‚ö†Ô∏è [ICE] Candidate processing error for ${fromUserId}:`, e.message);
  }
}

function toggleMic() {
  if (localStream) {
    const track = localStream.getAudioTracks()[0];
    if (track) {
      track.enabled = !track.enabled;
      isAudioEnabled = track.enabled;
      const btn = document.getElementById('micBtn');
      const icon = btn.querySelector('.material-symbols-outlined');
      const mic = document.getElementById(`mic-${currentUser.userId}`);
      
      console.log(`üé§ Mic toggled: ${isAudioEnabled ? 'ON' : 'OFF'}`);
      
      if (isAudioEnabled) {
        btn.classList.add('bg-primary', 'text-white');
        btn.classList.remove('bg-accent-red');
        icon.textContent = 'mic';
        if (mic) mic.classList.add('hidden');
      } else {
        btn.classList.remove('bg-primary');
        btn.classList.add('bg-accent-red', 'text-white');
        icon.textContent = 'mic_off';
        if (mic) mic.classList.remove('hidden');
      }
      
      socketInstance.emit('audio_state_changed', { callId: callData.callId, enabled: isAudioEnabled });
    }
  }
}

async function toggleVideo() {
  const now = Date.now();
  if (now - lastVideoToggleTime < VIDEO_TOGGLE_DEBOUNCE) {
    console.log('‚ö†Ô∏è Video toggle debounced - too soon after last toggle');
    return;
  }
  lastVideoToggleTime = now;
  
  if (isTogglingVideo) {
    console.log('‚ö†Ô∏è Video toggle already in progress, ignoring');
    return;
  }
  
  isTogglingVideo = true;
  
  try {
    console.log(`üìπ ========================================`);
    console.log(`üìπ VIDEO TOGGLE STARTED`);
    console.log(`üìπ ========================================`);
    console.log(`   Call type: ${callData.callType}`);
    console.log(`   Current isVideoEnabled: ${isVideoEnabled}`);
    console.log(`   LocalStream exists: ${!!localStream}`);
    console.log(`   Video tracks before: ${localStream?.getVideoTracks().length || 0}`);
    console.log(`   Active peer connections: ${peerConnections.size}`);
    console.log(`   Socket connected: ${socketInstance?.connected}`);
    
    if (!localStream) {
      console.error('‚ùå No localStream available');
      isTogglingVideo = false;
      return;
    }
    
    if (!socketInstance || !socketInstance.connected) {
      console.error('‚ùå Socket not connected');
      isTogglingVideo = false;
      return;
    }
    
    let track = localStream.getVideoTracks()[0];
    
    if (!track) {
      console.log(`üìπ No existing video track - requesting camera...`);
      
      try {
        const videoStream = await navigator.mediaDevices.getUserMedia({
          video: { 
            width: {ideal: 640}, 
            height: {ideal: 480},
            facingMode: 'user'
          }
        });
        
        track = videoStream.getVideoTracks()[0];
        
        if (!track) {
          console.error('‚ùå Failed to get video track from camera');
          isTogglingVideo = false;
          return;
        }
        
        console.log(`‚úÖ Got new video track: ${track.id}`);
        localStream.addTrack(track);
        track.enabled = true;
        isVideoEnabled = true;
        
        console.log(`üìä Adding track to ${peerConnections.size} peer connection(s)...`);
        
        // Add track to all peer connections
        const addPromises = [];
        peerConnections.forEach((pc, userId) => {
          console.log(`   üì§ Adding video track to PC for ${userId}`);
          try {
            const sender = pc.addTrack(track, localStream);
            console.log(`   ‚úÖ Track added, sender: ${sender ? 'yes' : 'no'}`);
          } catch (e) {
            console.error(`   ‚ùå Failed to add track to ${userId}:`, e);
          }
        });
        
        // Wait a moment for tracks to be added
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Now renegotiate with ALL peers
        console.log(`üîÑ Starting renegotiation with ${peerConnections.size} peer(s)...`);
        
        const renegotiationPromises = [];
        peerConnections.forEach((pc, userId) => {
          const renegotiatePromise = (async () => {
            try {
              console.log(`üîÑ [${userId}] Starting renegotiation...`);
              console.log(`   SignalingState: ${pc.signalingState}`);
              console.log(`   ConnectionState: ${pc.connectionState}`);
              console.log(`   IceConnectionState: ${pc.iceConnectionState}`);
              
              // Wait for stable state
              const maxWait = 15000;
              const startWait = Date.now();
              
              while (pc.signalingState !== 'stable' && (Date.now() - startWait) < maxWait) {
                console.log(`   ‚è≥ [${userId}] Waiting for stable (current: ${pc.signalingState})`);
                await new Promise(resolve => setTimeout(resolve, 200));
              }
              
              if (pc.signalingState !== 'stable') {
                console.error(`   ‚ùå [${userId}] Not stable after ${maxWait}ms - aborting`);
                return;
              }
              
              console.log(`   ‚úÖ [${userId}] PC is stable, creating offer...`);
              
              // Log current senders
              const senders = pc.getSenders();
              console.log(`   üìä [${userId}] Current senders: ${senders.length}`);
              senders.forEach((sender, i) => {
                const kind = sender.track?.kind || 'null';
                const enabled = sender.track?.enabled || false;
                const id = sender.track?.id?.substring(0, 8) || 'null';
                console.log(`      [${i}] ${kind} - enabled:${enabled} - id:${id}`);
              });
              
              const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
              
              console.log(`   ‚úÖ [${userId}] Offer created`);
              console.log(`      Type: ${offer.type}`);
              console.log(`      Has video: ${offer.sdp.includes('m=video')}`);
              console.log(`      SDP length: ${offer.sdp.length}`);
              
              await pc.setLocalDescription(offer);
              console.log(`   ‚úÖ [${userId}] Local description set`);
              
              // Emit the offer
              console.log(`   üì§ [${userId}] Emitting webrtc_offer...`);
              socketInstance.emit('webrtc_offer', {
                callId: callData.callId,
                targetUserId: userId,
                offer: offer,
                renegotiation: true
              });
              console.log(`   ‚úÖ [${userId}] Offer emitted successfully`);
              
            } catch (e) {
              console.error(`   ‚ùå [${userId}] Renegotiation failed:`, e);
              console.error(`      Error name: ${e.name}`);
              console.error(`      Error message: ${e.message}`);
              console.error(`      Stack:`, e.stack);
            }
          })();
          
          renegotiationPromises.push(renegotiatePromise);
        });
        
        await Promise.all(renegotiationPromises);
        console.log(`‚úÖ All renegotiations completed`);
        
        // Update local video
        const localVid = document.getElementById(`video-${currentUser.userId}`);
        if (localVid) {
          if (!localVid.srcObject) {
            localVid.srcObject = localStream;
          }
          try {
            await localVid.play();
            console.log(`‚ñ∂Ô∏è Local video playing`);
          } catch (e) {
            console.error(`‚ùå Failed to play local video:`, e);
          }
        }
        
        updateVideoVisibility(currentUser.userId, true, false);
        updateVideoButton();
        
        // Emit state change
        console.log(`üì§ Emitting video_state_changed: enabled=true`);
        socketInstance.emit('video_state_changed', {
          callId: callData.callId,
          enabled: true
        });
        console.log(`‚úÖ Video state change emitted`);
        
      } catch (error) {
        console.error(`‚ùå Failed to get camera:`, error);
        console.error(`   Error name: ${error.name}`);
        console.error(`   Error message: ${error.message}`);
        isVideoEnabled = false;
        updateVideoButton();
      }
      
    } else {
      // Toggle existing track
      console.log(`üìπ Toggling existing video track`);
      console.log(`   Track ID: ${track.id}`);
      console.log(`   Current enabled: ${track.enabled}`);
      console.log(`   Current readyState: ${track.readyState}`);
      
      track.enabled = !track.enabled;
      isVideoEnabled = track.enabled;
      
      console.log(`   ‚úÖ Track toggled to: ${isVideoEnabled ? 'ENABLED' : 'DISABLED'}`);
      
      updateVideoVisibility(currentUser.userId, isVideoEnabled, false);
      updateVideoButton();
      
      console.log(`üì§ Emitting video_state_changed: enabled=${isVideoEnabled}`);
      socketInstance.emit('video_state_changed', {
        callId: callData.callId,
        enabled: isVideoEnabled
      });
      console.log(`‚úÖ Video state change emitted`);
    }
    
    console.log(`üìπ ========================================`);
    console.log(`üìπ VIDEO TOGGLE COMPLETED`);
    console.log(`   Final isVideoEnabled: ${isVideoEnabled}`);
    console.log(`   Video tracks: ${localStream.getVideoTracks().length}`);
    console.log(`üìπ ========================================\n`);
    
  } catch (error) {
    console.error(`‚ùå FATAL ERROR in toggleVideo:`, error);
    console.error(`   Error name: ${error.name}`);
    console.error(`   Error message: ${error.message}`);
    console.error(`   Stack:`, error.stack);
  } finally {
    isTogglingVideo = false;
  }
}

    function updateDuration() {
  const roomStr = localStorage.getItem('currentRoom');
  if (!roomStr) {
    console.warn('‚ö†Ô∏è No room data - cannot sync timer');
    return;
  }
  
  try {
    const roomData = JSON.parse(roomStr);
    
    if (!roomData.expiresAt) {
      console.error('‚ùå No expiresAt in room data');
      return;
    }
    
    // Use stored expiresAt if available, otherwise use from localStorage
    const expiresAt = roomExpiresAt || roomData.expiresAt;
    
    // CRITICAL FIX: Use server-adjusted time
    const clientNow = Date.now();
    const serverNow = clientNow + serverClockOffset; // Adjust for clock skew
    const remaining = Math.max(0, expiresAt - serverNow);
    
    const totalSeconds = Math.floor(remaining / 1000);
    const h = Math.floor(totalSeconds / 3600);
    const m = Math.floor((totalSeconds % 3600) / 60);
    const s = totalSeconds % 60;
    
    const el = document.getElementById('callDuration');
    if (el) {
      el.textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }
    
    // Log every 10 seconds for debugging
    if (totalSeconds % 10 === 0) {
      console.log(`‚è∞ Call timer: ${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')} remaining`);
      console.log(`   Server expiresAt: ${new Date(expiresAt).toISOString()}`);
      console.log(`   Client now: ${new Date(clientNow).toISOString()}`);
      console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
      console.log(`   Clock offset: ${(serverClockOffset / 1000).toFixed(1)}s`);
    }
    
    if (remaining === 0) {
      console.log('‚è∞ Room expired during call - ending call');
      if (durationInterval) clearInterval(durationInterval);
      toast('Room has expired', 'warning');
      leaveCall();
    }
  } catch (e) {
    console.error('‚ùå Timer sync error:', e);
  }
}

      function leaveCall() {
  if (isInitializing) return;
  isInitializing = true;
  
  console.log('üö™ ========================================');
  console.log('üö™ LEAVE CALL INITIATED');
  console.log('üö™ ========================================');
  
  audioContexts.forEach(ac => {
    try {
      if (ac.stop) ac.stop();
      if (ac.context && ac.context.state !== 'closed') {
        ac.context.close().catch(e => console.warn('Failed to close audio context:', e));
      }
    } catch (e) {
      console.warn('Failed to cleanup audio context:', e);
    }
  });
  audioContexts.clear();
  
  if (localStream) localStream.getTracks().forEach(t => t.stop());
  peerConnections.forEach(pc => pc.close());
  peerConnections.clear();
  
  if (socketInstance && socketInstance.connected) {
    socketInstance.emit('leave_call', { callId: callData.callId });
    console.log('‚úÖ leave_call emitted to server');
  }
  
  if (durationInterval) clearInterval(durationInterval);
  
  localStorage.removeItem('activeCall');
  sessionStorage.removeItem('hasBackgroundCall');
  sessionStorage.removeItem('returningFromCall');
  sessionStorage.removeItem('backgroundCallMode');
  sessionStorage.removeItem('returningToBackgroundCall');
  
  console.log('‚úÖ All call data cleared');
  console.log('üö™ ========================================\n');
  
  setTimeout(() => { window.location.href = '/chat.html'; }, 500);
}
      
      
      
      // Add this helper function before initCall()
let joinCallRetryCount = 0;
const MAX_JOIN_RETRIES = 3;

async function attemptJoinCall(callId, retryDelay = 1000) {
  return new Promise((resolve, reject) => {
    console.log(`üîÑ Attempting to join call (attempt ${joinCallRetryCount + 1}/${MAX_JOIN_RETRIES})`);
    
    socketInstance.emit('join_call', { callId });
    
    // Set timeout for response
    const timeout = setTimeout(() => {
      joinCallRetryCount++;
      
      if (joinCallRetryCount < MAX_JOIN_RETRIES) {
        console.warn(`‚ö†Ô∏è Join call timeout, retrying in ${retryDelay}ms...`);
        setTimeout(() => {
          attemptJoinCall(callId, retryDelay * 1.5).then(resolve).catch(reject);
        }, retryDelay);
      } else {
        reject(new Error('Failed to join call after maximum retries'));
      }
    }, 5000); // 5 second timeout per attempt
    
    // Listen for successful join (one-time)
    const handleJoined = (data) => {
      clearTimeout(timeout);
      joinCallRetryCount = 0; // Reset on success
      console.log(`‚úÖ Join call succeeded on attempt ${joinCallRetryCount + 1}`);
      socketInstance.off('call_joined', handleJoined);
      socketInstance.off('error', handleError);
      resolve(data);
    };
    
    const handleError = (errorData) => {
      clearTimeout(timeout);
      socketInstance.off('call_joined', handleJoined);
      socketInstance.off('error', handleError);
      reject(new Error(errorData.message || 'Join call failed'));
    };
    
    socketInstance.once('call_joined', handleJoined);
    socketInstance.once('error', handleError);
  });
}
      

      async function initCall() {
      
        const returningToBackground = sessionStorage.getItem('returningToBackgroundCall') === 'true';
  
  if (returningToBackground) {
    console.log('üîÑ ========================================');
    console.log('üîÑ RETURNING TO BACKGROUND CALL');
    console.log('üîÑ ========================================');
    
    sessionStorage.removeItem('returningToBackgroundCall');
    
    // Call is already active, we're just returning to the UI
    console.log('‚ÑπÔ∏è Call connections should already be active');
    console.log('‚ÑπÔ∏è Reconnecting to existing call state...');
    
    // The rest of initCall will handle reconnection
  }
      
        if (isInitializing) return;
        isInitializing = true;
        console.log('=== INIT CALL ===');
        
        try {
          await _Auth.requireAuth();
          await fetchIceServers();
          
          const callStr = localStorage.getItem('activeCall');
          if (!callStr) { toast('No active call', 'error'); setTimeout(() => window.location.href = '/chat.html', 1500); return; }
          
          callData = JSON.parse(callStr);
          console.log(`üìû Call: ${callData.callId} (${callData.callType})`);
          
          const firebaseUser = firebase.auth().currentUser;
          if (!firebaseUser) { window.location.href = '/login.html'; return; }
          
          const userData = await _API.get('/api/users/me');
          currentUser = { userId: userData._id, username: userData.username, pfpUrl: userData.pfpUrl };
          console.log(`üë§ Current user: ${currentUser.username} (${currentUser.userId})`);
          
          const title = document.getElementById('callTitle');
          if (title) title.textContent = `${callData.callType === 'video' ? 'Video' : 'Audio'} Call`;
          
          const token = await firebaseUser.getIdToken();
          socketInstance = io(window.location.origin, {
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            auth: { token }
          });
          
          socketInstance.on('connect', () => {
            console.log(`üîå Connected: ${socketInstance.id}`);
            socketInstance.emit('authenticate', { token, userId: currentUser.userId });
          });
          
          // Inside initCall() function, replace the 'authenticated' handler:



socketInstance.on('room_expired', (data) => {
  console.error('üí• ========================================');
  console.error('üí• ROOM_EXPIRED EVENT RECEIVED FROM SERVER');
  console.error('üí• ========================================');
  console.error(`   roomId: ${data.roomId}`);
  console.error(`   message: ${data.message}`);
  console.error(`   Server says room expired at: ${new Date().toISOString()}`);
  
  if (roomExpiresAt) {
    const serverExpiry = new Date(roomExpiresAt).toISOString();
    const clientNow = new Date().toISOString();
    const serverNow = new Date(Date.now() + serverClockOffset).toISOString();
    console.error(`   expiresAt was: ${serverExpiry}`);
    console.error(`   Client time now: ${clientNow}`);
    console.error(`   Server time now (adjusted): ${serverNow}`);
  }
  
  console.error('üí• ========================================\n');
  
  if (durationInterval) clearInterval(durationInterval);
  toast(data.message || 'Room has expired', 'warning');
  
  // Clean up and redirect
  leaveCall();
});

socketInstance.on('room_expiring_soon', (data) => {
  console.warn('‚ö†Ô∏è ========================================');
  console.warn('‚ö†Ô∏è ROOM EXPIRING SOON');
  console.warn('‚ö†Ô∏è ========================================');
  console.warn(`   Expires in: ${data.expiresIn / 1000} seconds`);
  console.warn(`   expiresAt: ${new Date(data.expiresAt).toISOString()}`);
  
  const clientNow = Date.now();
  const serverNow = clientNow + serverClockOffset;
  const remaining = data.expiresAt - serverNow;
  
  console.warn(`   Client now: ${new Date(clientNow).toISOString()}`);
  console.warn(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
  console.warn(`   Remaining (adjusted): ${(remaining / 1000).toFixed(1)}s`);
  console.warn('‚ö†Ô∏è ========================================\n');
  
  toast(`Room expiring soon!`, 'warning');
});

socketInstance.on('authenticated', async () => {
  console.log('‚úÖ Authenticated');
  
  // CRITICAL: Request room data from server to get clock sync
  const roomStr = localStorage.getItem('currentRoom');
  if (roomStr) {
    try {
      const roomData = JSON.parse(roomStr);
      console.log('üì¶ Requesting fresh room data for clock sync...');
      
      // Emit a request for fresh room data (you'll need to add this handler on server)
      socketInstance.emit('request_room_sync', { roomId: roomData.roomId });
      
    } catch (e) {
      console.error('‚ùå Failed to parse room data:', e);
    }
  }
  
  // CRITICAL FIX: Prevent duplicate join attempts
  if (isJoiningCall) {
    console.warn(`‚ö†Ô∏è Already joining call, ignoring duplicate authenticated event`);
    return;
  }
  
  if (!hasJoinedCall) {
    isJoiningCall = true;
    hasJoinedCall = true;
    
    try {
      console.log(`üìû Attempting to join call ${callData.callId}...`);
      await attemptJoinCall(callData.callId);
      console.log(`‚úÖ Successfully joined call ${callData.callId}`);
    } catch (error) {
      console.error('‚ùå Failed to join call:', error);
      toast('Failed to join call. Returning to chat...', 'error');
      setTimeout(() => {
        window.location.href = '/chat.html';
      }, 2000);
    } finally {
      isJoiningCall = false;
    }
  }
});


socketInstance.on('room_sync_data', (data) => {
  console.log('‚è∞ ========================================');
  console.log('‚è∞ ROOM SYNC DATA RECEIVED');
  console.log('‚è∞ ========================================');
  
  const clientNow = Date.now();
  
  if (!data.serverTime) {
    console.warn('‚ö†Ô∏è No serverTime in sync data, assuming no clock skew');
    data.serverTime = clientNow;
  }
  
  // Calculate clock offset
  serverClockOffset = data.serverTime - clientNow;
  
  console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
  console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
  console.log(`   ‚è∞ CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);
  
  if (Math.abs(serverClockOffset) > 5000) {
    console.warn(`‚ö†Ô∏è WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
    console.warn(`   Timer will be adjusted to compensate`);
  }
  
  if (data.expiresAt) {
    roomExpiresAt = data.expiresAt;
    
    // Calculate time remaining using server-adjusted time
    const serverNow = clientNow + serverClockOffset;
    const timeRemaining = data.expiresAt - serverNow;
    
    console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
    console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
    console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);
    
    // Update localStorage with synced data
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const roomData = JSON.parse(roomStr);
        roomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(roomData));
        console.log('‚úÖ Updated localStorage with server expiry time');
      } catch (e) {
        console.error('‚ùå Failed to update localStorage:', e);
      }
    }
  }
  
  console.log('‚è∞ ========================================\n');
  
  // Force timer update with new data
  updateDuration();
});
          
          
socketInstance.on('webrtc_offer', async ({ fromUserId, offer, renegotiation }) => {
  console.log(`üì• ========================================`);
  console.log(`üì• WEBRTC_OFFER EVENT RECEIVED`);
  console.log(`üì• ========================================`);
  console.log(`   From: ${fromUserId}`);
  console.log(`   Type: ${renegotiation ? 'RENEGOTIATION' : 'INITIAL'}`);
  console.log(`   Offer SDP includes video: ${offer.sdp?.includes('m=video') || false}`);
  
  await handleOffer(fromUserId, offer, renegotiation);
  
  // CRITICAL: After handling renegotiation, check and update video visibility
  if (renegotiation) {
    setTimeout(() => {
      const remoteVideo = document.getElementById(`video-${fromUserId}`);
      if (remoteVideo && remoteVideo.srcObject) {
        const videoTracks = remoteVideo.srcObject.getVideoTracks();
        const hasVideo = videoTracks.length > 0 && videoTracks[0].enabled;
        console.log(`üîÑ Post-renegotiation: ${fromUserId} has video = ${hasVideo}`);
        updateVideoVisibility(fromUserId, hasVideo, hasVideo);
      }
    }, 500);
  }
  
  console.log(`üì• ========================================\n`);
});

socketInstance.on('webrtc_answer', ({ fromUserId, answer, renegotiationId }) => {
  handleAnswer(fromUserId, answer, renegotiationId);
});

socketInstance.on('ice_candidate', (d) => {
  console.log(`üîî [SOCKET] ice_candidate event received from ${d.fromUserId}`);
  handleIceCandidate(d.fromUserId, d.candidate);
});
          
          
socketInstance.on('call_joined', async (data) => {
  console.log(`‚úÖ ========================================`);
  console.log(`‚úÖ CALL_JOINED EVENT RECEIVED`);
  console.log(`‚úÖ ========================================`);
  console.log(`üìä Participants: ${data.participants.length}`);
  
  // Log all participants
  data.participants.forEach((p, i) => {
    console.log(`   [${i}] ${p.username} (${p.userId}) video:${p.videoEnabled} audio:${p.audioEnabled}`);
  });
  
  if (!data.participants || data.participants.length === 0) {
    console.error('‚ùå Received call_joined with 0 participants!');
    toast('Call state error. Please try again.', 'error');
    setTimeout(() => {
      window.location.href = '/chat.html';
    }, 2000);
    return;
  }
  
  const subtitle = document.getElementById('callSubtitle');
  if (subtitle) subtitle.textContent = `${data.participants.length} participant${data.participants.length>1?'s':''}`;
  
  console.log(`üé¨ Initializing local media...`);
  try {
    await initLocalMedia();
    console.log(`‚úÖ Local media initialized successfully`);
  } catch (mediaError) {
    console.error(`‚ùå Media initialization failed:`, mediaError);
    toast('Failed to initialize media.', 'error');
  }
  
  if (!localStream) {
    console.error(`‚ùå CRITICAL: localStream is still null!`);
    localStream = new MediaStream();
  }
  
  console.log(`üìä LocalStream: ${localStream.getTracks().length} tracks`);
  localStream.getTracks().forEach((track, i) => {
    console.log(`   [${i}] ${track.kind} (${track.id.substring(0, 8)}...) enabled:${track.enabled}`);
  });
  
  const grid = document.getElementById('participantGrid');
  if (!grid) {
    console.error('‚ùå Grid element not found!');
    return;
  }
  
  const fragment = document.createDocumentFragment();
  
  console.log(`üßπ Clearing grid and tracking`);
  grid.innerHTML = '';
  renderedParticipants.clear();
  
  console.log(`üìã Rendering ${data.participants.length} tiles`);
  
  const sortedParticipants = [...data.participants].sort((a, b) => 
    a.userId.localeCompare(b.userId)
  );
  
  let selfTileRendered = false;
  
  sortedParticipants.forEach((p, index) => {
    const isSelf = p.userId === currentUser.userId;
    const videoState = p.videoEnabled !== undefined ? p.videoEnabled : (callData.callType === 'video');
    const audioState = p.audioEnabled !== undefined ? p.audioEnabled : true;
    
    console.log(`[${index}] Rendering ${p.username} (${p.userId}) isSelf=${isSelf} video=${videoState} audio=${audioState}`);
    
    const tile = createParticipantTile(p, isSelf);
    if (tile) {
      fragment.appendChild(tile);
      console.log(`‚úÖ [${index}] Tile created for ${p.username}`);
      
      if (isSelf) selfTileRendered = true;
      
      if (audioState === false) {
        const micIndicator = tile.querySelector(`#mic-${p.userId}`);
        if (micIndicator) {
          micIndicator.classList.remove('hidden');
          console.log(`   üîá Mic indicator shown for ${p.username}`);
        }
      }
      
      if (!isSelf && videoState === false) {
        const vid = tile.querySelector(`#video-${p.userId}`);
        const pfp = tile.querySelector(`#pfp-${p.userId}`);
        if (vid && pfp) {
          vid.classList.add('hidden');
          pfp.classList.remove('hidden');
          console.log(`   üìπ Video hidden for ${p.username}`);
        }
      }
    }
  });
  
  grid.appendChild(fragment);
  
  console.log(`üé® Grid complete: ${grid.children.length} tiles`);
  console.log(`üìä Rendered participants:`, Array.from(renderedParticipants));
  
  if (selfTileRendered) {
    console.log(`üé¨ Setting up local video...`);
    await setupLocalVideo();
  } else {
    console.warn(`‚ö†Ô∏è Self tile not rendered!`);
  }
  
  const remoteParticipants = sortedParticipants.filter(p => p.userId !== currentUser.userId);
  
  console.log(`üîó Processing ${remoteParticipants.length} remote participants for WebRTC...`);
  
  for (let i = 0; i < remoteParticipants.length; i++) {
    const p = remoteParticipants[i];
    const shouldInitiateOffer = currentUser.userId < p.userId;
    
    console.log(`üîó [${i}] ${p.username} (${p.userId}): shouldInitiate=${shouldInitiateOffer}`);
    
    if (shouldInitiateOffer) {
      const delay = 1000 + (i * 500);
      console.log(`   ‚è±Ô∏è Will create offer in ${delay}ms`);
      setTimeout(() => {
        console.log(`üì§ [${i}] Creating offer to ${p.username}`);
        createOffer(p.userId);
      }, delay);
    } else {
      console.log(`   ‚è≥ Will wait for offer from ${p.username}`);
    }
  }
  
  console.log('‚è∞ Starting synced timer with room expiry and clock compensation');
  console.log(`   Clock offset: ${(serverClockOffset / 1000).toFixed(1)}s`);
  
  durationInterval = setInterval(updateDuration, 1000);
  updateDuration(); // Update immediately
  
  isInitializing = false;
  console.log('‚úÖ ========================================');
  console.log('‚úÖ INIT COMPLETE');
  console.log('‚úÖ ========================================\n');
});
          
// ‚úÖ CRITICAL FIX: Handle remote users joining the call
socketInstance.on('user_joined_call', ({ user, mediaState }) => {
  console.log(`üë§ ========================================`);
  console.log(`üë§ REMOTE USER JOINED CALL`);
  console.log(`üë§ ========================================`);
  console.log(`   User: ${user.username} (${user.userId})`);
  console.log(`   Video: ${mediaState.videoEnabled}`);
  console.log(`   Audio: ${mediaState.audioEnabled}`);
  
  // Skip if it's the current user
  if (user.userId === currentUser.userId) {
    console.log(`‚ÑπÔ∏è User joined event is for self, ignoring`);
    console.log(`üë§ ========================================\n`);
    return;
  }
  
  // Check if tile already exists
  if (renderedParticipants.has(user.userId)) {
    console.log(`‚ÑπÔ∏è Tile already exists for ${user.username}`);
    console.log(`üë§ ========================================\n`);
    return;
  }
  
  // Create tile for the new participant
  console.log(`üé® Creating tile for new participant ${user.username}`);
  
  const grid = document.getElementById('participantGrid');
  if (!grid) {
    console.error(`‚ùå Grid element not found!`);
    return;
  }
  
  const tile = createParticipantTile({
    username: user.username,
    userId: user.userId,
    pfpUrl: user.profilePicture || user.pfpUrl,
    videoEnabled: mediaState.videoEnabled,
    audioEnabled: mediaState.audioEnabled
  }, false); // isSelf = false
  
  if (tile) {
    grid.appendChild(tile);
    console.log(`‚úÖ Tile added to grid for ${user.username}`);
    
    // Update mic indicator if audio is off
    if (!mediaState.audioEnabled) {
      const micIndicator = document.getElementById(`mic-${user.userId}`);
      if (micIndicator) {
        micIndicator.classList.remove('hidden');
        console.log(`   üîá Mic indicator shown for ${user.username}`);
      }
    }
    
    // Update video visibility
    if (!mediaState.videoEnabled) {
      updateVideoVisibility(user.userId, false, false);
      console.log(`   üìπ Video hidden for ${user.username}`);
    }
  }
  
  console.log(`‚úÖ Tile created for ${user.username}`);
  console.log(`üìä Total rendered participants: ${renderedParticipants.size}`);
  console.log(`üë§ ========================================\n`);
  
  // Now that tile exists, initiate WebRTC connection if we should
  const shouldInitiate = currentUser.userId > user.userId;
  
  if (shouldInitiate) {
    console.log(`üîó We should initiate connection to ${user.username}`);
    console.log(`   Waiting 1000ms before creating offer...`);
    
    setTimeout(() => {
      console.log(`üì§ Creating offer to ${user.username} (${user.userId})`);
      createOffer(user.userId);
    }, 1000);
  } else {
    console.log(`‚è≥ Waiting for offer from ${user.username}`);
  }
});

          
socketInstance.on('user_left_call', ({ userId, username }) => {
  console.log(`üëã ========================================`);
  console.log(`üëã USER LEFT CALL`);
  console.log(`üëã ========================================`);
  console.log(`   User: ${username} (${userId})`);
  
  // Clean up peer connection
  if (peerConnections.has(userId)) {
    const pc = peerConnections.get(userId);
    pc.close();
    peerConnections.delete(userId);
    console.log(`üóëÔ∏è Closed peer connection for ${userId}`);
  }
  
  // Clean up audio context
  if (audioContexts.has(userId)) {
    const ctx = audioContexts.get(userId);
    if (ctx.stop) ctx.stop();
    if (ctx.context && ctx.context.state !== 'closed') {
      ctx.context.close().catch(e => console.warn('Failed to close audio context:', e));
    }
    audioContexts.delete(userId);
    console.log(`üóëÔ∏è Closed audio context for ${userId}`);
  }
  
  // Clean up connection stats
  const stats = connectionStats.get(userId);
  if (stats && stats.monitorInterval) {
    clearInterval(stats.monitorInterval);
  }
  connectionStats.delete(userId);
  pendingIceCandidates.delete(userId);
  
  // Clean up unmute interval
  if (window.unmuteIntervals && window.unmuteIntervals.has(userId)) {
    clearInterval(window.unmuteIntervals.get(userId));
    window.unmuteIntervals.delete(userId);
  }
  
  // Clean up connection timeout
  if (window.connectionTimeouts && window.connectionTimeouts.has(userId)) {
    clearTimeout(window.connectionTimeouts.get(userId));
    window.connectionTimeouts.delete(userId);
  }
  
  // Remove from rendered participants
  renderedParticipants.delete(userId);
  
  // Remove tile from DOM
  const tile = document.getElementById(`participant-${userId}`);
  if (tile) {
    tile.remove();
    console.log(`üóëÔ∏è Removed tile for ${userId}`);
  }
  
  console.log(`‚úÖ Fully cleaned up resources for ${userId}`);
  
  // Update participant count in subtitle
  const subtitle = document.getElementById('callSubtitle');
  if (subtitle) {
    const remainingCount = renderedParticipants.size;
    subtitle.textContent = `${remainingCount} participant${remainingCount !== 1 ? 's' : ''}`;
  }
  
  console.log(`üìä Remaining participants: ${renderedParticipants.size}`);
  console.log(`üëã ========================================\n`);
});
          
          socketInstance.on('speaking_state', (d) => {
            const s = document.getElementById(`speaking-${d.userId}`);
            const t = document.getElementById(`participant-${d.userId}`);
            if (s && t) {
              if (d.speaking) { s.classList.remove('hidden'); t.classList.add('active-speaker'); }
              else { s.classList.add('hidden'); t.classList.remove('active-speaker'); }
            }
          });
          
          socketInstance.on('audio_state_changed', (data) => {
  console.log(`üé§ Received audio_state_changed: userId=${data.userId}, enabled=${data.enabled}`);
  
  const micIndicator = document.getElementById(`mic-${data.userId}`);
  if (micIndicator) {
    if (data.enabled) {
      micIndicator.classList.add('hidden');
    } else {
      micIndicator.classList.remove('hidden');
    }
  }
});

socketInstance.on('video_state_changed', (data) => {
  console.log(`üìπ ========================================`);
  console.log(`üìπ RECEIVED: video_state_changed`);
  console.log(`üìπ ========================================`);
  console.log(`   From userId: ${data.userId}`);
  console.log(`   New state: ${data.enabled ? 'ON' : 'OFF'}`);
  console.log(`   My userId: ${currentUser.userId}`);
  
  // Sanity check - should NEVER receive own state back
  if (data.userId === currentUser.userId) {
    console.error(`‚ùå CRITICAL: Received own video state from server!`);
    console.error(`   This should not happen - server should exclude sender`);
    console.error(`   Ignoring to prevent state desync`);
    console.log(`üìπ ========================================\n`);
    return;
  }
  
  // ‚úÖ Update remote user's video visibility
  console.log(`üìπ Updating remote user ${data.userId} video visibility: ${data.enabled}`);
  
  // ‚úÖ CRITICAL: Check if video element has video tracks
  const remoteVideo = document.getElementById(`video-${data.userId}`);
  if (remoteVideo && remoteVideo.srcObject) {
    const videoTracks = remoteVideo.srcObject.getVideoTracks();
    console.log(`   Remote video element has ${videoTracks.length} video track(s)`);
    
    if (videoTracks.length === 0 && data.enabled) {
      console.warn(`‚ö†Ô∏è Remote wants to show video but no video tracks in stream yet`);
      console.warn(`   Waiting for ontrack event to deliver video track...`);
      // Don't update visibility yet - wait for track to arrive
      console.log(`üìπ ========================================\n`);
      return;
    }
  }
  
  updateVideoVisibility(data.userId, data.enabled, true);
  
  console.log(`‚úÖ Remote video state updated successfully`);
  console.log(`üìπ ========================================\n`);
});


// ‚úÖ FIX K: Handle server state mismatch
socketInstance.on('call_state_mismatch', ({ callId, reason, action }) => {
  console.log(`‚ö†Ô∏è ========================================`);
  console.log(`‚ö†Ô∏è CALL STATE MISMATCH DETECTED`);
  console.log(`‚ö†Ô∏è ========================================`);
  console.log(`   CallID: ${callId}`);
  console.log(`   Reason: ${reason}`);
  console.log(`   Action: ${action}`);
  
  if (action === 'leave') {
    console.log(`üö™ Server instructing client to leave call`);
    
    // Perform cleanup
    if (localStream) {
      localStream.getTracks().forEach(track => {
        track.stop();
        console.log(`üõë Stopped ${track.kind} track`);
      });
    }
    
    peerConnections.forEach((pc, userId) => {
      pc.close();
      console.log(`üóëÔ∏è Closed PC for ${userId}`);
    });
    peerConnections.clear();
    
    audioContexts.forEach((ctx, userId) => {
      ctx.close();
      console.log(`üóëÔ∏è Closed audio context for ${userId}`);
    });
    audioContexts.clear();
    
    // Navigate back to chat
    console.log(`üîô Navigating back to chat due to state mismatch`);
    window.location.href = '/chat.html';
  }
  
  console.log(`‚ö†Ô∏è ========================================\n`);
});

// ‚úÖ FIX K: Handle server-verified state
socketInstance.on('call_state_verified', ({ callId, participants, callType, expiresAt }) => {
  console.log(`‚úÖ ========================================`);
  console.log(`‚úÖ CALL STATE VERIFIED BY SERVER`);
  console.log(`‚úÖ ========================================`);
  console.log(`   CallID: ${callId}`);
  console.log(`   Participants: ${participants.length}`);
  console.log(`   Call type: ${callType}`);
  
  // ‚úÖ FIX J: Rebuild grid from authoritative server data
  const grid = document.getElementById('participantGrid');
  if (!grid) return;
  
  // Get currently rendered user IDs
  const currentTiles = new Set(
    Array.from(grid.querySelectorAll('.video-tile'))
      .map(tile => tile.id.replace('tile-', ''))
  );
  
  const serverUserIds = new Set(participants.map(p => p.userId));
  
  // Remove tiles for users not in server list
  currentTiles.forEach(userId => {
    if (!serverUserIds.has(userId)) {
      console.log(`üóëÔ∏è Removing stale tile for ${userId}`);
      const tile = document.getElementById(`tile-${userId}`);
      if (tile) tile.remove();
      
      renderedParticipants.delete(userId);
      
      // Close stale peer connection
      if (peerConnections.has(userId)) {
        peerConnections.get(userId).close();
        peerConnections.delete(userId);
      }
    }
  });
  
  // Add tiles for users in server list but not rendered
  participants.forEach(participant => {
    if (!currentTiles.has(participant.userId)) {
      console.log(`‚ûï Adding missing tile for ${participant.username}`);
      
      const isSelf = participant.userId === currentUser.userId;
      
      // Create tile (reusing existing createTile logic)
      createTile(
        participant.username,
        participant.userId,
        participant.profilePicture,
        isSelf,
        participant.videoEnabled,
        participant.audioEnabled
      );
      
      renderedParticipants.add(participant.userId);
      
      // Initiate connection if not self and not already connected
      if (!isSelf && !peerConnections.has(participant.userId)) {
        const shouldInitiate = currentUser.userId > participant.userId;
        if (shouldInitiate) {
          console.log(`üîó Initiating connection to ${participant.userId} after state sync`);
          setTimeout(() => createOffer(participant.userId), 1000);
        }
      }
    }
  });
  
  console.log(`‚úÖ Grid synchronized with server state`);
  console.log(`‚úÖ ========================================\n`);
});
          
          socketInstance.on('call_ended', () => { toast('Call ended', 'warning'); leaveCall(); });
          
          const mic = document.getElementById('micBtn');
          const vid = document.getElementById('videoBtn');
          const leave = document.getElementById('leaveCallBtn');
          if (mic) mic.addEventListener('click', toggleMic);
          if (vid) vid.addEventListener('click', toggleVideo);
          if (leave) leave.addEventListener('click', leaveCall, { passive: true });

// Setup back button handler for background call
setupCallBackButtonHandler();

// Setup cleanup handler
setupCallCleanup();


// Setup beforeunload handler for call.html
window.addEventListener('beforeunload', (e) => {
  console.log('üö™ ========================================');
  console.log('üö™ CALL.HTML BEFOREUNLOAD EVENT');
  console.log('üö™ ========================================');
  console.log(`   Reason: Page unload/navigation/close`);
  console.log(`   Has call data: ${!!callData}`);
  console.log(`   Has local stream: ${!!localStream}`);
  console.log(`   Peer connections: ${peerConnections.size}`);
  
  // CRITICAL: Check if we're in an iframe (chat overlay on call.html)
  const isInIframe = window.parent && window.parent !== window;
  console.log(`   Is in iframe: ${isInIframe}`);
  
// CRITICAL: Check if chat overlay is open
const chatOverlay = document.getElementById('chatOverlayContainer');
const isChatOverlayOpen = chatOverlay && !chatOverlay.classList.contains('hidden');
console.log(`   Chat overlay open: ${isChatOverlayOpen}`);

// CRITICAL: Check if we're navigating to chat
const isNavigatingToChat = sessionStorage.getItem('navigatingFromCall') === 'true';
console.log(`   Navigating to chat: ${isNavigatingToChat}`);

// ============================================
// EXCEPTION: NAVIGATING TO CHAT
// ============================================
if (isChatOverlayOpen || isNavigatingToChat) {
  console.log('üîí Preserving call state - user navigating to chat');
  console.log('   DO NOT emit leave_call or stop media');
  
  // Clear navigation flag
  sessionStorage.removeItem('navigatingFromCall');
  
  console.log('üö™ ========================================\n');
  return; // CRITICAL: Exit early without cleanup
}
  
  // ============================================
  // FULL LEAVE SEQUENCE (only for actual page close/reload)
  // ============================================
  console.log('üóëÔ∏è EXECUTING FULL LEAVE SEQUENCE');
  
  try {
    const activeCallStr = localStorage.getItem('activeCall');
    if (activeCallStr) {
      try {
        const callData = JSON.parse(activeCallStr);
        console.log(`üìû Leaving active call: ${callData.callId}`);
        
        if (socketInstance?.connected) {
          socketInstance.emit('leave_call', { callId: callData.callId });
        }
      } catch (e) {
        console.error('‚ùå Error parsing call data:', e);
      }
      
      localStorage.removeItem('activeCall');
      sessionStorage.removeItem('hasBackgroundCall');
      sessionStorage.removeItem('returningFromCall');
      sessionStorage.removeItem('backgroundCallMode');
      sessionStorage.removeItem('returningToBackgroundCall');
      console.log('‚úÖ Call data cleared');
    }
    
    if (localStream) {
      localStream.getTracks().forEach(track => {
        track.stop();
        console.log(`üõë Stopped ${track.kind} track`);
      });
    }
    
    peerConnections.forEach((pc, userId) => {
      pc.close();
      console.log(`üóëÔ∏è Closed PC for ${userId}`);
    });
    peerConnections.clear();
    
    audioContexts.forEach((ctx, userId) => {
      if (ctx.context && ctx.context.state !== 'closed') {
        ctx.context.close();
      }
      console.log(`üóëÔ∏è Closed audio context for ${userId}`);
    });
    audioContexts.clear();
    
    if (socketInstance) {
      socketInstance.disconnect();
      console.log('‚úÖ Socket disconnected');
    }
    
    if (durationInterval) {
      clearInterval(durationInterval);
      console.log('‚úÖ Timer cleared');
    }
    
    console.log('‚úÖ FULL LEAVE SEQUENCE COMPLETE');
    
  } catch (error) {
    console.error('‚ùå Error in beforeunload leave sequence:', error);
    
    try {
      localStorage.removeItem('activeCall');
      if (socketInstance) socketInstance.disconnect();
      if (durationInterval) clearInterval(durationInterval);
    } catch (e) {
      console.error('‚ùå Cleanup failed:', e);
    }
  }
  
  console.log('üö™ ========================================\n');
});

console.log('‚úÖ Call page event handlers initialized');
          
        } catch (e) {
          console.error('‚ùå Init error:', e);
          toast('Failed to initialize call', 'error');
          isInitializing = false;
          setTimeout(() => window.location.href = '/chat.html', 2000);
        }
      }

      console.log('‚úÖ Page loaded - starting initialization');
      initCall();
    })();
    </script>
</body>
</html>
