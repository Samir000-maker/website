<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Active Call - MoodLog</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#33bfcc",
                        "background-light": "#f2f2f3",
                        "background-dark": "#121417",
                        "surface-dark": "#1e2124",
                        "accent-red": "#ef4444",
                    },
                    fontFamily: {
                        "display": ["Manrope", "sans-serif"]
                    },
                    borderRadius: {
                        "DEFAULT": "0.5rem",
                        "lg": "1rem",
                        "xl": "1.5rem",
                        "full": "9999px"
                    },
                },
            },
        }
    </script>
    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }
        
        /* Active speaker highlight - CRITICAL */
        .active-speaker {
            box-shadow: 0 0 0 3px #33bfcc, 0 0 15px rgba(51, 191, 204, 0.4) !important;
            border-color: #33bfcc !important;
        }
        
        body {
            font-family: 'Manrope', sans-serif;
            overscroll-behavior: none;
        }
        
        /* CRITICAL: Square aspect ratio for tiles */
        .video-tile {
            position: relative;
            background: #000;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            border-radius: 1rem;
            transition: all 0.3s ease;
        }
        
        .video-feed {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        video {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .profile-picture-container {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        
        /* Grid layout: 3 columns, auto rows */
        .participant-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        /* Responsive: 2 columns on tablet */
        @media (max-width: 1024px) {
            .participant-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Responsive: 1 column on mobile */
        @media (max-width: 640px) {
            .participant-grid {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }
        }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-900 dark:text-white min-h-screen flex flex-col font-display">
    <!-- Header -->
    <header class="w-full border-b border-slate-200 dark:border-slate-800 px-6 py-4 flex items-center justify-between bg-background-light dark:bg-background-dark z-10">
        <div class="flex items-center gap-4">
            <div class="bg-primary/20 p-2 rounded-lg">
                <span class="material-symbols-outlined text-primary" id="callIcon">videocam</span>
            </div>
            <div>
                <h1 class="text-lg font-bold tracking-tight" id="callTitle">Mindful Space Call</h1>
                <p class="text-xs text-slate-500 dark:text-slate-400" id="callSubtitle">Connecting...</p>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-2 bg-slate-200 dark:bg-surface-dark px-4 py-2 rounded-xl border border-slate-300 dark:border-slate-700">
                <span class="relative flex h-2 w-2">
                    <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-primary opacity-75"></span>
                    <span class="relative inline-flex rounded-full h-2 w-2 bg-primary"></span>
                </span>
                <span class="text-sm font-bold font-mono" id="callDuration">00:00:00</span>
            </div>
            <button class="p-2 hover:bg-slate-200 dark:hover:bg-surface-dark rounded-lg transition-colors">
                <span class="material-symbols-outlined">settings</span>
            </button>
            <button class="p-2 hover:bg-slate-200 dark:hover:bg-surface-dark rounded-lg transition-colors">
                <span class="material-symbols-outlined">group</span>
            </button>
        </div>
    </header>

    <!-- Main Content: Participant Grid -->
    <main class="flex-1 overflow-y-auto p-4 md:p-6">
        <div id="participantGrid" class="participant-grid">
            <!-- Participant tiles will be dynamically generated here -->
        </div>
    </main>

    <!-- Bottom Persistent Control Bar -->
    <footer class="w-full p-6 flex justify-center sticky bottom-0 z-20">
        <div class="bg-white/95 dark:bg-surface-dark/95 backdrop-blur-lg shadow-2xl rounded-2xl border border-slate-200 dark:border-slate-800 p-2.5 flex items-center gap-2">
            <!-- Standard Controls -->
            <div class="flex items-center gap-2 px-2 border-r border-slate-200 dark:border-slate-800">
                <button id="micBtn" class="w-12 h-12 flex items-center justify-center rounded-xl bg-primary text-white hover:brightness-110 transition-all active:scale-95 shadow-lg shadow-primary/20">
                    <span class="material-symbols-outlined">mic</span>
                </button>
                <button id="videoBtn" class="w-12 h-12 flex items-center justify-center rounded-xl bg-slate-200 dark:bg-background-dark text-slate-700 dark:text-white hover:bg-slate-300 dark:hover:bg-slate-800 transition-all">
                    <span class="material-symbols-outlined">videocam_off</span>
                </button>
                <button id="screenShareBtn" class="w-12 h-12 flex items-center justify-center rounded-xl text-slate-500 hover:bg-slate-100 dark:hover:bg-slate-800 transition-all">
                    <span class="material-symbols-outlined">screen_share</span>
                </button>
            </div>
            
            <!-- Mood Control -->
            <div class="flex items-center gap-2 px-2">
                <button id="moodBtn" class="flex items-center gap-2 px-4 h-12 rounded-xl bg-slate-100 dark:bg-background-dark text-slate-700 dark:text-white border border-slate-200 dark:border-slate-700 hover:border-primary transition-all">
                    <span class="text-xl" id="currentMoodEmoji">üòä</span>
                    <span class="text-sm font-bold">Update Mood</span>
                </button>
            </div>
            
            <!-- Leave Button -->
            <div class="pl-2 border-l border-slate-200 dark:border-slate-800">
                <button id="leaveCallBtn" class="flex items-center gap-2 px-6 h-12 rounded-xl bg-accent-red text-white hover:brightness-110 shadow-lg shadow-accent-red/30 transition-all active:scale-95">
                    <span class="material-symbols-outlined font-bold">call_end</span>
                    <span class="font-bold text-sm">Leave Call</span>
                </button>
            </div>
        </div>
    </footer>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };

      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>

    <!-- Socket.IO -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>

    <!-- App -->
    <script src="app.js"></script>

    <script>
    (async () => {
      const MoodApp = window.MoodApp || {};
      const _Auth = MoodApp.Auth;
      const _API = MoodApp.API;
      const _Toast = MoodApp.Toast;

      const toast = (m, t='success') => { 
        if (_Toast && typeof _Toast[t] === 'function') return _Toast[t](m); 
        console[t==='error'?'error':'log'](m); 
      };

      // ============================================
      // ICE CONFIGURATION
      // ============================================
      
      let ICE_SERVERS = null;

      async function fetchIceServers() {
        try {
          console.log('üì° Fetching ICE servers...');
          const response = await _API.get('/api/ice-servers');
          ICE_SERVERS = response.iceServers;
          console.log(`‚úÖ ICE servers loaded: ${ICE_SERVERS.length} groups`);
          return ICE_SERVERS;
        } catch (error) {
          console.error('‚ùå Failed to fetch ICE servers:', error);
          ICE_SERVERS = [
            {
              urls: [
                'stun:stun.cloudflare.com:3478',
                'stun:stun.l.google.com:19302',
                'stun:stun1.l.google.com:19302'
              ]
            }
          ];
          console.warn('‚ö†Ô∏è Using fallback STUN-only configuration');
          return ICE_SERVERS;
        }
      }

      const PEER_CONNECTION_CONFIG = {
        iceCandidatePoolSize: 10,
        iceTransportPolicy: 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      };

      let localStream = null;
      let peerConnections = new Map();
      let audioContexts = new Map();
      let socketInstance = null;
      let callData = null;
      let currentUser = null;
      let isAudioEnabled = true;
      let isVideoEnabled = false;
      let callStartTime = null;
      let durationInterval = null;
      let isInitializing = false;
      let hasJoinedCall = false;
      let pendingIceCandidates = new Map();
      
      const connectionStats = new Map();

      function createProfilePictureElement(pfpUrl, username) {
        const initial = username ? username.charAt(0).toUpperCase() : 'U';
        const container = document.createElement('div');
        container.className = 'w-20 h-20 rounded-full overflow-hidden bg-slate-100 dark:bg-slate-800 border-2 border-primary/30 flex-shrink-0';
        
        if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
          const img = document.createElement('img');
          img.src = pfpUrl;
          img.alt = username;
          img.className = 'h-full w-full object-cover';
          img.onerror = function() {
            this.onerror = null;
            container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-2xl">${initial}</div>`;
          };
          container.appendChild(img);
        } else {
          container.innerHTML = `<div class="h-full w-full bg-primary text-white flex items-center justify-center font-bold text-2xl">${initial}</div>`;
        }
        
        return container;
      }

      function createParticipantTile(user, isSelf = false) {
        const tile = document.createElement('div');
        tile.id = `participant-${user.userId}`;
        tile.className = `video-tile ${isSelf ? 'border-2 border-dashed border-primary/30' : 'border border-white/5'} group hover:border-white/20`;
        
        // Video feed container
        const videoFeed = document.createElement('div');
        videoFeed.className = 'video-feed';
        
        // Video element (hidden by default)
        const videoElement = document.createElement('video');
        videoElement.id = `video-${user.userId}`;
        videoElement.className = 'hidden';
        videoElement.autoplay = true;
        videoElement.playsInline = true;
        if (isSelf) {
          videoElement.muted = true;
        }
        videoFeed.appendChild(videoElement);
        
        // Profile picture container (shown by default)
        const pfpContainer = document.createElement('div');
        pfpContainer.id = `pfp-container-${user.userId}`;
        pfpContainer.className = 'profile-picture-container';
        const pfpElement = createProfilePictureElement(user.pfpUrl, user.username);
        pfpContainer.appendChild(pfpElement);
        videoFeed.appendChild(pfpContainer);
        
        tile.appendChild(videoFeed);
        
        // Bottom label
        const labelContainer = document.createElement('div');
        labelContainer.className = 'absolute bottom-4 left-4 flex items-center gap-2 z-10';
        
        const label = document.createElement('div');
        label.className = `${isSelf ? 'bg-primary/80' : 'bg-black/60'} backdrop-blur-md px-3 py-1.5 rounded-full border ${isSelf ? 'border-primary/20' : 'border-white/10'} flex items-center gap-2`;
        label.innerHTML = `
          <span class="text-white text-sm font-semibold">${isSelf ? 'You' : user.username}</span>
          <span class="text-lg">üòä</span>
        `;
        labelContainer.appendChild(label);
        tile.appendChild(labelContainer);
        
        // Speaking indicator (top right)
        const speakingIndicator = document.createElement('div');
        speakingIndicator.id = `speaking-${user.userId}`;
        speakingIndicator.className = 'absolute top-4 right-4 bg-primary px-2 py-0.5 rounded text-[10px] font-bold text-white uppercase tracking-widest hidden z-10';
        speakingIndicator.textContent = 'Speaking';
        tile.appendChild(speakingIndicator);
        
        // Mic muted indicator (top right, shown when speaking indicator is hidden)
        const micIndicator = document.createElement('div');
        micIndicator.id = `mic-${user.userId}`;
        micIndicator.className = 'absolute top-4 right-4 bg-accent-red p-1.5 rounded-full text-white shadow-lg hidden z-10';
        micIndicator.innerHTML = '<span class="material-symbols-outlined text-[16px] block">mic_off</span>';
        tile.appendChild(micIndicator);
        
        if (isSelf) {
          const selfOverlay = document.createElement('div');
          selfOverlay.className = 'absolute inset-0 bg-primary/5 pointer-events-none';
          tile.appendChild(selfOverlay);
        }
        
        return tile;
      }

      // Audio level detection for speaking indicator
      function setupAudioLevelDetection(userId, stream) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const audioSource = audioContext.createMediaStreamSource(stream);
          const analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          audioSource.connect(analyser);
          
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          const speakingIndicator = document.getElementById(`speaking-${userId}`);
          const participantTile = document.getElementById(`participant-${userId}`);
          
          let isSpeaking = false;
          const SPEAKING_THRESHOLD = 30;
          const SPEAKING_TIMEOUT = 300;
          let lastSpeakingTime = 0;
          
          function detectSpeaking() {
            if (!speakingIndicator || !participantTile) {
              audioContext.close();
              return;
            }
            
            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            
            const now = Date.now();
            if (average > SPEAKING_THRESHOLD) {
              if (!isSpeaking) {
                isSpeaking = true;
                speakingIndicator.classList.remove('hidden');
                participantTile.classList.add('active-speaker');
                console.log(`üó£Ô∏è ${userId} started speaking`);
                
                // Emit speaking state to other users
                if (socketInstance && userId === currentUser.userId) {
                  socketInstance.emit('speaking_state', {
                    callId: callData.callId,
                    speaking: true
                  });
                }
              }
              lastSpeakingTime = now;
            } else if (isSpeaking && now - lastSpeakingTime > SPEAKING_TIMEOUT) {
              isSpeaking = false;
              speakingIndicator.classList.add('hidden');
              participantTile.classList.remove('active-speaker');
              console.log(`ü§ê ${userId} stopped speaking`);
              
              // Emit speaking state to other users
              if (socketInstance && userId === currentUser.userId) {
                socketInstance.emit('speaking_state', {
                  callId: callData.callId,
                  speaking: false
                });
              }
            }
            
            requestAnimationFrame(detectSpeaking);
          }
          
          detectSpeaking();
          audioContexts.set(userId, audioContext);
        } catch (error) {
          console.error(`Error setting up audio detection for ${userId}:`, error);
        }
      }

      async function initializeLocalMedia() {
        try {
          console.log(`üé• Requesting local media (type: ${callData.callType})...`);
          
          const constraints = {
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            },
            video: callData.callType === 'video' ? {
              width: { ideal: 640 },
              height: { ideal: 480 },
              frameRate: { ideal: 30 }
            } : false
          };
          
          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          const tracks = localStream.getTracks();
          console.log(`‚úÖ Local media initialized: ${tracks.map(t => t.kind).join(', ')}`);
          
          isVideoEnabled = callData.callType === 'video';
          isAudioEnabled = true;
          
          // Setup audio level detection for local stream
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            setupAudioLevelDetection(currentUser.userId, localStream);
          }
          
          // Update icon based on call type
          const callIcon = document.getElementById('callIcon');
          if (callIcon) {
            callIcon.textContent = callData.callType === 'video' ? 'videocam' : 'graphic_eq';
          }
          
          if (isVideoEnabled) {
            const localVideo = document.getElementById(`video-${currentUser.userId}`);
            const localPfpContainer = document.getElementById(`pfp-container-${currentUser.userId}`);
            if (localVideo && localStream) {
              localVideo.srcObject = localStream;
              await localVideo.play().catch(e => console.warn('Video play warning:', e));
              localVideo.classList.remove('hidden');
              if (localPfpContainer) localPfpContainer.classList.add('hidden');
              console.log(`üìπ Local video enabled for ${currentUser.username}`);
            }
            
            // Update video button state
            const videoBtn = document.getElementById('videoBtn');
            const videoIcon = videoBtn.querySelector('.material-symbols-outlined');
            videoBtn.classList.remove('bg-slate-200', 'dark:bg-background-dark');
            videoBtn.classList.add('bg-primary', 'text-white');
            videoIcon.textContent = 'videocam';
          }
          
          return localStream;
        } catch (error) {
          console.error('‚ùå Failed to get local media:', error);
          toast('Failed to access camera/microphone', 'error');
          throw error;
        }
      }

      function createPeerConnection(userId) {
        console.log(`üîó Creating peer connection for user: ${userId}`);
        
        const config = {
          ...PEER_CONNECTION_CONFIG,
          iceServers: ICE_SERVERS
        };
        
        const pc = new RTCPeerConnection(config);
        
        connectionStats.set(userId, {
          startTime: Date.now(),
          iceState: 'new',
          connectionState: 'new',
          candidatesReceived: 0,
          candidatesSent: 0,
          selectedCandidate: null
        });
        
        if (localStream) {
          localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
            console.log(`‚ûï Added local ${track.kind} track to connection with ${userId}`);
          });
        }
        
        pc.ontrack = (event) => {
          console.log(`üì• Received remote ${event.track.kind} from ${userId}`);
          const remoteVideo = document.getElementById(`video-${userId}`);
          const remotePfpContainer = document.getElementById(`pfp-container-${userId}`);
          
          if (remoteVideo) {
            if (!remoteVideo.srcObject) {
              remoteVideo.srcObject = new MediaStream();
            }
            remoteVideo.srcObject.addTrack(event.track);
            
            if (event.track.kind === 'video') {
              // Video track received
              remoteVideo.play().catch(e => console.warn('Remote video play warning:', e));
              
              event.track.onunmute = () => {
                console.log(`üìπ Video track unmuted for ${userId} - showing video`);
                remoteVideo.classList.remove('hidden');
                if (remotePfpContainer) remotePfpContainer.classList.add('hidden');
              };
              
              event.track.onmute = () => {
                console.log(`üìπ Video track muted for ${userId} - showing profile picture`);
                remoteVideo.classList.add('hidden');
                if (remotePfpContainer) remotePfpContainer.classList.remove('hidden');
              };
              
              event.track.onended = () => {
                console.log(`üìπ Video track ended for ${userId}`);
                remoteVideo.classList.add('hidden');
                if (remotePfpContainer) remotePfpContainer.classList.remove('hidden');
              };
            } else if (event.track.kind === 'audio') {
              // Audio track received
              remoteVideo.play().catch(e => console.warn('Remote audio play warning:', e));
              
              // Setup audio level detection for remote stream
              const stream = new MediaStream([event.track]);
              setupAudioLevelDetection(userId, stream);
            }
          }
        };
        
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            const stats = connectionStats.get(userId);
            stats.candidatesSent++;
            
            console.log(`üßä ICE candidate for ${userId}: ${event.candidate.type}`);
            
            socketInstance.emit('ice_candidate', {
              callId: callData.callId,
              targetUserId: userId,
              candidate: event.candidate
            });
          } else {
            console.log(`‚úÖ ICE gathering completed for ${userId}`);
          }
        };
        
        pc.oniceconnectionstatechange = () => {
          const state = pc.iceConnectionState;
          console.log(`üßä ICE state with ${userId}: ${state}`);
          connectionStats.get(userId).iceState = state;
          
          if (state === 'failed') {
            console.warn(`‚ö†Ô∏è ICE connection failed with ${userId} - restarting`);
            pc.restartIce();
          }
        };
        
        pc.onconnectionstatechange = () => {
          const state = pc.connectionState;
          const stats = connectionStats.get(userId);
          stats.connectionState = state;
          
          console.log(`üîå Connection state with ${userId}: ${state}`);
          
          const callSubtitle = document.getElementById('callSubtitle');
          
          switch (state) {
            case 'connected':
              if (callSubtitle) {
                const connectedCount = Array.from(connectionStats.values()).filter(s => s.connectionState === 'connected').length + 1;
                callSubtitle.textContent = `${connectedCount} participant${connectedCount > 1 ? 's' : ''} connected`;
              }
              
              pc.getStats().then(stats => {
                stats.forEach(report => {
                  if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                    const localCandidate = stats.get(report.localCandidateId);
                    if (localCandidate) {
                      console.log(`‚úÖ Using ${localCandidate.candidateType} for ${userId}`);
                      connectionStats.get(userId).selectedCandidate = localCandidate.candidateType;
                      
                      socketInstance.emit('connection_state_update', {
                        callId: callData.callId,
                        state: 'connected',
                        candidateType: localCandidate.candidateType
                      });
                    }
                  }
                });
              });
              break;
              
            case 'failed':
              console.error(`‚ùå Connection failed with ${userId}`);
              setTimeout(() => {
                if (pc.connectionState === 'failed') {
                  console.log(`üîÑ Restarting ICE for ${userId}`);
                  pc.restartIce();
                }
              }, 1000);
              
              socketInstance.emit('connection_state_update', {
                callId: callData.callId,
                state: 'failed'
              });
              break;
          }
        };
        
        peerConnections.set(userId, pc);
        return pc;
      }

      async function createOffer(userId) {
        try {
          console.log(`üì§ Creating offer for ${userId}`);
          const pc = createPeerConnection(userId);
          
          const offer = await pc.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true // Always offer to receive video
          });
          
          await pc.setLocalDescription(offer);
          console.log(`‚úÖ Offer created for ${userId}`);
          
          socketInstance.emit('webrtc_offer', {
            callId: callData.callId,
            targetUserId: userId,
            offer: offer
          });
        } catch (error) {
          console.error(`‚ùå Error creating offer for ${userId}:`, error);
        }
      }

      async function handleOffer(fromUserId, offer) {
        try {
          console.log(`üì• Received offer from ${fromUserId}`);
          const pc = createPeerConnection(fromUserId);
          
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          console.log(`‚úÖ Remote description set from ${fromUserId}`);
          
          // Process any pending ICE candidates
          if (pendingIceCandidates.has(fromUserId)) {
            const candidates = pendingIceCandidates.get(fromUserId);
            console.log(`üì¶ Processing ${candidates.length} pending ICE candidates from ${fromUserId}`);
            for (const candidate of candidates) {
              try {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
              } catch (e) {
                console.warn('Failed to add pending ICE candidate:', e);
              }
            }
            pendingIceCandidates.delete(fromUserId);
          }
          
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          console.log(`‚úÖ Answer created for ${fromUserId}`);
          
          socketInstance.emit('webrtc_answer', {
            callId: callData.callId,
            targetUserId: fromUserId,
            answer: answer
          });
        } catch (error) {
          console.error(`‚ùå Error handling offer from ${fromUserId}:`, error);
        }
      }

      async function handleAnswer(fromUserId, answer) {
        try {
          console.log(`üì• Received answer from ${fromUserId}`);
          const pc = peerConnections.get(fromUserId);
          if (pc && pc.signalingState !== 'stable') {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
            console.log(`‚úÖ Remote description (answer) set from ${fromUserId}`);
            
            // Process any pending ICE candidates
            if (pendingIceCandidates.has(fromUserId)) {
              const candidates = pendingIceCandidates.get(fromUserId);
              console.log(`üì¶ Processing ${candidates.length} pending ICE candidates from ${fromUserId}`);
              for (const candidate of candidates) {
                try {
                  await pc.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (e) {
                  console.warn('Failed to add pending ICE candidate:', e);
                }
              }
              pendingIceCandidates.delete(fromUserId);
            }
          } else {
            console.warn(`‚ö†Ô∏è Cannot set remote description for ${fromUserId}: signaling state is ${pc?.signalingState}`);
          }
        } catch (error) {
          console.error(`‚ùå Error handling answer from ${fromUserId}:`, error);
        }
      }

      async function handleIceCandidate(fromUserId, candidate) {
        try {
          const pc = peerConnections.get(fromUserId);
          if (pc && pc.remoteDescription) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            const stats = connectionStats.get(fromUserId);
            stats.candidatesReceived++;
            console.log(`üßä ICE candidate added from ${fromUserId}: ${candidate.type}`);
          } else {
            // Queue ICE candidate if remote description not set yet
            if (!pendingIceCandidates.has(fromUserId)) {
              pendingIceCandidates.set(fromUserId, []);
            }
            pendingIceCandidates.get(fromUserId).push(candidate);
            console.log(`üì¶ Queued ICE candidate from ${fromUserId} (waiting for remote description)`);
          }
        } catch (error) {
          console.error(`‚ùå Error adding ICE candidate from ${fromUserId}:`, error);
        }
      }

      function toggleMicrophone() {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            isAudioEnabled = audioTrack.enabled;
            
            const micBtn = document.getElementById('micBtn');
            const micIcon = micBtn.querySelector('.material-symbols-outlined');
            const micIndicator = document.getElementById(`mic-${currentUser.userId}`);
            
            if (isAudioEnabled) {
              micBtn.classList.add('bg-primary', 'text-white');
              micBtn.classList.remove('bg-accent-red');
              micIcon.textContent = 'mic';
              if (micIndicator) micIndicator.classList.add('hidden');
            } else {
              micBtn.classList.remove('bg-primary', 'text-white');
              micBtn.classList.add('bg-accent-red', 'text-white');
              micIcon.textContent = 'mic_off';
              if (micIndicator) micIndicator.classList.remove('hidden');
            }
            
            console.log(`üé§ Audio ${isAudioEnabled ? 'enabled' : 'disabled'}`);
            socketInstance.emit('audio_state_changed', {
              callId: callData.callId,
              enabled: isAudioEnabled
            });
          }
        }
      }

      async function toggleVideo() {
        if (callData.callType === 'audio') {
          toast('Video not available in audio call', 'warning');
          return;
        }
        
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            isVideoEnabled = videoTrack.enabled;
            
            const videoBtn = document.getElementById('videoBtn');
            const videoIcon = videoBtn.querySelector('.material-symbols-outlined');
            const localVideo = document.getElementById(`video-${currentUser.userId}`);
            const localPfpContainer = document.getElementById(`pfp-container-${currentUser.userId}`);
            
            if (isVideoEnabled) {
              videoBtn.classList.remove('bg-slate-200', 'dark:bg-background-dark', 'text-slate-700', 'dark:text-white');
              videoBtn.classList.add('bg-primary', 'text-white');
              videoIcon.textContent = 'videocam';
              if (localVideo) localVideo.classList.remove('hidden');
              if (localPfpContainer) localPfpContainer.classList.add('hidden');
            } else {
              videoBtn.classList.add('bg-slate-200', 'dark:bg-background-dark', 'text-slate-700', 'dark:text-white');
              videoBtn.classList.remove('bg-primary', 'text-white');
              videoIcon.textContent = 'videocam_off';
              if (localVideo) localVideo.classList.add('hidden');
              if (localPfpContainer) localPfpContainer.classList.remove('hidden');
            }
            
            console.log(`üìπ Video ${isVideoEnabled ? 'enabled' : 'disabled'}`);
            socketInstance.emit('video_state_changed', {
              callId: callData.callId,
              enabled: isVideoEnabled
            });
          }
        }
      }

      function updateCallDuration() {
        if (!callStartTime) return;
        
        const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
        const hours = Math.floor(elapsed / 3600);
        const minutes = Math.floor((elapsed % 3600) / 60);
        const seconds = elapsed % 60;
        
        const durationEl = document.getElementById('callDuration');
        if (durationEl) {
          durationEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
      }

      function leaveCall() {
        if (isInitializing) return;
        
        console.log('üö™ Leaving call...');
        isInitializing = true;
        
        // Close all audio contexts
        audioContexts.forEach((context, userId) => {
          context.close();
        });
        audioContexts.clear();
        
        if (localStream) {
          localStream.getTracks().forEach(track => {
            track.stop();
            console.log(`‚èπÔ∏è Stopped ${track.kind} track`);
          });
        }
        
        peerConnections.forEach((pc, userId) => {
          console.log(`üîå Closing connection to ${userId}`);
          pc.close();
        });
        peerConnections.clear();
        
        if (socketInstance && socketInstance.connected) {
          socketInstance.emit('leave_call', {
            callId: callData.callId
          });
        }
        
        if (durationInterval) clearInterval(durationInterval);
        
        localStorage.removeItem('activeCall');
        
        setTimeout(() => {
          window.location.href = '/chat.html';
        }, 500);
      }

      async function initializeCall() {
        if (isInitializing) return;
        
        isInitializing = true;
        console.log('=== Initializing Call ===');
        
        try {
          await _Auth.requireAuth();
          await fetchIceServers();
          
          const callDataStr = localStorage.getItem('activeCall');
          if (!callDataStr) {
            toast('No active call found', 'error');
            setTimeout(() => window.location.href = '/chat.html', 1500);
            return;
          }
          
          callData = JSON.parse(callDataStr);
          console.log(`üìû Call data loaded: ${callData.callId} (${callData.callType})`);
          
          const firebaseUser = firebase.auth().currentUser;
          if (!firebaseUser) {
            window.location.href = '/login.html';
            return;
          }
          
          const userData = await _API.get('/api/users/me');
          currentUser = {
            userId: userData._id,
            username: userData.username,
            pfpUrl: userData.pfpUrl
          };
          
          console.log(`üë§ Current user: ${currentUser.username}`);
          
          const callTitle = document.getElementById('callTitle');
          if (callTitle) callTitle.textContent = `${callData.callType === 'video' ? 'Video' : 'Audio'} Call`;
          
          const idToken = await firebaseUser.getIdToken();
          const socketUrl = window.location.origin;
          socketInstance = io(socketUrl, {
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            auth: { token: idToken }
          });
          
          socketInstance.on('connect', () => {
            console.log(`üîå Socket connected: ${socketInstance.id}`);
            socketInstance.emit('authenticate', {
              token: idToken,
              userId: currentUser.userId
            });
          });
          
          socketInstance.on('authenticated', async () => {
            console.log('‚úÖ Socket authenticated');
            
            if (!hasJoinedCall) {
              hasJoinedCall = true;
              socketInstance.emit('join_call', {
                callId: callData.callId
              });
            }
          });
          
          socketInstance.on('call_joined', async (data) => {
            console.log(`‚úÖ Call joined: ${data.participants.length} participants`);
            
            const callSubtitle = document.getElementById('callSubtitle');
            if (callSubtitle) callSubtitle.textContent = `${data.participants.length} participant${data.participants.length > 1 ? 's' : ''}`;
            
            await initializeLocalMedia();
            
            const participantGrid = document.getElementById('participantGrid');
            if (participantGrid) {
              participantGrid.innerHTML = '';
              
              data.participants.forEach(participant => {
                const isSelf = participant.userId === currentUser.userId;
                const tile = createParticipantTile(participant, isSelf);
                participantGrid.appendChild(tile);
                
                if (!isSelf) {
                  setTimeout(() => createOffer(participant.userId), 500);
                }
              });
            }
            
            callStartTime = Date.now();
            durationInterval = setInterval(updateCallDuration, 1000);
            
            isInitializing = false;
            console.log('=== Call Initialization Complete ===');
          });
          
          socketInstance.on('user_joined_call', (data) => {
            console.log(`üëã User joined: ${data.user.username}`);
            
            const participantGrid = document.getElementById('participantGrid');
            if (participantGrid && !document.getElementById(`participant-${data.user.userId}`)) {
              const tile = createParticipantTile(data.user, false);
              participantGrid.appendChild(tile);
              setTimeout(() => createOffer(data.user.userId), 500);
            }
          });
          
          socketInstance.on('user_left_call', (data) => {
            console.log(`üëã User left: ${data.userId}`);
            
            const tile = document.getElementById(`participant-${data.userId}`);
            if (tile) {
              tile.remove();
            }
            
            const pc = peerConnections.get(data.userId);
            if (pc) {
              pc.close();
              peerConnections.delete(data.userId);
            }
            
            // Close audio context
            const audioContext = audioContexts.get(data.userId);
            if (audioContext) {
              audioContext.close();
              audioContexts.delete(data.userId);
            }
            
            connectionStats.delete(data.userId);
            pendingIceCandidates.delete(data.userId);
          });
          
          socketInstance.on('webrtc_offer', (data) => handleOffer(data.fromUserId, data.offer));
          socketInstance.on('webrtc_answer', (data) => handleAnswer(data.fromUserId, data.answer));
          socketInstance.on('ice_candidate', (data) => handleIceCandidate(data.fromUserId, data.candidate));
          
          // Handle speaking state from other users
          socketInstance.on('speaking_state', (data) => {
            const speakingIndicator = document.getElementById(`speaking-${data.userId}`);
            const participantTile = document.getElementById(`participant-${data.userId}`);
            
            if (speakingIndicator && participantTile) {
              if (data.speaking) {
                speakingIndicator.classList.remove('hidden');
                participantTile.classList.add('active-speaker');
              } else {
                speakingIndicator.classList.add('hidden');
                participantTile.classList.remove('active-speaker');
              }
            }
          });
          
          socketInstance.on('audio_state_changed', (data) => {
            console.log(`üé§ Audio state changed for ${data.userId}: ${data.enabled}`);
            const micIndicator = document.getElementById(`mic-${data.userId}`);
            if (micIndicator) {
              data.enabled ? micIndicator.classList.add('hidden') : micIndicator.classList.remove('hidden');
            }
          });
          
          socketInstance.on('video_state_changed', (data) => {
            console.log(`üìπ Video state changed for ${data.userId}: ${data.enabled}`);
            const video = document.getElementById(`video-${data.userId}`);
            const pfpContainer = document.getElementById(`pfp-container-${data.userId}`);
            if (video && pfpContainer) {
              if (data.enabled) {
                // User enabled video - but wait for actual video track
                console.log(`üìπ Waiting for video track from ${data.userId}`);
              } else {
                // User disabled video - show profile picture
                video.classList.add('hidden');
                pfpContainer.classList.remove('hidden');
              }
            }
          });
          
          socketInstance.on('call_ended', () => {
            console.log('üìµ Call ended');
            toast('Call ended', 'warning');
            leaveCall();
          });
          
          const micBtn = document.getElementById('micBtn');
          const videoBtn = document.getElementById('videoBtn');
          const leaveCallBtn = document.getElementById('leaveCallBtn');
          
          if (micBtn) micBtn.addEventListener('click', toggleMicrophone);
          if (videoBtn) videoBtn.addEventListener('click', toggleVideo);
          if (leaveCallBtn) leaveCallBtn.addEventListener('click', leaveCall);
          
          window.addEventListener('beforeunload', () => leaveCall());
          
        } catch (error) {
          console.error('‚ùå Call initialization error:', error);
          toast('Failed to initialize call', 'error');
          isInitializing = false;
          setTimeout(() => window.location.href = '/chat.html', 2000);
        }
      }

      console.log('‚úÖ Arrived at call page');
      initializeCall();
      
    })();
    </script>
</body>
</html>
