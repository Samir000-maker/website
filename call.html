
<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Active Call - MoodLog</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#33bfcc",
                        "background-light": "#f2f2f3",
                        "background-dark": "#121417",
                        "surface-dark": "#1e2124",
                        "accent-red": "#ef4444",
                    },
                    fontFamily: {
                        "display": ["Manrope", "sans-serif"]
                    }
                },
            },
        }
    </script>
    <style>
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }
        
        .active-speaker {
            box-shadow: 0 0 0 3px #33bfcc, 0 0 15px rgba(51, 191, 204, 0.4) !important;
            border-color: #33bfcc !important;
        }
        
        body {
            font-family: 'Manrope', sans-serif;
            overscroll-behavior: none;
        }
        
        .video-tile {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            max-width: 400px;
            background: #000;
            overflow: hidden;
            border-radius: 1rem;
        }
        
        .video-container {
            position: absolute;
            inset: 0;
        }
        
        video {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .pfp-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        
        .participant-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 400px));
            justify-content: center;
            gap: 1rem;
            width: 100%;
            padding: 1rem;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        @media (min-width: 1024px) {
            .participant-grid {
                grid-template-columns: repeat(auto-fit, minmax(300px, 400px));
            }
        }
        
        @media (max-width: 640px) {
            .participant-grid {
                grid-template-columns: 1fr;
                padding: 0.75rem;
            }
            .video-tile {
                max-width: 100%;
            }
        }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-900 dark:text-white min-h-screen flex flex-col font-display">
    <header class="w-full border-b border-slate-200 dark:border-slate-800 px-4 sm:px-6 py-3 sm:py-4 flex items-center justify-between bg-background-light dark:bg-background-dark z-10">
        <div class="flex items-center gap-3 sm:gap-4 flex-1 min-w-0">
            <div class="bg-primary/20 p-1.5 sm:p-2 rounded-lg flex-shrink-0">
                <span class="material-symbols-outlined text-primary text-lg sm:text-2xl" id="callIcon">videocam</span>
            </div>
            <div class="min-w-0">
                <h1 class="text-sm sm:text-lg font-bold tracking-tight truncate" id="callTitle">Video Call</h1>
                <p class="text-[10px] sm:text-xs text-slate-500 dark:text-slate-400 truncate" id="callSubtitle">Connecting...</p>
            </div>
        </div>
        <div class="flex items-center gap-2 sm:gap-3 flex-shrink-0">
            <div class="flex items-center gap-1.5 sm:gap-2 bg-slate-200 dark:bg-surface-dark px-2 sm:px-4 py-1.5 sm:py-2 rounded-lg sm:rounded-xl border border-slate-300 dark:border-slate-700">
                <span class="relative flex h-2 w-2">
                    <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-primary opacity-75"></span>
                    <span class="relative inline-flex rounded-full h-2 w-2 bg-primary"></span>
                </span>
                <span class="text-[10px] sm:text-sm font-bold font-mono" id="callDuration">00:00:00</span>
            </div>
        </div>
    </header>

    <main class="flex-1 overflow-y-auto">
        <div id="participantGrid" class="participant-grid"></div>
    </main>

    <footer class="w-full px-3 sm:px-6 py-3 sm:py-4 flex justify-center sticky bottom-0 z-20">
        <div class="bg-white/95 dark:bg-surface-dark/95 backdrop-blur-lg shadow-2xl rounded-xl sm:rounded-2xl border border-slate-200 dark:border-slate-800 p-2 sm:p-2.5 flex items-center gap-1 sm:gap-2">
            <div class="flex items-center gap-1 sm:gap-2 px-1 sm:px-2 border-r border-slate-200 dark:border-slate-800">
                <button id="micBtn" class="w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-primary text-white hover:brightness-110 transition-all active:scale-95">
                    <span class="material-symbols-outlined text-lg sm:text-2xl">mic</span>
                </button>
                <button id="videoBtn" class="w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-lg sm:rounded-xl bg-slate-200 dark:bg-background-dark text-slate-700 dark:text-white hover:bg-slate-300 dark:hover:bg-slate-800 transition-all">
                    <span class="material-symbols-outlined text-lg sm:text-2xl">videocam_off</span>
                </button>
            </div>
            
            <div class="hidden sm:flex items-center gap-2 px-2">
                <button id="moodBtn" class="flex items-center gap-1.5 sm:gap-2 px-3 sm:px-4 h-10 sm:h-12 rounded-lg sm:rounded-xl bg-slate-100 dark:bg-background-dark text-slate-700 dark:text-white border border-slate-200 dark:border-slate-700 hover:border-primary transition-all text-xs sm:text-sm">
                    <span class="text-base sm:text-xl">üòä</span>
                    <span class="font-bold hidden md:inline">Update Mood</span>
                </button>
            </div>
            
            <div class="pl-1 sm:pl-2 border-l border-slate-200 dark:border-slate-800">
                <button id="leaveCallBtn" class="flex items-center gap-1.5 sm:gap-2 px-4 sm:px-6 h-10 sm:h-12 rounded-lg sm:rounded-xl bg-accent-red text-white hover:brightness-110 transition-all active:scale-95">
                    <span class="material-symbols-outlined font-bold text-lg sm:text-2xl">call_end</span>
                    <span class="font-bold text-xs sm:text-sm">Leave</span>
                </button>
            </div>
        </div>
    </footer>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyA0aEEUk7uPGk2vK69HjhW7Ug0GCWOksLU",
        authDomain: "projectt3-8c55e.firebaseapp.com",
        projectId: "projectt3-8c55e",
        storageBucket: "projectt3-8c55e.firebasestorage.app",
        messagingSenderId: "64611387728",
        appId: "1:64611387728:web:2e53a18151ab3de1b60455",
        measurementId: "G-0Z91D0Q6EE"
      };
      if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
      firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    </script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="app.js"></script>



    <script>
    (async () => {
      const MoodApp = window.MoodApp || {};
      const _Auth = MoodApp.Auth;
      const _API = MoodApp.API;
      const _Toast = MoodApp.Toast;
      const toast = (m, t='success') => { 
        if (_Toast && typeof _Toast[t] === 'function') return _Toast[t](m); 
        console[t==='error'?'error':'log'](m); 
      };



let videoStateChangeTimeout = null;
let isTogglingVideo = false;
let isJoiningCall = false;

let negotiationMutex = new Map(); // userId -> Promise to prevent duplicate offer handling
let makingOffer = new Map();
        
      let ICE_SERVERS = null;
      async function fetchIceServers() {
  try {
    const response = await _API.get('/api/ice-servers');
    
    // CRITICAL: Ensure STUN servers come FIRST for proper prioritization
    const stunServers = response.iceServers.filter(server => 
      server.urls.some(url => url.startsWith('stun:'))
    );
    
    const turnServers = response.iceServers.filter(server => 
      server.urls.some(url => url.startsWith('turn:') || url.startsWith('turns:'))
    );
    
    // Put STUN first, TURN second - ICE will prioritize in this order
    ICE_SERVERS = [...stunServers, ...turnServers];
    
    console.log(`‚úÖ ICE servers loaded in priority order:`);
    console.log(`   - ${stunServers.length} STUN server group(s)`);
    console.log(`   - ${turnServers.length} TURN server group(s)`);
    
    return ICE_SERVERS;
  } catch (error) {
    console.error('‚ùå ICE servers failed:', error);
    ICE_SERVERS = [{ urls: ['stun:stun.cloudflare.com:3478', 'stun:stun.l.google.com:19302'] }];
    return ICE_SERVERS;
  }
}

      const PEER_CONNECTION_CONFIG = { 
  iceCandidatePoolSize: 10,
  iceTransportPolicy: 'all', // MUST be 'all' to try STUN first, NOT 'relay'
  bundlePolicy: 'max-bundle', 
  rtcpMuxPolicy: 'require',
  // Enable ICE restart for failed connections
  iceRestart: false
};
      let localStream = null, peerConnections = new Map(), audioContexts = new Map(), socketInstance = null;
      let callData = null, currentUser = null, isAudioEnabled = true, isVideoEnabled = false;
      let durationInterval = null, isInitializing = false, hasJoinedCall = false;
      let pendingIceCandidates = new Map(), connectionStats = new Map();
      let renderedParticipants = new Set(); // CRITICAL FIX: Track rendered participants

      function createProfilePicture(pfpUrl, username) {
        const initial = username ? username.charAt(0).toUpperCase() : 'U';
        const div = document.createElement('div');
        div.className = 'w-16 h-16 sm:w-20 sm:h-20 rounded-full overflow-hidden bg-slate-100 dark:bg-slate-800 border-2 border-primary/30';
        if (pfpUrl && pfpUrl !== 'https://ui-avatars.com/api/?name=User&background=367d7d&color=ffffff&size=200') {
          const img = document.createElement('img');
          img.src = pfpUrl;
          img.alt = username;
          img.className = 'w-full h-full object-cover';
          img.onerror = () => { div.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-xl sm:text-2xl">${initial}</div>`; };
          div.appendChild(img);
        } else {
          div.innerHTML = `<div class="w-full h-full bg-primary text-white flex items-center justify-center font-bold text-xl sm:text-2xl">${initial}</div>`;
        }
        return div;
      }
      
      
      function updateVideoVisibility(userId, enabled, trackReady = true) {
  const vid = document.getElementById(`video-${userId}`);
  const pfp = document.getElementById(`pfp-${userId}`);
  
  if (!vid || !pfp) {
    console.warn(`‚ö†Ô∏è Video elements not found for ${userId}`);
    return;
  }
  
  const shouldShowVideo = enabled && trackReady && vid.srcObject && vid.srcObject.getVideoTracks().length > 0;
  
  console.log(`üìπ updateVideoVisibility(${userId}): enabled=${enabled}, trackReady=${trackReady}, shouldShow=${shouldShowVideo}`);
  
  if (shouldShowVideo) {
    vid.classList.remove('hidden');
    pfp.classList.add('hidden');
  } else {
    vid.classList.add('hidden');
    pfp.classList.remove('hidden');
  }
}
      

      function createParticipantTile(user, isSelf = false) {
  console.log(`üé® Creating tile for ${user.username} (userId: ${user.userId}, isSelf: ${isSelf})`);
  
  // CRITICAL: Check if tile already exists in DOM
  const existingTile = document.getElementById(`participant-${user.userId}`);
  if (existingTile) {
    console.warn(`‚ö†Ô∏è Tile for ${user.userId} already exists in DOM! Removing old tile.`);
    existingTile.remove();
    renderedParticipants.delete(user.userId);
  }
  
  // Double-check tracking set
  if (renderedParticipants.has(user.userId)) {
    console.warn(`‚ö†Ô∏è Tile for ${user.userId} in tracking set but not in DOM! Clearing.`);
    renderedParticipants.delete(user.userId);
  }
  
  const tile = document.createElement('div');
  tile.id = `participant-${user.userId}`;
  tile.className = `video-tile ${isSelf ? 'border-2 border-dashed border-primary/30' : 'border border-white/5'}`;
  
  const videoContainer = document.createElement('div');
  videoContainer.className = 'video-container';
  
  const video = document.createElement('video');
  video.id = `video-${user.userId}`;
  video.className = 'hidden';
  video.autoplay = true;
  video.playsInline = true;
  video.setAttribute('playsinline', '');
  video.setAttribute('webkit-playsinline', '');
  
  if (isSelf) {
    video.muted = true;
    video.volume = 0;
    console.log(`üîá Self video will be muted (userId: ${user.userId})`);
  } else {
    video.muted = false;
    video.volume = 1.0;
    console.log(`üîä Remote video will NOT be muted (userId: ${user.userId})`);
  }
  
  videoContainer.appendChild(video);
  
  const pfpOverlay = document.createElement('div');
  pfpOverlay.id = `pfp-${user.userId}`;
  pfpOverlay.className = 'pfp-overlay';
  pfpOverlay.appendChild(createProfilePicture(user.pfpUrl, user.username));
  videoContainer.appendChild(pfpOverlay);
  
  tile.appendChild(videoContainer);
  
  const label = document.createElement('div');
  label.className = 'absolute bottom-3 sm:bottom-4 left-3 sm:left-4 z-10';
  label.innerHTML = `<div class="${isSelf ? 'bg-primary/80' : 'bg-black/60'} backdrop-blur-md px-2 sm:px-3 py-1 sm:py-1.5 rounded-full border ${isSelf ? 'border-primary/20' : 'border-white/10'} flex items-center gap-1.5 sm:gap-2">
    <span class="text-white text-xs sm:text-sm font-semibold">${isSelf ? 'You' : user.username}</span>
    <span class="text-base sm:text-lg">üòä</span>
  </div>`;
  tile.appendChild(label);
  
  const speaking = document.createElement('div');
  speaking.id = `speaking-${user.userId}`;
  speaking.className = 'absolute top-3 sm:top-4 right-3 sm:right-4 bg-primary px-1.5 sm:px-2 py-0.5 rounded text-[9px] sm:text-[10px] font-bold text-white uppercase hidden z-10';
  speaking.textContent = 'SPEAKING';
  tile.appendChild(speaking);
  
  const micOff = document.createElement('div');
  micOff.id = `mic-${user.userId}`;
  micOff.className = 'absolute top-3 sm:top-4 right-3 sm:right-4 bg-accent-red p-1 sm:p-1.5 rounded-full text-white shadow-lg hidden z-10';
  micOff.innerHTML = '<span class="material-symbols-outlined text-[14px] sm:text-[16px]">mic_off</span>';
  tile.appendChild(micOff);
  
  if (isSelf) {
    const overlay = document.createElement('div');
    overlay.className = 'absolute inset-0 bg-primary/5 pointer-events-none';
    tile.appendChild(overlay);
  }
  
  renderedParticipants.add(user.userId);
  console.log(`‚úÖ Tile created for ${user.username} (${user.userId})`);
  console.log(`üìä Rendered participants now:`, Array.from(renderedParticipants));
  return tile;
}


// Add after createPC function to monitor connection quality
function monitorConnectionQuality(userId, pc) {
  const monitorInterval = setInterval(async () => {
    if (!pc || pc.connectionState === 'closed') {
      clearInterval(monitorInterval);
      return;
    }
    
    try {
      const stats = await pc.getStats();
      let connectionInfo = {
        candidateType: 'unknown',
        bytesReceived: 0,
        bytesSent: 0,
        packetsLost: 0
      };
      
      stats.forEach(report => {
        if (report.type === 'candidate-pair' && report.state === 'succeeded') {
          const localCandidate = stats.get(report.localCandidateId);
          if (localCandidate) {
            connectionInfo.candidateType = localCandidate.candidateType;
          }
        }
        
        if (report.type === 'inbound-rtp' && report.kind === 'audio') {
          connectionInfo.bytesReceived = report.bytesReceived || 0;
          connectionInfo.packetsLost = report.packetsLost || 0;
        }
        
        if (report.type === 'outbound-rtp' && report.kind === 'audio') {
          connectionInfo.bytesSent = report.bytesSent || 0;
        }
      });
      
      // Only log significant changes or issues
      if (connectionInfo.packetsLost > 10) {
        console.warn(`‚ö†Ô∏è [Quality] Packet loss detected for ${userId}: ${connectionInfo.packetsLost} packets`);
      }
      
      // Update connection stats
      const connStats = connectionStats.get(userId);
      if (connStats) {
        connStats.lastQualityCheck = Date.now();
        connStats.connectionType = connectionInfo.candidateType;
      }
      
    } catch (e) {
      console.warn(`‚ö†Ô∏è Failed to get stats for ${userId}:`, e.message);
    }
  }, 5000); // Check every 5 seconds
  
  // Store interval for cleanup
  if (!connectionStats.has(userId)) {
    connectionStats.set(userId, {});
  }
  connectionStats.get(userId).monitorInterval = monitorInterval;
}

      function setupAudioDetection(userId, stream) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          const analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          source.connect(analyser);
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          let isSpeaking = false, lastSpeakTime = 0;
          
          function detect() {
            const speaking = document.getElementById(`speaking-${userId}`);
            const tile = document.getElementById(`participant-${userId}`);
            if (!speaking || !tile) { audioContext.close(); return; }
            
            analyser.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a,b)=>a+b) / dataArray.length;
            const now = Date.now();
            
            if (avg > 30) {
              if (!isSpeaking) {
                isSpeaking = true;
                speaking.classList.remove('hidden');
                tile.classList.add('active-speaker');
                if (socketInstance && userId === currentUser.userId) {
                  socketInstance.emit('speaking_state', { callId: callData.callId, speaking: true });
                }
              }
              lastSpeakTime = now;
            } else if (isSpeaking && now - lastSpeakTime > 300) {
              isSpeaking = false;
              speaking.classList.add('hidden');
              tile.classList.remove('active-speaker');
              if (socketInstance && userId === currentUser.userId) {
                socketInstance.emit('speaking_state', { callId: callData.callId, speaking: false });
              }
            }
            requestAnimationFrame(detect);
          }
          detect();
          audioContexts.set(userId, audioContext);
        } catch (e) { console.error('Audio detection error:', e); }
      }

      // Replace initLocalMedia function
async function initLocalMedia() {
  const MAX_RETRIES = 3;
  let attempt = 0;
  
  while (attempt < MAX_RETRIES) {
    try {
      attempt++;
      console.log(`üé• [Attempt ${attempt}/${MAX_RETRIES}] Requesting media (${callData.callType})...`);
      
      const constraints = {
        audio: { 
          echoCancellation: true, 
          noiseSuppression: true, 
          autoGainControl: true 
        },
        video: callData.callType === 'video' ? { 
          width: {ideal:640}, 
          height: {ideal:480},
          facingMode: 'user'
        } : false
      };
      
      let hasVideo = false;
      let hasAudio = false;
      
      try {
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        hasVideo = localStream.getVideoTracks().length > 0;
        hasAudio = localStream.getAudioTracks().length > 0;
        console.log(`‚úÖ [Attempt ${attempt}] SUCCESS: video=${hasVideo}, audio=${hasAudio}`);
        break; // Success, exit retry loop
      } catch (videoError) {
        console.warn(`‚ö†Ô∏è [Attempt ${attempt}] Video failed: ${videoError.name}`);
        
        // Try audio-only
        try {
          const audioOnlyConstraints = {
            audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
            video: false
          };
          localStream = await navigator.mediaDevices.getUserMedia(audioOnlyConstraints);
          hasAudio = localStream.getAudioTracks().length > 0;
          console.log(`‚úÖ [Attempt ${attempt}] Audio-only SUCCESS: audio=${hasAudio}`);
          
          if (attempt === 1) {
            toast('Camera not available, using audio only', 'warning');
          }
          break; // Success, exit retry loop
        } catch (audioError) {
          console.error(`‚ùå [Attempt ${attempt}] Both failed: ${audioError.name}`);
          
          if (attempt === MAX_RETRIES) {
            localStream = new MediaStream();
            toast('No media devices available. You can still join the call.', 'error');
          } else {
            await new Promise(resolve => setTimeout(resolve, 500)); // Wait before retry
            continue;
          }
        }
      }
      
      // Set states based on actual media acquired
      isVideoEnabled = hasVideo;
      isAudioEnabled = hasAudio;
      
      console.log(`üìä Final media state: video=${isVideoEnabled}, audio=${isAudioEnabled}`);
      console.log(`üìä LocalStream tracks: ${localStream.getTracks().map(t => `${t.kind}(${t.enabled})`).join(', ')}`);
      
      // Setup audio detection if we have audio
      if (hasAudio) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          setupAudioDetection(currentUser.userId, localStream);
          console.log(`üé§ Audio detection setup for ${currentUser.username}`);
        }
      }
      
      // Update call icon
      const callIcon = document.getElementById('callIcon');
      if (callIcon) callIcon.textContent = isVideoEnabled ? 'videocam' : 'graphic_eq';
      
      console.log(`‚úÖ initLocalMedia() complete - stream ready`);
      return localStream;
      
    } catch (e) {
      console.error(`‚ùå [Attempt ${attempt}] Critical error:`, e);
      if (attempt === MAX_RETRIES) {
        localStream = new MediaStream();
        isVideoEnabled = false;
        isAudioEnabled = false;
        toast('Unable to access media devices.', 'error');
        return localStream;
      }
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  return localStream;
}


// Replace setupLocalVideo function
async function setupLocalVideo() {
  const waitForElement = (id, maxWait = 5000) => {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      const checkElement = () => {
        const element = document.getElementById(id);
        if (element) {
          resolve(element);
        } else if (Date.now() - startTime > maxWait) {
          reject(new Error(`Element ${id} not found after ${maxWait}ms`));
        } else {
          requestAnimationFrame(checkElement);
        }
      };
      checkElement();
    });
  };

  try {
    console.log(`üîß Waiting for local video elements for ${currentUser.username}...`);
    
    // CRITICAL FIX: Check if tile exists first
    const localTile = document.getElementById(`participant-${currentUser.userId}`);
    if (!localTile) {
      console.warn(`‚ö†Ô∏è No tile for ${currentUser.username} yet - will be created when user_joined_call fires`);
      return; // Exit gracefully - will be called again when tile is created
    }
    
    const localVid = await waitForElement(`video-${currentUser.userId}`);
    const localPfp = await waitForElement(`pfp-${currentUser.userId}`);
    
    console.log(`‚úÖ Found video elements for ${currentUser.username}`);
    console.log(`   Video element: ${!!localVid}, PFP element: ${!!localPfp}`);
    console.log(`   LocalStream: ${!!localStream}, Video tracks: ${localStream.getVideoTracks().length}`);
    
    if (!localStream) {
      console.error(`‚ùå No localStream available`);
      return;
    }
    
    localVid.srcObject = localStream;
    localVid.muted = true;
    localVid.volume = 0;
    localVid.style.transform = 'scaleX(1)';
    console.log(`‚úÖ Local stream attached to video element`);
    
    if (isVideoEnabled && localStream.getVideoTracks().length > 0) {
      console.log(`üìπ Waiting for local video to be ready...`);
      
      await new Promise((resolve) => {
        const checkReady = () => {
          if (localVid.readyState >= 2) {
            console.log(`üìπ Local video ready: ${localVid.videoWidth}x${localVid.videoHeight}`);
            resolve();
          } else {
            localVid.addEventListener('loadedmetadata', () => {
              console.log(`üìπ Metadata loaded: ${localVid.videoWidth}x${localVid.videoHeight}`);
              resolve();
            }, { once: true });
          }
        };
        checkReady();
      });
      
      try {
        await localVid.play();
        console.log(`‚ñ∂Ô∏è Local video playback started`);
        updateVideoVisibility(currentUser.userId, true, true);
      } catch (e) {
        console.error('‚ùå Local video play failed:', e);
        updateVideoVisibility(currentUser.userId, false, false);
      }
    } else {
      console.log(`üìπ Video disabled or no video track for ${currentUser.username}`);
      updateVideoVisibility(currentUser.userId, false, false);
    }
    
    updateVideoButton();
    updateMicButton();
    
    console.log(`‚úÖ setupLocalVideo() complete for ${currentUser.username}`);
    
  } catch (error) {
    console.error(`‚ùå setupLocalVideo() failed:`, error);
    console.log(`‚ö†Ô∏è Will retry when tile becomes available`);
  }
}



function updateVideoButton() {
  const btn = document.getElementById('videoBtn');
  const icon = btn?.querySelector('.material-symbols-outlined');
  
  if (!btn || !icon) return;
  
  if (isVideoEnabled) {
    btn.classList.add('bg-primary', 'text-white');
    btn.classList.remove('bg-slate-200', 'dark:bg-background-dark');
    icon.textContent = 'videocam';
  } else {
    btn.classList.remove('bg-primary', 'text-white');
    btn.classList.add('bg-slate-200', 'dark:bg-background-dark');
    icon.textContent = 'videocam_off';
  }
  console.log(`‚úÖ Video button updated: ${isVideoEnabled ? 'ON' : 'OFF'}`);
}




function updateMicButton() {
  const micBtn = document.getElementById('micBtn');
  const micIcon = micBtn?.querySelector('.material-symbols-outlined');
  
  if (!micBtn || !micIcon) return;
  
  if (isAudioEnabled) {
    micBtn.classList.add('bg-primary', 'text-white');
    micBtn.classList.remove('bg-accent-red');
    micIcon.textContent = 'mic';
  } else {
    micBtn.classList.remove('bg-primary');
    micBtn.classList.add('bg-accent-red', 'text-white');
    micIcon.textContent = 'mic_off';
  }
  console.log(`‚úÖ Mic button updated: ${isAudioEnabled ? 'ON' : 'OFF'}`);
}



function createPC(userId) {
  console.log(`üîó Creating PC for ${userId}`);
  
  // CRITICAL FIX: Check for existing PC and close it
  const existingPC = peerConnections.get(userId);
  if (existingPC) {
    console.warn(`‚ö†Ô∏è PC already exists for ${userId}, closing old one`);
    existingPC.close();
    peerConnections.delete(userId);
  }
  
  if (!localStream) {
    console.error(`‚ùå CRITICAL: localStream is null when creating PC for ${userId}!`);
    throw new Error('Cannot create PeerConnection without localStream');
  }
  
  console.log(`‚úÖ localStream validated: ${localStream.getTracks().length} tracks`);
  
  const pc = new RTCPeerConnection({ 
    ...PEER_CONNECTION_CONFIG, 
    iceServers: ICE_SERVERS 
  });
  
  connectionStats.set(userId, { 
    startTime: Date.now(), 
    iceState: 'new', 
    connectionState: 'new', 
    candidatesReceived: 0, 
    candidatesSent: 0,
    iceRestartCount: 0,
    lastIceCandidateTime: 0
  });
  
  const tracks = localStream.getTracks();
  console.log(`üìä Adding ${tracks.length} tracks to PC for ${userId}:`);
  
  tracks.forEach(track => {
    pc.addTrack(track, localStream);
    console.log(`   ‚ûï ${track.kind} track (id=${track.id.substring(0, 8)}..., enabled=${track.enabled})`);
  });
  
  // CRITICAL: Add ontrack handler to receive remote media
  pc.ontrack = (event) => {
    console.log(`üéµ [TRACK] Received ${event.track.kind} track from ${userId}`);
    console.log(`   Track ID: ${event.track.id.substring(0, 8)}...`);
    console.log(`   Track state: enabled=${event.track.enabled}, readyState=${event.track.readyState}, muted=${event.track.muted}`);
    console.log(`   Streams: ${event.streams.length}`);
    
    if (event.streams && event.streams.length > 0) {
      const remoteStream = event.streams[0];
      console.log(`   Remote stream: ${remoteStream.id.substring(0, 8)}... with ${remoteStream.getTracks().length} tracks`);
      
      const remoteVideo = document.getElementById(`video-${userId}`);
      
      if (remoteVideo) {
        // CRITICAL: Set srcObject if not already set or different
        if (!remoteVideo.srcObject || remoteVideo.srcObject.id !== remoteStream.id) {
          console.log(`üì∫ Setting srcObject for ${userId}`);
          remoteVideo.srcObject = remoteStream;
          remoteVideo.muted = false; // Ensure NOT muted for remote
          remoteVideo.volume = 1.0;
          
          // Wait for metadata and play
          remoteVideo.onloadedmetadata = async () => {
            console.log(`üì∫ Metadata loaded for ${userId}: ${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`);
            try {
              await remoteVideo.play();
              console.log(`‚ñ∂Ô∏è Remote video playing for ${userId}`);
              
              // Update visibility based on track type
              if (event.track.kind === 'video' && event.track.enabled) {
                console.log(`üìπ Remote video track enabled for ${userId}`);
                updateVideoVisibility(userId, true, true);
              }
            } catch (playError) {
              console.error(`‚ùå Failed to play remote video for ${userId}:`, playError);
            }
          };
          
          // If metadata already loaded, play immediately
          if (remoteVideo.readyState >= 2) {
            console.log(`üì∫ Metadata already loaded for ${userId}, playing now`);
            remoteVideo.play().catch(e => {
              console.error(`‚ùå Play failed for ${userId}:`, e);
            });
          }
        } else {
          console.log(`‚ÑπÔ∏è Remote video for ${userId} already has correct srcObject`);
        }
        
        // Setup audio detection for remote streams
        if (event.track.kind === 'audio') {
          console.log(`üé§ Setting up audio detection for remote user ${userId}`);
          setupAudioDetection(userId, remoteStream);
        }
        
      } else {
        console.error(`‚ùå Video element not found for ${userId}`);
      }
    } else {
      console.warn(`‚ö†Ô∏è No streams in track event for ${userId}`);
    }
    
    // Track ended handler
    event.track.onended = () => {
      console.log(`üîá Track ended for ${userId}: ${event.track.kind}`);
    };
    
    // Track mute/unmute handlers
    event.track.onmute = () => {
      console.log(`üîá Track muted for ${userId}: ${event.track.kind}`);
    };
    
    event.track.onunmute = () => {
      console.log(`üîä Track unmuted for ${userId}: ${event.track.kind}`);
    };
  };
  
  // CRITICAL: ICE candidate handler with rate limiting
  let lastCandidateEmit = 0;
  const CANDIDATE_EMIT_THROTTLE = 50; // 50ms between emits
  
  pc.onicecandidate = (e) => {
    if (e.candidate) {
      const stats = connectionStats.get(userId);
      if (stats) {
        stats.candidatesSent++;
        stats.lastIceCandidateTime = Date.now();
      }
      
      const candidateType = e.candidate.type || 'unknown';
      const candidateProtocol = e.candidate.protocol || 'unknown';
      
      console.log(`üßä [ICE] Generated ${candidateType} candidate for ${userId} (protocol: ${candidateProtocol})`);
      
      // Throttle candidate emissions
      const now = Date.now();
      if (now - lastCandidateEmit < CANDIDATE_EMIT_THROTTLE) {
        setTimeout(() => {
          socketInstance.emit('ice_candidate', { 
            callId: callData.callId, 
            targetUserId: userId, 
            candidate: e.candidate 
          });
          console.log(`üì§ [ICE] Sent throttled candidate #${stats.candidatesSent} to ${userId}`);
        }, CANDIDATE_EMIT_THROTTLE);
      } else {
        socketInstance.emit('ice_candidate', { 
          callId: callData.callId, 
          targetUserId: userId, 
          candidate: e.candidate 
        });
        console.log(`üì§ [ICE] Sent candidate #${stats.candidatesSent} to ${userId}`);
      }
      lastCandidateEmit = now;
      
    } else {
      console.log(`üßä [ICE] End of candidates for ${userId}`);
      socketInstance.emit('ice_candidate', { 
        callId: callData.callId, 
        targetUserId: userId, 
        candidate: null 
      });
    }
  };
  
  // ICE connection state monitoring
  pc.oniceconnectionstatechange = () => {
    const state = pc.iceConnectionState;
    const stats = connectionStats.get(userId);
    if (stats) stats.iceState = state;
    
    console.log(`üßä [ICE] Connection state for ${userId}: ${state}`);
    
    if (state === 'connected' || state === 'completed') {
      console.log(`‚úÖ [ICE] Connected to ${userId}`);
      
      // Get selected candidate pair for debugging
      pc.getStats().then(stats => {
        stats.forEach(report => {
          if (report.type === 'candidate-pair' && report.state === 'succeeded') {
            console.log(`   Selected pair: ${report.id}`);
            const local = stats.get(report.localCandidateId);
            const remote = stats.get(report.remoteCandidateId);
            if (local && remote) {
              console.log(`   Local: ${local.candidateType} ${local.protocol} ${local.address}:${local.port}`);
              console.log(`   Remote: ${remote.candidateType} ${remote.protocol} ${remote.address}:${remote.port}`);
            }
          }
        });
      });
      
    } else if (state === 'failed') {
      console.error(`‚ùå [ICE] Connection failed for ${userId}`);
      
      // Attempt ICE restart
      if (stats && stats.iceRestartCount < 2) {
        stats.iceRestartCount++;
        console.log(`üîÑ Attempting ICE restart for ${userId} (attempt ${stats.iceRestartCount})`);
        
        setTimeout(() => {
          if (pc.connectionState !== 'closed') {
            createOffer(userId);
          }
        }, 1000);
      }
    } else if (state === 'disconnected') {
      console.warn(`‚ö†Ô∏è [ICE] Disconnected from ${userId}`);
    } else if (state === 'closed') {
      console.log(`üîí [ICE] Connection closed for ${userId}`);
    }
  };
  
  // Connection state monitoring
  pc.onconnectionstatechange = () => {
    const state = pc.connectionState;
    const stats = connectionStats.get(userId);
    if (stats) stats.connectionState = state;
    
    console.log(`üîå [PC] Connection state for ${userId}: ${state}`);
    
    if (state === 'connected') {
      console.log(`‚úÖ [PC] Peer connection established with ${userId}`);
      
      // Emit connection state update
      socketInstance.emit('connection_state_update', {
        callId: callData.callId,
        state: 'connected'
      });
      
    } else if (state === 'failed') {
      console.error(`‚ùå [PC] Connection failed with ${userId}`);
      
      socketInstance.emit('connection_state_update', {
        callId: callData.callId,
        state: 'failed'
      });
      
    } else if (state === 'disconnected') {
      console.warn(`‚ö†Ô∏è [PC] Disconnected from ${userId}`);
    }
  };
  
  monitorConnectionQuality(userId, pc);
  
  peerConnections.set(userId, pc);
  console.log(`‚úÖ PeerConnection created for ${userId} with all handlers`);
  return pc;
}


async function createOffer(userId) {
  // CRITICAL: Check if already making offer
  if (makingOffer.get(userId)) {
    console.warn(`‚ö†Ô∏è Already making offer to ${userId}, skipping`);
    return;
  }
  
  try {
    makingOffer.set(userId, true);
    
    console.log(`üì§ Creating offer for ${userId}`);
    
    // Small delay to ensure remote peer has fully joined
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const pc = createPC(userId);
    
    // Validate local stream
    if (!localStream || localStream.getTracks().length === 0) {
      console.error(`‚ùå No local stream available when creating offer for ${userId}`);
      return;
    }
    
    console.log(`üìä Local stream for offer: ${localStream.getTracks().map(t => `${t.kind}(${t.enabled})`).join(', ')}`);
    
    const offer = await pc.createOffer({ 
      offerToReceiveAudio: true, 
      offerToReceiveVideo: true 
    });
    
    await pc.setLocalDescription(offer);
    
    console.log(`‚úÖ Offer created and set as local description for ${userId}`);
    console.log(`   Offer type: ${offer.type}`);
    console.log(`   Offer SDP length: ${offer.sdp?.length || 0} bytes`);
    console.log(`   PC state: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    socketInstance.emit('webrtc_offer', { 
      callId: callData.callId, 
      targetUserId: userId, 
      offer 
    });
    
    console.log(`üì§ Offer sent to ${userId} via socket`);
    
  } catch (e) { 
    console.error(`‚ùå Offer creation error for ${userId}:`, e);
    console.error(`   Error name: ${e.name}`);
    console.error(`   Error message: ${e.message}`);
  } finally {
    makingOffer.set(userId, false);
  }
}

async function handleOffer(fromUserId, offer) {
  // CRITICAL: Prevent duplicate offer processing with mutex
  if (negotiationMutex.has(fromUserId)) {
    console.warn(`‚ö†Ô∏è Already processing offer from ${fromUserId}, ignoring duplicate`);
    return;
  }
  
  // Create mutex promise
  const mutexPromise = (async () => {
    try {
      console.log(`üì• [OFFER] Received offer from ${fromUserId}`);
      console.log(`   Offer type: ${offer.type}, SDP length: ${offer.sdp?.length || 0}`);
      
      // Validate localStream
      if (!localStream) {
        console.error(`‚ùå CRITICAL: No localStream when handling offer from ${fromUserId}`);
        return;
      }
      
      console.log(`‚úÖ LocalStream validated: ${localStream.getTracks().length} tracks`);
      
      let pc = peerConnections.get(fromUserId);
      
      // CRITICAL: Check for signaling state collision
      const offerCollision = pc && 
        (pc.signalingState !== 'stable' && pc.signalingState !== 'have-local-offer');
      
      // Determine polite/impolite based on user ID comparison
      const polite = currentUser.userId < fromUserId;
      
      console.log(`   Polite: ${polite}, Offer collision: ${offerCollision}`);
      
      // Impolite peer ignores colliding offers
      if (offerCollision && !polite) {
        console.log(`   üö´ Impolite peer ignoring colliding offer from ${fromUserId}`);
        return;
      }
      
      // If PC exists and we have a collision, polite peer uses rollback
      if (offerCollision && polite) {
        console.log(`   üîÑ Polite peer performing rollback for ${fromUserId}`);
        await pc.setLocalDescription({ type: 'rollback' });
        console.log(`   ‚úÖ Rollback complete`);
      }
      
      // Create new PC if needed or if closed
      if (!pc || pc.connectionState === 'closed') {
        console.log(`üîß Creating new PeerConnection for ${fromUserId}`);
        pc = createPC(fromUserId);
      }
      
      console.log(`üîß Setting remote description (offer) for ${fromUserId}`);
      console.log(`   PC state before: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
      
      // CRITICAL: Use Promise.all to queue operations properly
      await Promise.all([
        pc.setRemoteDescription(new RTCSessionDescription(offer)),
        // Queue ICE candidate processing after setRemoteDescription
        new Promise(resolve => setTimeout(resolve, 0))
      ]);
      
      console.log(`‚úÖ Remote description set successfully`);
      console.log(`   PC state after: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
      
      // Inside handleOffer function, replace the pending candidates section:

// Process pending ICE candidates AFTER remote description is set
if (pendingIceCandidates.has(fromUserId)) {
  const cands = pendingIceCandidates.get(fromUserId);
  console.log(`üßä Adding ${cands.length} pending ICE candidates for ${fromUserId}`);
  
  for (const item of cands) {
    try {
      const c = item.candidate;
      
      // Validate before adding
      if (!c.candidate || typeof c.candidate !== 'string') {
        console.warn(`‚ö†Ô∏è Skipping invalid queued candidate`);
        continue;
      }
      
      if (c.sdpMid === null && c.sdpMLineIndex === null) {
        console.warn(`‚ö†Ô∏è Skipping queued candidate with null sdpMid/sdpMLineIndex`);
        continue;
      }
      
      await pc.addIceCandidate(new RTCIceCandidate(c));
      console.log(`‚úÖ Added pending ICE candidate`);
    } catch (e) {
      console.warn(`‚ö†Ô∏è Failed to add queued candidate:`, e.message);
      // Continue with next candidate
    }
  }
  pendingIceCandidates.delete(fromUserId);
}
      
      console.log(`üì§ Creating answer for ${fromUserId}...`);
      
      // Create answer
      const answer = await pc.createAnswer();
      console.log(`   Answer created: type=${answer.type}, SDP length=${answer.sdp?.length || 0}`);
      
      await pc.setLocalDescription(answer);
      console.log(`‚úÖ Answer set as local description`);
      console.log(`   PC state: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
      
      console.log(`üì§ Sending answer to ${fromUserId} via socket`);
      socketInstance.emit('webrtc_answer', { 
        callId: callData.callId, 
        targetUserId: fromUserId, 
        answer 
      });
      console.log(`‚úÖ Answer emitted successfully`);
      
    } catch (e) { 
      console.error(`‚ùå Handle offer error for ${fromUserId}:`, e);
      console.error(`   Error name: ${e.name}`);
      console.error(`   Error message: ${e.message}`);
    } finally {
      // Remove mutex after 100ms to allow for any in-flight duplicates to be caught
      setTimeout(() => {
        negotiationMutex.delete(fromUserId);
      }, 100);
    }
  })();
  
  negotiationMutex.set(fromUserId, mutexPromise);
  await mutexPromise;
}

async function handleAnswer(fromUserId, answer) {
  try {
    console.log(`üì• [ANSWER] Received answer from ${fromUserId}`);
    console.log(`   Answer type: ${answer.type}, SDP length: ${answer.sdp?.length || 0}`);
    
    const pc = peerConnections.get(fromUserId);
    
    if (!pc) {
      console.error(`‚ùå No PC found for ${fromUserId} when handling answer`);
      return;
    }
    
    console.log(`üìä PC state before handling answer: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
    // CRITICAL: Only accept answer if we're in the right state
    if (pc.signalingState !== 'have-local-offer') {
      console.warn(`‚ö†Ô∏è Ignoring answer from ${fromUserId} - wrong state: ${pc.signalingState}`);
      return;
    }
    
    console.log(`üîß Setting remote description (answer) for ${fromUserId}`);
    await pc.setRemoteDescription(new RTCSessionDescription(answer));
    console.log(`‚úÖ Answer set as remote description`);
    console.log(`   PC state after: signalingState=${pc.signalingState}, connectionState=${pc.connectionState}`);
    
   // Inside handleAnswer function, replace the pending candidates section:

// Process pending ICE candidates
if (pendingIceCandidates.has(fromUserId)) {
  const cands = pendingIceCandidates.get(fromUserId);
  console.log(`üßä Adding ${cands.length} pending ICE candidates for ${fromUserId}`);
  
  for (const item of cands) {
    try {
      const c = item.candidate;
      
      // Validate before adding
      if (!c.candidate || typeof c.candidate !== 'string') {
        console.warn(`‚ö†Ô∏è Skipping invalid queued candidate`);
        continue;
      }
      
      if (c.sdpMid === null && c.sdpMLineIndex === null) {
        console.warn(`‚ö†Ô∏è Skipping queued candidate with null sdpMid/sdpMLineIndex`);
        continue;
      }
      
      await pc.addIceCandidate(new RTCIceCandidate(c));
      console.log(`‚úÖ Added pending ICE candidate`);
    } catch (e) {
      console.warn(`‚ö†Ô∏è Failed to add queued candidate:`, e.message);
      // Continue with next candidate
    }
  }
  pendingIceCandidates.delete(fromUserId);
}
    
    console.log(`‚úÖ Answer handling complete for ${fromUserId}`);
    
  } catch (e) { 
    console.error(`‚ùå Handle answer error for ${fromUserId}:`, e);
    console.error(`   Error name: ${e.name}`);
    console.error(`   Error message: ${e.message}`);
  }
}

// Replace handleIceCandidate function
async function handleIceCandidate(fromUserId, candidate) {
  try {
    if (!candidate) {
      console.log(`üßä [ICE] Received end-of-candidates from ${fromUserId}`);
      return;
    }
    
    // CRITICAL FIX: Validate candidate structure before queuing/adding
    if (!candidate.candidate || typeof candidate.candidate !== 'string') {
      console.warn(`‚ö†Ô∏è [ICE] Invalid candidate structure from ${fromUserId}:`, candidate);
      return;
    }
    
    // Additional validation for required fields
    if (candidate.sdpMid === null && candidate.sdpMLineIndex === null) {
      console.warn(`‚ö†Ô∏è [ICE] Candidate missing both sdpMid and sdpMLineIndex from ${fromUserId}, skipping`);
      return;
    }
    
    const pc = peerConnections.get(fromUserId);
    
    // Queue candidates if no PC yet OR if remote description not set
    if (!pc || !pc.remoteDescription) {
      if (!pendingIceCandidates.has(fromUserId)) {
        pendingIceCandidates.set(fromUserId, []);
      }
      
      const queue = pendingIceCandidates.get(fromUserId);
      queue.push({
        candidate: candidate,
        timestamp: Date.now()
      });
      
      console.log(`üßä [ICE] Queued candidate from ${fromUserId} (pending: ${queue.length})`);
      
      // Auto-cleanup old candidates after 30 seconds
      setTimeout(() => {
        const currentQueue = pendingIceCandidates.get(fromUserId);
        if (currentQueue) {
          const filtered = currentQueue.filter(item => Date.now() - item.timestamp < 30000);
          if (filtered.length !== currentQueue.length) {
            console.log(`üßπ [ICE] Cleaned ${currentQueue.length - filtered.length} old candidates for ${fromUserId}`);
            pendingIceCandidates.set(fromUserId, filtered);
          }
        }
      }, 30000);
      
      return;
    }
    
    // Add candidate if PC is ready
    try {
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
      const stats = connectionStats.get(fromUserId);
      if (stats) stats.candidatesReceived++;
      
      const candidateType = candidate.type || candidate.candidate?.split(' ')[7] || 'unknown';
      console.log(`üßä [ICE] Added ${candidateType} candidate from ${fromUserId} (total: ${stats?.candidatesReceived || 0})`);
    } catch (addError) {
      console.warn(`‚ö†Ô∏è [ICE] Failed to add candidate from ${fromUserId}:`, addError.message);
      // Don't throw - continue processing other candidates
    }
    
  } catch (e) { 
    console.warn(`‚ö†Ô∏è [ICE] Candidate processing error for ${fromUserId}:`, e.message);
  }
}

function toggleMic() {
  if (localStream) {
    const track = localStream.getAudioTracks()[0];
    if (track) {
      track.enabled = !track.enabled;
      isAudioEnabled = track.enabled;
      const btn = document.getElementById('micBtn');
      const icon = btn.querySelector('.material-symbols-outlined');
      const mic = document.getElementById(`mic-${currentUser.userId}`);
      
      console.log(`üé§ Mic toggled: ${isAudioEnabled ? 'ON' : 'OFF'}`);
      
      if (isAudioEnabled) {
        btn.classList.add('bg-primary', 'text-white');
        btn.classList.remove('bg-accent-red');
        icon.textContent = 'mic';
        if (mic) mic.classList.add('hidden');
      } else {
        btn.classList.remove('bg-primary');
        btn.classList.add('bg-accent-red', 'text-white');
        icon.textContent = 'mic_off';
        if (mic) mic.classList.remove('hidden');
      }
      
      socketInstance.emit('audio_state_changed', { callId: callData.callId, enabled: isAudioEnabled });
    }
  }
}

async function toggleVideo() {
  if (callData.callType === 'audio') { 
    toast('Video not available in audio call', 'warning'); 
    return; 
  }
  
  if (isTogglingVideo) {
    console.log('‚ö†Ô∏è Video toggle already in progress, ignoring');
    return;
  }
  
  isTogglingVideo = true;
  
  if (!localStream) {
    console.error('‚ùå No localStream available');
    isTogglingVideo = false;
    return;
  }
  
  const track = localStream.getVideoTracks()[0];
  if (!track) {
    console.error('‚ùå No video track available');
    isTogglingVideo = false;
    return;
  }
  
  // Toggle the track enabled state
  const newState = !track.enabled;
  track.enabled = newState;
  isVideoEnabled = newState;
  
  console.log(`üìπ Video toggled locally: ${isVideoEnabled ? 'ON' : 'OFF'}`);
  console.log(`üìπ Track state after toggle: enabled=${track.enabled}, readyState=${track.readyState}, muted=${track.muted}`);
  
  // CRITICAL FIX: Update local video visibility immediately
  const localVid = document.getElementById(`video-${currentUser.userId}`);
  if (localVid && localVid.srcObject) {
    console.log(`üìπ Updating local video element visibility`);
    updateVideoVisibility(currentUser.userId, isVideoEnabled, true);
  }
  
  // Update button state
  updateVideoButton();
  
  // Emit to server (server will broadcast to ALL including us for confirmation)
  socketInstance.emit('video_state_changed', { 
    callId: callData.callId, 
    enabled: isVideoEnabled 
  });
  console.log(`üì§ Emitted video_state_changed to server: ${isVideoEnabled}`);
  
  // Clear toggle lock after a delay
  setTimeout(() => {
    isTogglingVideo = false;
    console.log(`üîì Video toggle unlocked`);
  }, 200);
}

    function updateDuration() {
  const roomStr = localStorage.getItem('currentRoom');
  if (!roomStr) {
    console.warn('‚ö†Ô∏è No room data - cannot sync timer');
    return;
  }
  
  try {
    const roomData = JSON.parse(roomStr);
    
    if (!roomData.expiresAt) {
      console.error('‚ùå No expiresAt in room data');
      return;
    }
    
    // Use stored expiresAt if available, otherwise use from localStorage
    const expiresAt = roomExpiresAt || roomData.expiresAt;
    
    // CRITICAL FIX: Use server-adjusted time
    const clientNow = Date.now();
    const serverNow = clientNow + serverClockOffset; // Adjust for clock skew
    const remaining = Math.max(0, expiresAt - serverNow);
    
    const totalSeconds = Math.floor(remaining / 1000);
    const h = Math.floor(totalSeconds / 3600);
    const m = Math.floor((totalSeconds % 3600) / 60);
    const s = totalSeconds % 60;
    
    const el = document.getElementById('callDuration');
    if (el) {
      el.textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }
    
    // Log every 10 seconds for debugging
    if (totalSeconds % 10 === 0) {
      console.log(`‚è∞ Call timer: ${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')} remaining`);
      console.log(`   Server expiresAt: ${new Date(expiresAt).toISOString()}`);
      console.log(`   Client now: ${new Date(clientNow).toISOString()}`);
      console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
      console.log(`   Clock offset: ${(serverClockOffset / 1000).toFixed(1)}s`);
    }
    
    if (remaining === 0) {
      console.log('‚è∞ Room expired during call - ending call');
      if (durationInterval) clearInterval(durationInterval);
      toast('Room has expired', 'warning');
      leaveCall();
    }
  } catch (e) {
    console.error('‚ùå Timer sync error:', e);
  }
}

      function leaveCall() {
        if (isInitializing) return;
        isInitializing = true;
        audioContexts.forEach(c => c.close());
        audioContexts.clear();
        if (localStream) localStream.getTracks().forEach(t => t.stop());
        peerConnections.forEach(pc => pc.close());
        peerConnections.clear();
        if (socketInstance && socketInstance.connected) socketInstance.emit('leave_call', { callId: callData.callId });
        if (durationInterval) clearInterval(durationInterval);
        localStorage.removeItem('activeCall');
        setTimeout(() => { window.location.href = '/chat.html'; }, 500);
      }
      
      
      
      // Add this helper function before initCall()
let joinCallRetryCount = 0;
const MAX_JOIN_RETRIES = 3;

async function attemptJoinCall(callId, retryDelay = 1000) {
  return new Promise((resolve, reject) => {
    console.log(`üîÑ Attempting to join call (attempt ${joinCallRetryCount + 1}/${MAX_JOIN_RETRIES})`);
    
    socketInstance.emit('join_call', { callId });
    
    // Set timeout for response
    const timeout = setTimeout(() => {
      joinCallRetryCount++;
      
      if (joinCallRetryCount < MAX_JOIN_RETRIES) {
        console.warn(`‚ö†Ô∏è Join call timeout, retrying in ${retryDelay}ms...`);
        setTimeout(() => {
          attemptJoinCall(callId, retryDelay * 1.5).then(resolve).catch(reject);
        }, retryDelay);
      } else {
        reject(new Error('Failed to join call after maximum retries'));
      }
    }, 5000); // 5 second timeout per attempt
    
    // Listen for successful join (one-time)
    const handleJoined = (data) => {
      clearTimeout(timeout);
      joinCallRetryCount = 0; // Reset on success
      console.log(`‚úÖ Join call succeeded on attempt ${joinCallRetryCount + 1}`);
      socketInstance.off('call_joined', handleJoined);
      socketInstance.off('error', handleError);
      resolve(data);
    };
    
    const handleError = (errorData) => {
      clearTimeout(timeout);
      socketInstance.off('call_joined', handleJoined);
      socketInstance.off('error', handleError);
      reject(new Error(errorData.message || 'Join call failed'));
    };
    
    socketInstance.once('call_joined', handleJoined);
    socketInstance.once('error', handleError);
  });
}
      

      async function initCall() {
        if (isInitializing) return;
        isInitializing = true;
        console.log('=== INIT CALL ===');
        
        try {
          await _Auth.requireAuth();
          await fetchIceServers();
          
          const callStr = localStorage.getItem('activeCall');
          if (!callStr) { toast('No active call', 'error'); setTimeout(() => window.location.href = '/chat.html', 1500); return; }
          
          callData = JSON.parse(callStr);
          console.log(`üìû Call: ${callData.callId} (${callData.callType})`);
          
          const firebaseUser = firebase.auth().currentUser;
          if (!firebaseUser) { window.location.href = '/login.html'; return; }
          
          const userData = await _API.get('/api/users/me');
          currentUser = { userId: userData._id, username: userData.username, pfpUrl: userData.pfpUrl };
          console.log(`üë§ Current user: ${currentUser.username} (${currentUser.userId})`);
          
          const title = document.getElementById('callTitle');
          if (title) title.textContent = `${callData.callType === 'video' ? 'Video' : 'Audio'} Call`;
          
          const token = await firebaseUser.getIdToken();
          socketInstance = io(window.location.origin, {
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            auth: { token }
          });
          
          socketInstance.on('connect', () => {
            console.log(`üîå Connected: ${socketInstance.id}`);
            socketInstance.emit('authenticate', { token, userId: currentUser.userId });
          });
          
          // Inside initCall() function, replace the 'authenticated' handler:



socketInstance.on('room_expired', (data) => {
  console.error('üí• ========================================');
  console.error('üí• ROOM_EXPIRED EVENT RECEIVED FROM SERVER');
  console.error('üí• ========================================');
  console.error(`   roomId: ${data.roomId}`);
  console.error(`   message: ${data.message}`);
  console.error(`   Server says room expired at: ${new Date().toISOString()}`);
  
  if (roomExpiresAt) {
    const serverExpiry = new Date(roomExpiresAt).toISOString();
    const clientNow = new Date().toISOString();
    const serverNow = new Date(Date.now() + serverClockOffset).toISOString();
    console.error(`   expiresAt was: ${serverExpiry}`);
    console.error(`   Client time now: ${clientNow}`);
    console.error(`   Server time now (adjusted): ${serverNow}`);
  }
  
  console.error('üí• ========================================\n');
  
  if (durationInterval) clearInterval(durationInterval);
  toast(data.message || 'Room has expired', 'warning');
  
  // Clean up and redirect
  leaveCall();
});

socketInstance.on('room_expiring_soon', (data) => {
  console.warn('‚ö†Ô∏è ========================================');
  console.warn('‚ö†Ô∏è ROOM EXPIRING SOON');
  console.warn('‚ö†Ô∏è ========================================');
  console.warn(`   Expires in: ${data.expiresIn / 1000} seconds`);
  console.warn(`   expiresAt: ${new Date(data.expiresAt).toISOString()}`);
  
  const clientNow = Date.now();
  const serverNow = clientNow + serverClockOffset;
  const remaining = data.expiresAt - serverNow;
  
  console.warn(`   Client now: ${new Date(clientNow).toISOString()}`);
  console.warn(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
  console.warn(`   Remaining (adjusted): ${(remaining / 1000).toFixed(1)}s`);
  console.warn('‚ö†Ô∏è ========================================\n');
  
  toast(`Room expiring soon!`, 'warning');
});

socketInstance.on('authenticated', async () => {
  console.log('‚úÖ Authenticated');
  
  // CRITICAL: Request room data from server to get clock sync
  const roomStr = localStorage.getItem('currentRoom');
  if (roomStr) {
    try {
      const roomData = JSON.parse(roomStr);
      console.log('üì¶ Requesting fresh room data for clock sync...');
      
      // Emit a request for fresh room data (you'll need to add this handler on server)
      socketInstance.emit('request_room_sync', { roomId: roomData.roomId });
      
    } catch (e) {
      console.error('‚ùå Failed to parse room data:', e);
    }
  }
  
  // CRITICAL FIX: Prevent duplicate join attempts
  if (isJoiningCall) {
    console.warn(`‚ö†Ô∏è Already joining call, ignoring duplicate authenticated event`);
    return;
  }
  
  if (!hasJoinedCall) {
    isJoiningCall = true;
    hasJoinedCall = true;
    
    try {
      console.log(`üìû Attempting to join call ${callData.callId}...`);
      await attemptJoinCall(callData.callId);
      console.log(`‚úÖ Successfully joined call ${callData.callId}`);
    } catch (error) {
      console.error('‚ùå Failed to join call:', error);
      toast('Failed to join call. Returning to chat...', 'error');
      setTimeout(() => {
        window.location.href = '/chat.html';
      }, 2000);
    } finally {
      isJoiningCall = false;
    }
  }
});


socketInstance.on('room_sync_data', (data) => {
  console.log('‚è∞ ========================================');
  console.log('‚è∞ ROOM SYNC DATA RECEIVED');
  console.log('‚è∞ ========================================');
  
  const clientNow = Date.now();
  
  if (!data.serverTime) {
    console.warn('‚ö†Ô∏è No serverTime in sync data, assuming no clock skew');
    data.serverTime = clientNow;
  }
  
  // Calculate clock offset
  serverClockOffset = data.serverTime - clientNow;
  
  console.log(`   Server time: ${new Date(data.serverTime).toISOString()}`);
  console.log(`   Client time: ${new Date(clientNow).toISOString()}`);
  console.log(`   ‚è∞ CLOCK OFFSET: ${(serverClockOffset / 1000).toFixed(1)}s`);
  
  if (Math.abs(serverClockOffset) > 5000) {
    console.warn(`‚ö†Ô∏è WARNING: Large clock skew detected (${(serverClockOffset / 1000).toFixed(1)}s)`);
    console.warn(`   Timer will be adjusted to compensate`);
  }
  
  if (data.expiresAt) {
    roomExpiresAt = data.expiresAt;
    
    // Calculate time remaining using server-adjusted time
    const serverNow = clientNow + serverClockOffset;
    const timeRemaining = data.expiresAt - serverNow;
    
    console.log(`   Expires at: ${new Date(data.expiresAt).toISOString()}`);
    console.log(`   Server now (adjusted): ${new Date(serverNow).toISOString()}`);
    console.log(`   Time remaining (adjusted): ${(timeRemaining / 1000).toFixed(1)}s`);
    
    // Update localStorage with synced data
    const roomStr = localStorage.getItem('currentRoom');
    if (roomStr) {
      try {
        const roomData = JSON.parse(roomStr);
        roomData.expiresAt = data.expiresAt;
        localStorage.setItem('currentRoom', JSON.stringify(roomData));
        console.log('‚úÖ Updated localStorage with server expiry time');
      } catch (e) {
        console.error('‚ùå Failed to update localStorage:', e);
      }
    }
  }
  
  console.log('‚è∞ ========================================\n');
  
  // Force timer update with new data
  updateDuration();
});
          
          
socketInstance.on('webrtc_offer', (d) => {
  console.log(`üîî [SOCKET] webrtc_offer event received from ${d.fromUserId}`);
  handleOffer(d.fromUserId, d.offer);
});

socketInstance.on('webrtc_answer', (d) => {
  console.log(`üîî [SOCKET] webrtc_answer event received from ${d.fromUserId}`);
  handleAnswer(d.fromUserId, d.answer);
});

socketInstance.on('ice_candidate', (d) => {
  console.log(`üîî [SOCKET] ice_candidate event received from ${d.fromUserId}`);
  handleIceCandidate(d.fromUserId, d.candidate);
});
          
          
socketInstance.on('call_joined', async (data) => {
  console.log(`‚úÖ ========================================`);
  console.log(`‚úÖ CALL_JOINED EVENT RECEIVED`);
  console.log(`‚úÖ ========================================`);
  console.log(`üìä Participants: ${data.participants.length}`);
  
  // Log all participants
  data.participants.forEach((p, i) => {
    console.log(`   [${i}] ${p.username} (${p.userId}) video:${p.videoEnabled} audio:${p.audioEnabled}`);
  });
  
  if (!data.participants || data.participants.length === 0) {
    console.error('‚ùå Received call_joined with 0 participants!');
    toast('Call state error. Please try again.', 'error');
    setTimeout(() => {
      window.location.href = '/chat.html';
    }, 2000);
    return;
  }
  
  const subtitle = document.getElementById('callSubtitle');
  if (subtitle) subtitle.textContent = `${data.participants.length} participant${data.participants.length>1?'s':''}`;
  
  console.log(`üé¨ Initializing local media...`);
  try {
    await initLocalMedia();
    console.log(`‚úÖ Local media initialized successfully`);
  } catch (mediaError) {
    console.error(`‚ùå Media initialization failed:`, mediaError);
    toast('Failed to initialize media.', 'error');
  }
  
  if (!localStream) {
    console.error(`‚ùå CRITICAL: localStream is still null!`);
    localStream = new MediaStream();
  }
  
  console.log(`üìä LocalStream: ${localStream.getTracks().length} tracks`);
  localStream.getTracks().forEach((track, i) => {
    console.log(`   [${i}] ${track.kind} (${track.id.substring(0, 8)}...) enabled:${track.enabled}`);
  });
  
  const grid = document.getElementById('participantGrid');
  if (!grid) {
    console.error('‚ùå Grid element not found!');
    return;
  }
  
  const fragment = document.createDocumentFragment();
  
  console.log(`üßπ Clearing grid and tracking`);
  grid.innerHTML = '';
  renderedParticipants.clear();
  
  console.log(`üìã Rendering ${data.participants.length} tiles`);
  
  const sortedParticipants = [...data.participants].sort((a, b) => 
    a.userId.localeCompare(b.userId)
  );
  
  let selfTileRendered = false;
  
  sortedParticipants.forEach((p, index) => {
    const isSelf = p.userId === currentUser.userId;
    const videoState = p.videoEnabled !== undefined ? p.videoEnabled : (callData.callType === 'video');
    const audioState = p.audioEnabled !== undefined ? p.audioEnabled : true;
    
    console.log(`[${index}] Rendering ${p.username} (${p.userId}) isSelf=${isSelf} video=${videoState} audio=${audioState}`);
    
    const tile = createParticipantTile(p, isSelf);
    if (tile) {
      fragment.appendChild(tile);
      console.log(`‚úÖ [${index}] Tile created for ${p.username}`);
      
      if (isSelf) selfTileRendered = true;
      
      if (audioState === false) {
        const micIndicator = tile.querySelector(`#mic-${p.userId}`);
        if (micIndicator) {
          micIndicator.classList.remove('hidden');
          console.log(`   üîá Mic indicator shown for ${p.username}`);
        }
      }
      
      if (!isSelf && videoState === false) {
        const vid = tile.querySelector(`#video-${p.userId}`);
        const pfp = tile.querySelector(`#pfp-${p.userId}`);
        if (vid && pfp) {
          vid.classList.add('hidden');
          pfp.classList.remove('hidden');
          console.log(`   üìπ Video hidden for ${p.username}`);
        }
      }
    }
  });
  
  grid.appendChild(fragment);
  
  console.log(`üé® Grid complete: ${grid.children.length} tiles`);
  console.log(`üìä Rendered participants:`, Array.from(renderedParticipants));
  
  if (selfTileRendered) {
    console.log(`üé¨ Setting up local video...`);
    await setupLocalVideo();
  } else {
    console.warn(`‚ö†Ô∏è Self tile not rendered!`);
  }
  
  const remoteParticipants = sortedParticipants.filter(p => p.userId !== currentUser.userId);
  
  console.log(`üîó Processing ${remoteParticipants.length} remote participants for WebRTC...`);
  
  for (let i = 0; i < remoteParticipants.length; i++) {
    const p = remoteParticipants[i];
    const shouldInitiateOffer = currentUser.userId < p.userId;
    
    console.log(`üîó [${i}] ${p.username} (${p.userId}): shouldInitiate=${shouldInitiateOffer}`);
    
    if (shouldInitiateOffer) {
      const delay = 1000 + (i * 500);
      console.log(`   ‚è±Ô∏è Will create offer in ${delay}ms`);
      setTimeout(() => {
        console.log(`üì§ [${i}] Creating offer to ${p.username}`);
        createOffer(p.userId);
      }, delay);
    } else {
      console.log(`   ‚è≥ Will wait for offer from ${p.username}`);
    }
  }
  
  console.log('‚è∞ Starting synced timer with room expiry and clock compensation');
  console.log(`   Clock offset: ${(serverClockOffset / 1000).toFixed(1)}s`);
  
  durationInterval = setInterval(updateDuration, 1000);
  updateDuration(); // Update immediately
  
  isInitializing = false;
  console.log('‚úÖ ========================================');
  console.log('‚úÖ INIT COMPLETE');
  console.log('‚úÖ ========================================\n');
});
          
// Replace the entire user_joined_call handler
socketInstance.on('user_joined_call', (data) => {
  const videoState = data.user.videoEnabled !== undefined ? data.user.videoEnabled : (callData.callType === 'video');
  const audioState = data.user.audioEnabled !== undefined ? data.user.audioEnabled : true;
  
  console.log(`üëã User joined event: ${data.user.username} (${data.user.userId}) video:${videoState} audio:${audioState}`);
  
  // CRITICAL FIX: Check if this is a duplicate event for already-rendered participant
  if (renderedParticipants.has(data.user.userId)) {
    console.warn(`‚ö†Ô∏è Participant ${data.user.username} already rendered, ignoring duplicate user_joined_call`);
    return;
  }
  
  const grid = document.getElementById('participantGrid');
  const existingTile = document.getElementById(`participant-${data.user.userId}`);
  
  if (existingTile) {
    console.warn(`‚ö†Ô∏è Tile already exists in DOM for ${data.user.username}, removing old tile`);
    existingTile.remove();
    renderedParticipants.delete(data.user.userId);
  }
  
  console.log(`‚ûï Adding NEW participant ${data.user.username}`);
  
  if (grid) {
    const isSelf = data.user.userId === currentUser.userId;
    const tile = createParticipantTile(data.user, isSelf);
    
    if (tile) {
      grid.appendChild(tile);
      
      const micIndicator = document.getElementById(`mic-${data.user.userId}`);
      if (micIndicator && audioState === false) {
        micIndicator.classList.remove('hidden');
      }
      
      // CRITICAL FIX: If this is our own tile, setup local video NOW
      if (isSelf) {
        console.log(`‚úÖ Self tile created via user_joined_call - setting up local video...`);
        setupLocalVideo().catch(err => {
          console.error('‚ùå Failed to setup local video for self:', err);
        });
      } else {
        // For remote users, initiate connection with delay to avoid race
        const shouldInitiateOffer = currentUser.userId < data.user.userId;
        if (shouldInitiateOffer) {
          setTimeout(() => {
            console.log(`üì§ Creating offer to late joiner ${data.user.username}`);
            createOffer(data.user.userId);
          }, 2000); // Increased delay to 2s
        }
      }
      
      console.log(`‚úÖ Tile rendered for ${data.user.username}, tracking set updated`);
    }
  }
});
          
         // Replace user_left_call handler
socketInstance.on('user_left_call', (data) => {
  console.log(`üëã User left: ${data.userId}`);
  
  // Remove tile
  const tile = document.getElementById(`participant-${data.userId}`);
  if (tile) tile.remove();
  renderedParticipants.delete(data.userId);
  
  // Clean up peer connection
  const pc = peerConnections.get(data.userId);
  if (pc) { 
    pc.close(); 
    peerConnections.delete(data.userId); 
  }
  
  // Clean up audio context
  const ac = audioContexts.get(data.userId);
  if (ac) { 
    ac.close(); 
    audioContexts.delete(data.userId); 
  }
  
  // Clean up connection stats and monitoring
  const stats = connectionStats.get(data.userId);
  if (stats && stats.monitorInterval) {
    clearInterval(stats.monitorInterval);
  }
  connectionStats.delete(data.userId);
  
  // Clean up pending candidates
  pendingIceCandidates.delete(data.userId);
  
  // Clean up negotiation mutex
  negotiationMutex.delete(data.userId);
  makingOffer.delete(data.userId);
  
  console.log(`‚úÖ Fully cleaned up resources for ${data.userId}`);
});
          
          socketInstance.on('webrtc_offer', (d) => handleOffer(d.fromUserId, d.offer));
          socketInstance.on('webrtc_answer', (d) => handleAnswer(d.fromUserId, d.answer));
          socketInstance.on('ice_candidate', (d) => handleIceCandidate(d.fromUserId, d.candidate));
          
          socketInstance.on('speaking_state', (d) => {
            const s = document.getElementById(`speaking-${d.userId}`);
            const t = document.getElementById(`participant-${d.userId}`);
            if (s && t) {
              if (d.speaking) { s.classList.remove('hidden'); t.classList.add('active-speaker'); }
              else { s.classList.add('hidden'); t.classList.remove('active-speaker'); }
            }
          });
          
          socketInstance.on('audio_state_changed', (data) => {
  console.log(`üé§ Received audio_state_changed: userId=${data.userId}, enabled=${data.enabled}`);
  
  const micIndicator = document.getElementById(`mic-${data.userId}`);
  if (micIndicator) {
    if (data.enabled) {
      micIndicator.classList.add('hidden');
    } else {
      micIndicator.classList.remove('hidden');
    }
  }
});

socketInstance.on('video_state_changed', (data) => {
  console.log(`üìπ [SOCKET] Received video_state_changed: userId=${data.userId}, enabled=${data.enabled}`);
  
  // CRITICAL FIX: Update visibility for BOTH self and remote users
  if (data.userId === currentUser.userId) {
    console.log(`üìπ Confirming our own video state from server: ${data.enabled}`);
    // Server confirms our state - update UI if out of sync
    if (isVideoEnabled !== data.enabled) {
      console.warn(`‚ö†Ô∏è Local state (${isVideoEnabled}) out of sync with server (${data.enabled}), correcting...`);
      isVideoEnabled = data.enabled;
      updateVideoButton();
    }
    updateVideoVisibility(currentUser.userId, data.enabled, true);
  } else {
    // For remote users, update visibility
    console.log(`üìπ Updating remote user ${data.userId} video visibility: ${data.enabled}`);
    updateVideoVisibility(data.userId, data.enabled, true);
  }
});
          
          socketInstance.on('call_ended', () => { toast('Call ended', 'warning'); leaveCall(); });
          
          const mic = document.getElementById('micBtn');
          const vid = document.getElementById('videoBtn');
          const leave = document.getElementById('leaveCallBtn');
          if (mic) mic.addEventListener('click', toggleMic);
          if (vid) vid.addEventListener('click', toggleVideo);
          if (leave) leave.addEventListener('click', leaveCall);
          window.addEventListener('beforeunload', () => leaveCall());
          
        } catch (e) {
          console.error('‚ùå Init error:', e);
          toast('Failed to initialize call', 'error');
          isInitializing = false;
          setTimeout(() => window.location.href = '/chat.html', 2000);
        }
      }

      console.log('‚úÖ Page loaded - starting initialization');
      initCall();
    })();
    </script>
</body>
</html>
